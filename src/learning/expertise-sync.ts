/**
 * Expertise Sync System - Self-Improving Agent Experts
 *
 * Implements the TAC Agent Experts Pattern (Act → Learn → Reuse) by:
 * 1. Detecting code changes in domain-specific areas
 * 2. Generating self-improve prompts to analyze changes
 * 3. Updating expertise YAML files with new learnings
 * 4. Providing expertise context for future agent sessions
 *
 * Domains: database, gateway, security, channel
 */

import fs from "node:fs/promises";
import path from "node:path";
import { normalizeAgentId } from "../routing/session-key.js";
import { resolveStateDir } from "../config/paths.js";
import { appendJournalEntry, type JournalEventSource } from "./journal.js";

// ============================================================================
// Types & Interfaces
// ============================================================================

/** Supported expert domains based on PRD */
export type ExpertDomain = "database" | "gateway" | "security" | "channel";

/** Confidence level for expertise entries */
export type ExpertiseConfidence = "high" | "medium" | "low";

/** Source of expertise knowledge */
export type ExpertiseSource =
  | "code_analysis" // From analyzing source code
  | "git_commit" // From git commit analysis
  | "conversation" // From agent conversation learnings
  | "manual" // Manually added by user
  | "self_improve"; // Generated by self-improve prompt

/** A single expertise entry (knowledge item) */
export interface ExpertiseEntry {
  /** Unique identifier */
  id: string;
  /** Brief description of the knowledge */
  summary: string;
  /** Detailed knowledge content */
  content: string;
  /** Confidence in this knowledge */
  confidence: ExpertiseConfidence;
  /** Source of this knowledge */
  source: ExpertiseSource;
  /** File paths this knowledge relates to */
  relatedFiles: string[];
  /** Tags for categorization */
  tags: string[];
  /** When this was first captured */
  createdAt: string;
  /** When this was last updated */
  updatedAt: string;
  /** Evidence or context supporting this knowledge */
  evidence?: string;
  /** Whether this entry is active */
  active: boolean;
}

/** Mental model for a specific domain */
export interface DomainExpertise {
  /** Domain identifier */
  domain: ExpertDomain;
  /** Human-readable domain name */
  name: string;
  /** Brief description of domain scope */
  description: string;
  /** File patterns that belong to this domain */
  filePatterns: string[];
  /** Key architectural decisions */
  decisions: ExpertiseEntry[];
  /** Common patterns and conventions */
  patterns: ExpertiseEntry[];
  /** Known gotchas and pitfalls */
  pitfalls: ExpertiseEntry[];
  /** Best practices for this domain */
  bestPractices: ExpertiseEntry[];
  /** Schema version for migrations */
  version: number;
  /** Last sync timestamp */
  lastSync: string;
}

/** Result of analyzing code changes */
export interface CodeChangeAnalysis {
  /** Files that changed */
  changedFiles: string[];
  /** Domains affected */
  affectedDomains: ExpertDomain[];
  /** Summary of changes */
  summary: string;
  /** Suggested areas to update expertise */
  suggestions: string[];
}

/** A self-improve prompt for updating expertise */
export interface SelfImprovePrompt {
  /** Domain this prompt targets */
  domain: ExpertDomain;
  /** Type of prompt */
  promptType: "review" | "extract" | "validate" | "consolidate";
  /** The prompt content */
  prompt: string;
  /** Context files to include */
  contextFiles: string[];
  /** Expected output format */
  outputFormat: "entries" | "validation" | "summary";
}

/** Result of applying a self-improve prompt */
export interface SelfImproveResult {
  /** Entries that were added */
  added: ExpertiseEntry[];
  /** Entries that were updated */
  updated: ExpertiseEntry[];
  /** Entries that were marked inactive */
  deactivated: string[];
  /** Summary of changes */
  summary: string;
  /** Timestamp of improvement */
  timestamp: string;
}

/** Configuration for expertise sync */
export interface ExpertiseSyncConfig {
  /** Minimum confidence to keep entries */
  minConfidence: ExpertiseConfidence;
  /** Maximum entries per category */
  maxEntriesPerCategory: number;
  /** Days before low-confidence entries decay */
  decayDays: number;
  /** Enable automatic sync on code changes */
  autoSync: boolean;
  /** File patterns to ignore */
  ignorePatterns: string[];
}

// ============================================================================
// Constants
// ============================================================================

/** Default configuration */
export const defaultSyncConfig: ExpertiseSyncConfig = {
  minConfidence: "low",
  maxEntriesPerCategory: 50,
  decayDays: 90,
  autoSync: true,
  ignorePatterns: ["node_modules/**", "dist/**", "*.test.ts", "*.spec.ts"],
};

/** Domain definitions with file patterns */
export const DOMAIN_DEFINITIONS: Record<
  ExpertDomain,
  { name: string; description: string; filePatterns: string[] }
> = {
  database: {
    name: "Database Expert",
    description: "Data persistence, storage, and query patterns",
    filePatterns: [
      "**/db/**",
      "**/database/**",
      "**/store/**",
      "**/storage/**",
      "**/*-store.ts",
      "**/learnings-store.ts",
      "**/sessions/**",
      "**/migration/**",
    ],
  },
  gateway: {
    name: "Gateway Expert",
    description: "WebSocket server, session management, and request routing",
    filePatterns: [
      "**/gateway/**",
      "**/websocket/**",
      "**/ws/**",
      "**/routing/**",
      "**/session*.ts",
      "**/provider*.ts",
    ],
  },
  security: {
    name: "Security Expert",
    description: "Authentication, authorization, sandboxing, and credential handling",
    filePatterns: [
      "**/auth/**",
      "**/security/**",
      "**/credentials/**",
      "**/sandbox/**",
      "**/permission*.ts",
      "**/allowlist*.ts",
      "**/policy*.ts",
    ],
  },
  channel: {
    name: "Channel Expert",
    description: "Messaging channel integrations (WhatsApp, Telegram, Discord, etc.)",
    filePatterns: [
      "**/channels/**",
      "**/telegram/**",
      "**/discord/**",
      "**/slack/**",
      "**/signal/**",
      "**/imessage/**",
      "**/whatsapp/**",
      "**/web/**",
      "**/extensions/**",
    ],
  },
};

/** Current schema version for expertise files */
const EXPERTISE_SCHEMA_VERSION = 1;

/** Filename for expertise YAML storage */
const EXPERTISE_FILENAME = "expertise.yaml";

// ============================================================================
// File Path Resolution
// ============================================================================

/**
 * Resolve the expertise storage directory for an agent
 */
function resolveExpertiseDir(agentId: string): string {
  const id = normalizeAgentId(agentId);
  const root = resolveStateDir();
  return path.join(root, "agents", id, "expertise");
}

/**
 * Resolve the path to a domain expertise file
 */
export function resolveDomainExpertisePath(agentId: string, domain: ExpertDomain): string {
  return path.join(resolveExpertiseDir(agentId), `${domain}-${EXPERTISE_FILENAME}`);
}

/**
 * Resolve the path to expertise sync state file
 */
export function resolveSyncStatePath(agentId: string): string {
  return path.join(resolveExpertiseDir(agentId), "sync-state.json");
}

// ============================================================================
// ID Generation
// ============================================================================

/**
 * Generate a unique expertise entry ID
 */
function generateEntryId(): string {
  return `exp_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
}

// ============================================================================
// YAML Serialization (Simple Format)
// ============================================================================

/**
 * Serialize domain expertise to YAML-like format
 * Uses a simple structured text format for human readability
 */
export function serializeExpertise(expertise: DomainExpertise): string {
  const lines: string[] = [];

  lines.push(`# ${expertise.name}`);
  lines.push(`# ${expertise.description}`);
  lines.push(`# Last sync: ${expertise.lastSync}`);
  lines.push(`# Version: ${expertise.version}`);
  lines.push("");

  lines.push(`domain: ${expertise.domain}`);
  lines.push(`name: ${expertise.name}`);
  lines.push(`description: ${expertise.description}`);
  lines.push("");

  lines.push("file_patterns:");
  for (const pattern of expertise.filePatterns) {
    lines.push(`  - ${pattern}`);
  }
  lines.push("");

  // Serialize each category
  const categories: Array<{ key: keyof DomainExpertise; name: string }> = [
    { key: "decisions", name: "Architectural Decisions" },
    { key: "patterns", name: "Patterns & Conventions" },
    { key: "pitfalls", name: "Pitfalls & Gotchas" },
    { key: "bestPractices", name: "Best Practices" },
  ];

  for (const { key, name } of categories) {
    const entries = expertise[key] as ExpertiseEntry[];
    if (entries.length === 0) continue;

    lines.push(`# ${name}`);
    lines.push(`${key}:`);

    for (const entry of entries) {
      if (!entry.active) continue;
      lines.push(`  - id: ${entry.id}`);
      lines.push(`    summary: ${entry.summary}`);
      lines.push(`    content: |`);
      // Indent content lines
      for (const contentLine of entry.content.split("\n")) {
        lines.push(`      ${contentLine}`);
      }
      lines.push(`    confidence: ${entry.confidence}`);
      lines.push(`    source: ${entry.source}`);
      if (entry.tags.length > 0) {
        lines.push(`    tags: [${entry.tags.join(", ")}]`);
      }
      if (entry.relatedFiles.length > 0) {
        lines.push(`    related_files:`);
        for (const file of entry.relatedFiles) {
          lines.push(`      - ${file}`);
        }
      }
      lines.push(`    created_at: ${entry.createdAt}`);
      lines.push(`    updated_at: ${entry.updatedAt}`);
      lines.push("");
    }
  }

  return lines.join("\n");
}

/**
 * Parse domain expertise from YAML-like format
 */
export function parseExpertise(content: string, domain: ExpertDomain): DomainExpertise {
  const expertise = createEmptyExpertise(domain);
  const lines = content.split("\n");
  let currentSection: string | null = null;
  let currentEntry: Partial<ExpertiseEntry> | null = null;
  let inMultilineContent = false;
  let multilineContent: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();

    // Skip comments and empty lines at top level
    if (trimmed.startsWith("#") || trimmed === "") {
      if (!inMultilineContent) continue;
    }

    // Handle multiline content
    if (inMultilineContent) {
      if (line.startsWith("      ")) {
        multilineContent.push(line.slice(6));
        continue;
      } else {
        // End of multiline content
        if (currentEntry) {
          currentEntry.content = multilineContent.join("\n");
        }
        inMultilineContent = false;
        multilineContent = [];
      }
    }

    // Parse key-value pairs
    const kvMatch = trimmed.match(/^(\w+):\s*(.*)$/);
    if (kvMatch) {
      const [, key, value] = kvMatch;

      // Section markers - save previous entry before switching sections
      if (["decisions", "patterns", "pitfalls", "bestPractices"].includes(key)) {
        if (currentEntry && currentEntry.id && currentSection) {
          saveEntry(expertise, currentSection, currentEntry as ExpertiseEntry);
          currentEntry = null;
        }
        currentSection = key;
        continue;
      }

      // Top-level fields
      if (key === "domain") {
        expertise.domain = value as ExpertDomain;
      } else if (key === "name") {
        expertise.name = value;
      } else if (key === "description") {
        expertise.description = value;
      }

      // Entry fields
      if (currentEntry) {
        if (key === "id") {
          currentEntry.id = value;
        } else if (key === "summary") {
          currentEntry.summary = value;
        } else if (key === "content") {
          if (value === "|") {
            inMultilineContent = true;
            multilineContent = [];
          } else {
            currentEntry.content = value;
          }
        } else if (key === "confidence") {
          currentEntry.confidence = value as ExpertiseConfidence;
        } else if (key === "source") {
          currentEntry.source = value as ExpertiseSource;
        } else if (key === "tags") {
          // Parse [tag1, tag2] format
          const tagsMatch = value.match(/\[(.*)\]/);
          if (tagsMatch) {
            currentEntry.tags = tagsMatch[1].split(",").map((t) => t.trim());
          }
        } else if (key === "created_at") {
          currentEntry.createdAt = value;
        } else if (key === "updated_at") {
          currentEntry.updatedAt = value;
        }
      }
    }

    // New entry marker
    if (trimmed.startsWith("- id:") && currentSection) {
      // Save previous entry
      if (currentEntry && currentEntry.id && currentSection) {
        saveEntry(expertise, currentSection, currentEntry as ExpertiseEntry);
      }

      // Start new entry
      const idMatch = trimmed.match(/^- id:\s*(.+)$/);
      currentEntry = {
        id: idMatch ? idMatch[1] : generateEntryId(),
        tags: [],
        relatedFiles: [],
        active: true,
      };
    }

    // Related files list
    if (trimmed.startsWith("- ") && lines[i - 1]?.trim() === "related_files:") {
      const file = trimmed.slice(2);
      if (currentEntry?.relatedFiles) {
        currentEntry.relatedFiles.push(file);
      }
    }
  }

  // Save last entry
  if (currentEntry && currentEntry.id && currentSection) {
    saveEntry(expertise, currentSection, currentEntry as ExpertiseEntry);
  }

  return expertise;
}

/**
 * Helper to save an entry to the appropriate category
 */
function saveEntry(expertise: DomainExpertise, section: string, entry: ExpertiseEntry): void {
  const fullEntry: ExpertiseEntry = {
    id: entry.id || generateEntryId(),
    summary: entry.summary || "",
    content: entry.content || "",
    confidence: entry.confidence || "medium",
    source: entry.source || "manual",
    relatedFiles: entry.relatedFiles || [],
    tags: entry.tags || [],
    createdAt: entry.createdAt || new Date().toISOString(),
    updatedAt: entry.updatedAt || new Date().toISOString(),
    active: entry.active !== false,
  };

  const category = section as keyof Pick<
    DomainExpertise,
    "decisions" | "patterns" | "pitfalls" | "bestPractices"
  >;
  if (expertise[category]) {
    expertise[category].push(fullEntry);
  }
}

// ============================================================================
// Expertise CRUD Operations
// ============================================================================

/**
 * Create an empty expertise object for a domain
 */
export function createEmptyExpertise(domain: ExpertDomain): DomainExpertise {
  const def = DOMAIN_DEFINITIONS[domain];
  return {
    domain,
    name: def.name,
    description: def.description,
    filePatterns: [...def.filePatterns],
    decisions: [],
    patterns: [],
    pitfalls: [],
    bestPractices: [],
    version: EXPERTISE_SCHEMA_VERSION,
    lastSync: new Date().toISOString(),
  };
}

/**
 * Load expertise for a domain
 * Uses JSON for internal storage to preserve all metadata including inactive entries
 */
export async function loadExpertise(
  agentId: string,
  domain: ExpertDomain,
): Promise<DomainExpertise> {
  const filePath = resolveDomainExpertisePath(agentId, domain);

  try {
    const content = await fs.readFile(filePath, "utf8");
    // Try JSON first (preferred format)
    try {
      const parsed = JSON.parse(content) as DomainExpertise;
      return parsed;
    } catch {
      // Fall back to YAML parsing for backwards compatibility
      return parseExpertise(content, domain);
    }
  } catch {
    return createEmptyExpertise(domain);
  }
}

/**
 * Save expertise for a domain
 * Saves as JSON for full fidelity, but also creates a YAML export for readability
 */
export async function saveExpertise(agentId: string, expertise: DomainExpertise): Promise<void> {
  const filePath = resolveDomainExpertisePath(agentId, expertise.domain);
  const dir = path.dirname(filePath);

  await fs.mkdir(dir, { recursive: true });
  expertise.lastSync = new Date().toISOString();

  // Save as JSON for full fidelity (includes inactive entries)
  await fs.writeFile(filePath, JSON.stringify(expertise, null, 2), "utf8");

  // Also export as human-readable YAML (only active entries)
  const yamlPath = filePath.replace(".yaml", "-readable.yaml");
  const yamlContent = serializeExpertise(expertise);
  await fs.writeFile(yamlPath, yamlContent, "utf8");
}

/**
 * Load all domain expertise for an agent
 */
export async function loadAllExpertise(
  agentId: string,
): Promise<Map<ExpertDomain, DomainExpertise>> {
  const expertise = new Map<ExpertDomain, DomainExpertise>();
  const domains: ExpertDomain[] = ["database", "gateway", "security", "channel"];

  for (const domain of domains) {
    expertise.set(domain, await loadExpertise(agentId, domain));
  }

  return expertise;
}

/**
 * Add an expertise entry to a domain
 */
export async function addExpertiseEntry(
  agentId: string,
  domain: ExpertDomain,
  category: "decisions" | "patterns" | "pitfalls" | "bestPractices",
  entry: Omit<ExpertiseEntry, "id" | "createdAt" | "updatedAt" | "active">,
): Promise<ExpertiseEntry> {
  const expertise = await loadExpertise(agentId, domain);
  const now = new Date().toISOString();

  const fullEntry: ExpertiseEntry = {
    ...entry,
    id: generateEntryId(),
    createdAt: now,
    updatedAt: now,
    active: true,
  };

  expertise[category].push(fullEntry);
  await saveExpertise(agentId, expertise);

  // Log to journal
  await appendJournalEntry(agentId, {
    eventType: "learning_added",
    source: entry.source as JournalEventSource,
    content: `Added ${category} entry: ${entry.summary}`,
    topic: domain,
    category: "pattern",
    confidence: entry.confidence,
    metadata: { entryId: fullEntry.id, domain, category },
  });

  return fullEntry;
}

/**
 * Update an existing expertise entry
 */
export async function updateExpertiseEntry(
  agentId: string,
  domain: ExpertDomain,
  entryId: string,
  updates: Partial<
    Pick<ExpertiseEntry, "summary" | "content" | "confidence" | "tags" | "evidence">
  >,
): Promise<ExpertiseEntry | null> {
  const expertise = await loadExpertise(agentId, domain);
  const categories: Array<"decisions" | "patterns" | "pitfalls" | "bestPractices"> = [
    "decisions",
    "patterns",
    "pitfalls",
    "bestPractices",
  ];

  for (const category of categories) {
    const index = expertise[category].findIndex((e) => e.id === entryId);
    if (index !== -1) {
      expertise[category][index] = {
        ...expertise[category][index],
        ...updates,
        updatedAt: new Date().toISOString(),
      };
      await saveExpertise(agentId, expertise);
      return expertise[category][index];
    }
  }

  return null;
}

/**
 * Deactivate an expertise entry
 */
export async function deactivateExpertiseEntry(
  agentId: string,
  domain: ExpertDomain,
  entryId: string,
): Promise<boolean> {
  const expertise = await loadExpertise(agentId, domain);
  const categories: Array<"decisions" | "patterns" | "pitfalls" | "bestPractices"> = [
    "decisions",
    "patterns",
    "pitfalls",
    "bestPractices",
  ];

  for (const category of categories) {
    const entry = expertise[category].find((e) => e.id === entryId);
    if (entry) {
      entry.active = false;
      entry.updatedAt = new Date().toISOString();
      await saveExpertise(agentId, expertise);
      return true;
    }
  }

  return false;
}

// ============================================================================
// Code Change Detection
// ============================================================================

/**
 * Match a file path against glob-like patterns
 */
function matchesPattern(filePath: string, pattern: string): boolean {
  // Simple glob matching: ** matches any path, * matches any segment
  const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\//g, "\\/");

  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(filePath);
}

/**
 * Determine which domains are affected by file changes
 */
export function detectAffectedDomains(changedFiles: string[]): ExpertDomain[] {
  const affected = new Set<ExpertDomain>();

  for (const file of changedFiles) {
    for (const [domain, def] of Object.entries(DOMAIN_DEFINITIONS)) {
      for (const pattern of def.filePatterns) {
        if (matchesPattern(file, pattern)) {
          affected.add(domain as ExpertDomain);
          break;
        }
      }
    }
  }

  return Array.from(affected);
}

/**
 * Analyze code changes and determine impact
 */
export function analyzeCodeChanges(
  changedFiles: string[],
  commitMessages?: string[],
): CodeChangeAnalysis {
  const affectedDomains = detectAffectedDomains(changedFiles);

  // Group files by domain
  const filesByDomain = new Map<ExpertDomain, string[]>();
  for (const file of changedFiles) {
    for (const domain of affectedDomains) {
      const def = DOMAIN_DEFINITIONS[domain];
      for (const pattern of def.filePatterns) {
        if (matchesPattern(file, pattern)) {
          const files = filesByDomain.get(domain) || [];
          files.push(file);
          filesByDomain.set(domain, files);
          break;
        }
      }
    }
  }

  // Generate suggestions based on change types
  const suggestions: string[] = [];
  for (const [domain, files] of filesByDomain) {
    const hasNewFiles = files.some((f) => f.includes("new") || !f.includes("/"));
    const hasRemovedFiles = files.some((f) => f.includes("removed") || f.includes("delete"));
    const hasConfigChanges = files.some((f) => f.match(/config|setting|option|param/i));

    if (hasNewFiles) {
      suggestions.push(`Review new ${domain} files for architectural patterns`);
    }
    if (hasConfigChanges) {
      suggestions.push(`Update ${domain} configuration documentation`);
    }
    if (hasRemovedFiles) {
      suggestions.push(`Check ${domain} expertise for outdated entries`);
    }
  }

  // Build summary from commit messages or file changes
  let summary = "";
  if (commitMessages && commitMessages.length > 0) {
    summary = commitMessages.slice(0, 3).join("; ");
  } else {
    summary = `${changedFiles.length} files changed across ${affectedDomains.length} domains`;
  }

  return {
    changedFiles,
    affectedDomains,
    summary,
    suggestions,
  };
}

// ============================================================================
// Self-Improve Prompts
// ============================================================================

/**
 * Generate a self-improve prompt for reviewing domain changes
 */
export function generateReviewPrompt(
  domain: ExpertDomain,
  changedFiles: string[],
  existingExpertise: DomainExpertise,
): SelfImprovePrompt {
  const def = DOMAIN_DEFINITIONS[domain];

  const prompt = `# Self-Improve: Review ${def.name} Changes

You are the ${def.name}, responsible for maintaining expertise about: ${def.description}

## Recent Changes
The following files in your domain have changed:
${changedFiles.map((f) => `- ${f}`).join("\n")}

## Current Expertise Summary
- Architectural Decisions: ${existingExpertise.decisions.filter((e) => e.active).length} entries
- Patterns & Conventions: ${existingExpertise.patterns.filter((e) => e.active).length} entries
- Pitfalls & Gotchas: ${existingExpertise.pitfalls.filter((e) => e.active).length} entries
- Best Practices: ${existingExpertise.bestPractices.filter((e) => e.active).length} entries

## Your Task
1. Review the changed files to understand what was modified
2. Identify any new patterns, decisions, or best practices that should be documented
3. Check if any existing expertise entries are now outdated or incorrect
4. Suggest additions, updates, or removals to keep expertise current

## Output Format
Respond with JSON in this format:
{
  "additions": [
    {
      "category": "patterns|decisions|pitfalls|bestPractices",
      "summary": "Brief description",
      "content": "Detailed explanation",
      "confidence": "high|medium|low",
      "relatedFiles": ["file1.ts", "file2.ts"],
      "tags": ["tag1", "tag2"]
    }
  ],
  "updates": [
    {
      "entryId": "exp_xxx",
      "updates": { "content": "new content", "confidence": "high" }
    }
  ],
  "deactivations": ["exp_xxx", "exp_yyy"],
  "summary": "Brief summary of expertise changes"
}`;

  return {
    domain,
    promptType: "review",
    prompt,
    contextFiles: changedFiles,
    outputFormat: "entries",
  };
}

/**
 * Generate a self-improve prompt for extracting expertise from code
 */
export function generateExtractPrompt(
  domain: ExpertDomain,
  targetFiles: string[],
): SelfImprovePrompt {
  const def = DOMAIN_DEFINITIONS[domain];

  const prompt = `# Self-Improve: Extract ${def.name} Expertise

You are the ${def.name}, building a mental model of: ${def.description}

## Files to Analyze
${targetFiles.map((f) => `- ${f}`).join("\n")}

## Extraction Goals
Extract the following types of knowledge:

### Architectural Decisions
- Key design choices and their rationale
- Trade-offs that were considered
- Why certain approaches were chosen over alternatives

### Patterns & Conventions
- Code patterns used consistently
- Naming conventions
- Common abstractions and how to use them

### Pitfalls & Gotchas
- Common mistakes to avoid
- Non-obvious behaviors
- Edge cases and their handling

### Best Practices
- Recommended approaches
- Performance considerations
- Security best practices (especially important)

## Output Format
Respond with JSON in this format:
{
  "extractions": [
    {
      "category": "patterns|decisions|pitfalls|bestPractices",
      "summary": "Brief description (under 100 chars)",
      "content": "Detailed explanation with code examples if helpful",
      "confidence": "high|medium|low",
      "relatedFiles": ["file1.ts"],
      "tags": ["tag1", "tag2"],
      "evidence": "Quote or reference from code"
    }
  ],
  "summary": "Overall summary of extracted expertise"
}`;

  return {
    domain,
    promptType: "extract",
    prompt,
    contextFiles: targetFiles,
    outputFormat: "entries",
  };
}

/**
 * Generate a self-improve prompt for validating existing expertise
 */
export function generateValidatePrompt(
  domain: ExpertDomain,
  existingExpertise: DomainExpertise,
): SelfImprovePrompt {
  const def = DOMAIN_DEFINITIONS[domain];

  const allEntries = [
    ...existingExpertise.decisions,
    ...existingExpertise.patterns,
    ...existingExpertise.pitfalls,
    ...existingExpertise.bestPractices,
  ].filter((e) => e.active);

  const entrySummaries = allEntries
    .map((e) => `- [${e.id}] ${e.summary} (confidence: ${e.confidence})`)
    .join("\n");

  const prompt = `# Self-Improve: Validate ${def.name} Expertise

You are the ${def.name}, validating your existing knowledge about: ${def.description}

## Current Expertise Entries
${entrySummaries || "(No entries yet)"}

## Validation Tasks
1. Check if each entry is still accurate given the current codebase
2. Identify entries that may be outdated or incorrect
3. Suggest confidence adjustments based on evidence
4. Flag any contradictions between entries

## Output Format
Respond with JSON in this format:
{
  "validations": [
    {
      "entryId": "exp_xxx",
      "valid": true|false,
      "newConfidence": "high|medium|low",
      "reason": "Why this entry is/isn't valid",
      "suggested_update": "Optional updated content"
    }
  ],
  "contradictions": [
    {
      "entryIds": ["exp_xxx", "exp_yyy"],
      "description": "How they contradict"
    }
  ],
  "summary": "Overall validation summary"
}`;

  return {
    domain,
    promptType: "validate",
    prompt,
    contextFiles: existingExpertise.filePatterns,
    outputFormat: "validation",
  };
}

/**
 * Generate a self-improve prompt for consolidating expertise
 */
export function generateConsolidatePrompt(
  domain: ExpertDomain,
  existingExpertise: DomainExpertise,
): SelfImprovePrompt {
  const def = DOMAIN_DEFINITIONS[domain];

  const prompt = `# Self-Improve: Consolidate ${def.name} Expertise

You are the ${def.name}, organizing and improving your knowledge about: ${def.description}

## Current State
- Decisions: ${existingExpertise.decisions.filter((e) => e.active).length} entries
- Patterns: ${existingExpertise.patterns.filter((e) => e.active).length} entries
- Pitfalls: ${existingExpertise.pitfalls.filter((e) => e.active).length} entries
- Best Practices: ${existingExpertise.bestPractices.filter((e) => e.active).length} entries

## Consolidation Goals
1. Merge similar or duplicate entries
2. Improve clarity and organization
3. Add missing connections between related entries
4. Prioritize high-value knowledge
5. Remove low-value or redundant entries

## Output Format
Respond with JSON in this format:
{
  "merges": [
    {
      "sourceIds": ["exp_xxx", "exp_yyy"],
      "merged": {
        "summary": "Combined summary",
        "content": "Consolidated content",
        "confidence": "high|medium|low",
        "tags": ["tag1"]
      }
    }
  ],
  "improvements": [
    {
      "entryId": "exp_xxx",
      "newContent": "Improved content",
      "reason": "Why this improves the entry"
    }
  ],
  "removals": ["exp_xxx"],
  "summary": "Consolidation summary"
}`;

  return {
    domain,
    promptType: "consolidate",
    prompt,
    contextFiles: [],
    outputFormat: "summary",
  };
}

// ============================================================================
// Sync State Management
// ============================================================================

/** Sync state tracking */
interface SyncState {
  /** Last sync timestamp per domain */
  lastSyncByDomain: Record<ExpertDomain, string>;
  /** Files processed in last sync */
  lastProcessedFiles: string[];
  /** Pending changes waiting for sync */
  pendingChanges: string[];
  /** Total syncs performed */
  totalSyncs: number;
}

/**
 * Load sync state for an agent
 */
export async function loadSyncState(agentId: string): Promise<SyncState> {
  const filePath = resolveSyncStatePath(agentId);

  try {
    const content = await fs.readFile(filePath, "utf8");
    return JSON.parse(content);
  } catch {
    return {
      lastSyncByDomain: {
        database: "",
        gateway: "",
        security: "",
        channel: "",
      },
      lastProcessedFiles: [],
      pendingChanges: [],
      totalSyncs: 0,
    };
  }
}

/**
 * Save sync state for an agent
 */
export async function saveSyncState(agentId: string, state: SyncState): Promise<void> {
  const filePath = resolveSyncStatePath(agentId);
  const dir = path.dirname(filePath);

  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, JSON.stringify(state, null, 2), "utf8");
}

/**
 * Record pending changes for later sync
 */
export async function recordPendingChanges(agentId: string, changedFiles: string[]): Promise<void> {
  const state = await loadSyncState(agentId);

  // Add new changes, avoiding duplicates
  const existing = new Set(state.pendingChanges);
  for (const file of changedFiles) {
    existing.add(file);
  }
  state.pendingChanges = Array.from(existing);

  await saveSyncState(agentId, state);
}

/**
 * Clear pending changes after sync
 */
export async function clearPendingChanges(agentId: string): Promise<string[]> {
  const state = await loadSyncState(agentId);
  const pending = [...state.pendingChanges];

  state.lastProcessedFiles = pending;
  state.pendingChanges = [];
  state.totalSyncs++;

  await saveSyncState(agentId, state);
  return pending;
}

/**
 * Update last sync time for a domain
 */
export async function updateDomainSyncTime(agentId: string, domain: ExpertDomain): Promise<void> {
  const state = await loadSyncState(agentId);
  state.lastSyncByDomain[domain] = new Date().toISOString();
  await saveSyncState(agentId, state);
}

// ============================================================================
// Expertise Summary & Formatting
// ============================================================================

/**
 * Get a summary of expertise for context injection
 */
export async function getExpertiseSummary(agentId: string, domain: ExpertDomain): Promise<string> {
  const expertise = await loadExpertise(agentId, domain);
  const lines: string[] = [];

  lines.push(`# ${expertise.name}`);
  lines.push(`> ${expertise.description}`);
  lines.push("");

  // Add high-confidence decisions
  const decisions = expertise.decisions.filter((e) => e.active && e.confidence === "high");
  if (decisions.length > 0) {
    lines.push("## Key Architectural Decisions");
    for (const d of decisions.slice(0, 5)) {
      lines.push(`- **${d.summary}**: ${d.content.slice(0, 200)}...`);
    }
    lines.push("");
  }

  // Add patterns
  const patterns = expertise.patterns.filter((e) => e.active);
  if (patterns.length > 0) {
    lines.push("## Patterns");
    for (const p of patterns.slice(0, 5)) {
      lines.push(`- ${p.summary}`);
    }
    lines.push("");
  }

  // Add pitfalls
  const pitfalls = expertise.pitfalls.filter((e) => e.active && e.confidence !== "low");
  if (pitfalls.length > 0) {
    lines.push("## Watch Out For");
    for (const pit of pitfalls.slice(0, 3)) {
      lines.push(`- ${pit.summary}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Get expertise context for all domains
 */
export async function getFullExpertiseContext(agentId: string): Promise<string> {
  const domains: ExpertDomain[] = ["database", "gateway", "security", "channel"];
  const sections: string[] = [];

  for (const domain of domains) {
    const summary = await getExpertiseSummary(agentId, domain);
    if (summary.trim()) {
      sections.push(summary);
    }
  }

  return sections.join("\n---\n\n");
}

/**
 * Search expertise entries across all domains
 */
export async function searchExpertise(
  agentId: string,
  query: string,
  options: { domains?: ExpertDomain[]; categories?: string[] } = {},
): Promise<Array<ExpertiseEntry & { domain: ExpertDomain; category: string }>> {
  const domains =
    options.domains || (["database", "gateway", "security", "channel"] as ExpertDomain[]);
  const queryLower = query.toLowerCase();
  const results: Array<ExpertiseEntry & { domain: ExpertDomain; category: string }> = [];

  for (const domain of domains) {
    const expertise = await loadExpertise(agentId, domain);
    const categories = ["decisions", "patterns", "pitfalls", "bestPractices"] as const;

    for (const category of categories) {
      if (options.categories && !options.categories.includes(category)) continue;

      for (const entry of expertise[category]) {
        if (!entry.active) continue;

        const matches =
          entry.summary.toLowerCase().includes(queryLower) ||
          entry.content.toLowerCase().includes(queryLower) ||
          entry.tags.some((t) => t.toLowerCase().includes(queryLower));

        if (matches) {
          results.push({ ...entry, domain, category });
        }
      }
    }
  }

  // Sort by confidence
  const confidenceOrder = { high: 0, medium: 1, low: 2 };
  results.sort((a, b) => confidenceOrder[a.confidence] - confidenceOrder[b.confidence]);

  return results;
}

// ============================================================================
// Expertise Decay
// ============================================================================

/**
 * Apply decay to old, low-confidence entries
 */
export async function applyExpertiseDecay(
  agentId: string,
  config: Partial<ExpertiseSyncConfig> = {},
): Promise<{ domain: ExpertDomain; deactivated: number }[]> {
  const cfg = { ...defaultSyncConfig, ...config };
  const domains: ExpertDomain[] = ["database", "gateway", "security", "channel"];
  const results: { domain: ExpertDomain; deactivated: number }[] = [];
  const cutoff = Date.now() - cfg.decayDays * 24 * 60 * 60 * 1000;

  for (const domain of domains) {
    const expertise = await loadExpertise(agentId, domain);
    let deactivated = 0;

    const categories = ["decisions", "patterns", "pitfalls", "bestPractices"] as const;
    for (const category of categories) {
      for (const entry of expertise[category]) {
        if (!entry.active) continue;

        // Only decay low-confidence entries that haven't been updated
        if (entry.confidence === "low") {
          const updatedAt = new Date(entry.updatedAt).getTime();
          if (updatedAt < cutoff) {
            entry.active = false;
            deactivated++;
          }
        }
      }
    }

    if (deactivated > 0) {
      await saveExpertise(agentId, expertise);
      results.push({ domain, deactivated });
    }
  }

  return results;
}
