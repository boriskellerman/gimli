{
  "video_id": "zte-secret-of-agentic-engineering",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/zte-secret-of-agentic-engineering",
  "title": "ZTE: The Secret of Agentic Engineering",
  "channel": "Agentic Engineer",
  "duration": 3500,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T03:52:26.213Z",
  "transcript": "Welcome to lesson seven,\nyour second to last\nTactical Agentic Coding lesson.\nHere we approach the\nedge of agentic coding.\nHere we ship end\nto end with our\nOutloop system to deliver\nmore engineering value than\nwe ever could before.\nIn the next hour,\nyou'll witness something most\nengineers dismiss as impossible,\na codebase that\nnearly runs itself. This\nlesson is going to\nflow differently from the\nrest. First, we're gonna\nhand off five net\nnew pieces of work\nto our agentic layer\nthat now ships end\nto end. Plan, build,\ntest, review, document. You'll\nsee the order of\nmagnitude improvement in your\nengineering velocity. You'll see\nwhat it looks like\nto fully invest in\nyour agentic layer. We'll\nwork through a couple\nof additions that helps\nus increase our engineering\nvelocity with our agents.\nNext, we'll break down\nhow we've parallelized our\nAI developer workflows using\nGit work trees. This\nenables multiple agent pipelines\nto execute simultaneously in\nisolated environments on a\nsingle device. Of course,\nyou can tweak this\nand make it your\nown. You can set\nup your own containers.\nYou can use Docker.\nWe're keeping it simple\nand we're focusing on\nthe key idea of\nscaling beyond what in-loop\nagentic coding can offer.\nThen midway through the\nlesson, I want to\nintroduce you to the\nthird level of agentic\ncoding on the agentic\nengineering velocity scale. There\nare three levels in\nloop out loop and\none additional level that\nwe're going to break\ndown in this lesson.\nMost engineers are operating\nin the loop throughout\ntack. You've learned how\nto construct powerful out\nloop systems that you're\ngoing to see in\nthis lesson that clearly\noutperform out of the\nbox agentic coding tools\nbecause they contain your\nengineering practices and your\nengineering workflows. But there's\na level beyond Outloop\nSystems. We'll understand a\ncritical moment in the\nfuture where human in\nthe loop review becomes\na bottleneck, not a\nsafety net. This tactic\nwill lead us to\nthe secret of tactical\nagentic coding. Let's collect\nthe incredible dividends from\nour complete end to\nend Outloop agentic system.\nI wanna showcase that\nonce you've invested in\nyour Outloop system. Once\nyou've built the system\nthat builds the system,\nit's going to pay\nyou back massively. Let's\nprompt and while our\nagents cook, let's review\nthe codebase and\nthen review their work.\nAs we work through\nthese, we'll address shortcomings,\ntrade-offs and improvements we\ncan make to this\nversion of this Outloop\nsystem. And we'll discuss\nhow you can move\ntoward the next scale\nof Agentic coding. We\nare approaching the edge.\nThese are the advanced\nlessons to the ideas\nhere haven't arrived yet.\nbut I wanna give\nyou the greatest edge\nI possibly can. So\nlet's get started and\nhand off more work\nthan ever with the\nnew agentic layer of\nour codebase. As\nyou can see here,\nwe have our dedicated\nagent environment up and\nrunning. The webhook trigger\nis ready for prompts\ncoming in from GitHub\nissues, which is our\nprompt input from our\nPeter framework. We've templated\nour engineering. We're operating\nout the loop so\nwe can scale our\nimpact as easily as\ncopying a file. Let\nme open up our\nagent environment. You can\nsee this is a\nscreen If I run\nChrome, you can see\nrefresh, refresh. You can\nsee our codebase,\nright? Classic natural language\nSQL interface. What we're\ngoing to do here\nis rapidly enhance this\napplication. Okay, our agents\nknow how to operate\nthis codebase. Let's\nput them to work.\nSo we have code\nopen here. We have\nour web hook ready\nto go. Remove focus,\nopen up GitHub issues.\nbecause this is our\nprompt source. Remember the\nPeter framework, you have\nprompt input, your trigger\nenvironment, and your review\nsystem. Our prompt input\nis of course, GitHub\nissues. Let's go ahead\nand fire up two,\nthree, four, five pieces\nof work that will\nrun end to end.\nLet's go ahead and\nrun like various levels\nof difficulty. So here\nI want increase drag\nand drop surface area.\nPaste all this in,\nfeature, software developer lifecycle,\nisolated. We'll break this\nall down in just\na moment here. And\nyou can see the\nprompt. We want to\nincrease the drop zone\nof the surface area\nso that we can\ndrag and drop over\nany element. Feature two,\nI want JSON export.\nThere's the prompt. You\ncan see nice, simple,\nhigh-level prompt. Our agents\nhandle the rest. I\nwant the ability to\ncreate random data based\non the existing schema\nin our table. So\nI wanna be able\nto click on a\ntable and have it\ngenerate some additional random\ndata for us to\nwork with, all right?\nSo this is another\nfeature that you might\nget requested from your\nPM or something you\nwanna build into your\nproduct. And now you\ncan have your agents\ndo this and multiple\nother features at scale\nin parallel. We have\na more mid-level prompt\nhere. You can see\nthere's a lot more\ndetail. Feel free to\npause and understand what's\ngoing on, but it's\nas you would expect,\nright? We want synthetic\ndata based on the\nexisting table patterns and\nschemas. We want support\nfor better models for\nquery generation, all right?\nThis is a simple\none. This is gonna\nbe a chore and\nwe want to update\nour model to use\n04 mini, okay? So\nwe're just boosting our\nmodel. I think currently\nit's up to GPT\n4.1. These are just\nrandom examples of work\nyou might be doing\ninside of your code\nbase that you don't\nneed to do anymore.\nYou can hand out\nthis work to your\nagents, all right? And\nlast but not least,\nlet's solve a bug.\nWe have a really\nsimple issue here. If\nwe open up this\non the server, you\ncan see here our\nproducts CSV export looks\nlike this. We have\nthe chart icon and\nthen CSV, but if\nwe select a product,\nyou'll see something here\nWe have mismatched text.\nOkay, so this is\njust a small, simple\nbug. So we wanna\nalign this. This is\ngonna be a simple\nhigh level prompt. And\nhere we're not even\ngonna use the full\nSDLC workflow, which I'll\nbreak down in a\nmoment. We're going to\nuse a simple patch\nworkflow. Okay, so check\nthis out, five issues.\nWe're gonna fire them\nall off back to\nback. Our Outloop agentic\nsystem is gonna pick\nup all these events\nto end and that's\nfine. The point is\nthat we're leaning toward\nthe future. We're working\ntoward that future where\nwe are operating out\nthe loop more and\nmore and more. Okay,\nthis isn't black and\nwhite. It's not in\nloop versus out loop.\nIt's in loop moving\ntoward out loop. Okay,\none day at a\ntime, improving your workflows,\nimproving your AI developer\nworkflows down to the\nprompt level. Okay, you\ncan imagine what this\ndoes. This is the\ncomplete software developer lifecycle,\nright? And it runs\nin isolation. Plan, build,\ntest, review, document. We\nhave this entire workflow\nand this is what\nwe fired off on\nmost of our runs\nhere, right? ADW, SDLC,\nSDLC, SDLC, SDLC here.\nAnd then here is\nthe only one where\nwe did in patch.\nAll right, just a\nsimple cleanup, right? It's\njust text. We don't\nneed to go all\ninto the SDLC to\nsolve this problem. Although\nif you wanted to,\nyou could. This is\nthe SDLC. This is\nthe software developer lifecycle\nend to end. This\nis what we've been\nbuilding up to, all\nright? This is full\nautomation across the software\ndeveloper lifecycle. There are\nmany different flavors of\nthis. You're going to\nwant to tweak it\nand make it your\nown, but this is\nan incredible starting point\nfor the agentic layer\nof our codebase.\nNow let's just focus\non the key pieces\nhere. We have several\nflags and ideas embedded,\nbut what we want\nto focus on here\nSo if I just\nsearch this plus that\nPython, let's enable regex.\nYou can see we're\njust kicking off lower\nlevel compositional pieces, right?\nThis is not new.\nWe start by planning,\nwe then build, we\nthen test. You can\nsee we're skipping end\nto end here just\nto save some time.\nThen we review our\nwork. And then of\ncourse we document the\nwork done. This is\njust a full recap\nof everything we've done\nup to this lesson,\nright? Now, the interesting\npart here is how\nwe've scaled this up.\nBefore, as you'll remember,\nour agent box was\nlimited to strictly operating\nin the base directory,\nbut now we've used\nGit work trees. And\nit doesn't matter that\nyou use Git work\ntrees. It doesn't matter\nif you want to\nuse individual instances, individual\nVMs, Docker containers. I\ndon't care how you\nscale up your agent\nenvironments, it only matters\nthat you can, all\nright? So we've adjusted\nall of our workflows\nto create their own\nisolated trees. Check this\nout. In every tree,\nright, in every one\nof these directories, the\napplication exists for a\nspecific agent to build\nin. This is the\neasiest way to parallelize\nyour workflows and to\nscale up agents into\nyour work. You can\nsee we have all\nof our environment variables,\nour playwright configuration at\nthe beginning of our\nworkflow. And we can\nof course just search\nthis, right? Because we\nknow how to navigate\nthe agentic layer slash\ninstall work. You can\nsee here in plan\nISO, right? When we're\nplanning our work, setting\nup the environment, we\nrun slash install work\ntree. And then we're\npassing in our ports\nthat were created and\nour work tree path.\nAnd then you can\nimagine what this does,\nthe work tree, sets\nup every piece that\nwe need to operate\nthe codebase in\na dedicated directory, right?\nSo we're basically cloning\nin a new version.\nWe're installing as if\nwe, the engineer, were\noperating, right? This is\ncritical. Some type of\nconfiguration format like this\nis going to be\nreally important. A lot\nof engineers, you're going\nto lean on tools\nlike Docker, some new\nagent-based containerization frameworks. Whatever\nyou use doesn't matter.\nDon't get caught on\nthat. Get caught on\nscaling up the agentic\nlayer so that you\ncan multiply your agents.\nYou want agents operating\nin parallel, in dedicated\nisolated, safe environments. Okay.\nAnd then you want\nto be able to\nquickly plug in to\nany one of these\nenvironments, right? At any\nmoment in time, I\ncan come into one\nof these work trees,\nright? So say I\nwanted to, I can\ndo something like this,\nright? At any moment\nin time, I can\ncome in and I\ncan say code trees,\n8F. Let's actually use\na real, let's use\na real ID. So\nwe have this agent\noperating here and this\nagent just implemented its\nsolution. So if we\ncopy this ID here,\nwe can open up\nthis agent environment right\nnow. And we can\njust watch what's going\non. So we open\nup this, we have\na brand new instance,\nwe're in the dedicated\nenvironment that this agent\nis operating in. Check\nthis out. You can\nsee the branch down\nthere, right? Chore task\nissue 39, there's the\nADWID. Okay. Think in\nthe gray, we're not\njumping to Outloop. We're\nprogressively handing off more\nand more work to\nour agents. All right.\nSo things are going\nto go wrong. We're\ngoing to need to\nhop in the environment,\nunderstand what went wrong\nwith our agents so\nthat we can not\nfix the issue directly,\nbut so that we\ncan hop up to\nour top level and\nimprove the agentic layer\nof our codebase.\nI hope you can\nsee the theme here.\nWe're building the system\nthat builds the system.\nWe're not solving the\nproblem directly anymore. Of\ncourse, we will be\ndoing that, right? Your\ndomain specific problem is\neverything, but the impact\nyou can have, the\nrate in which you\ncan solve your specific\nproblem can now be\ndrastically scaled up when\nlesson six tactic has\nnot been broken this\nis really important for\nscaling we have one\nagent running one prompt\nwith a single purpose\nnow In order to\ncombat some of the\nstate management issues that\nyou're going to run\ninto, we do have\nthis state.json object, and\nwe're starting to track\nmore and more information\nhere, kind of meta\ninformation to pass through\nto your ADWs and\nto your individual agents.\nexpect to have to\nadd some type of\nstate object inside your\ndedicated agent environments, but\nthis truly frees your\nagent to do one\nthing extraordinarily well with\nall the context it\nneeds and it lets\nyou jump in and\nreplay what that agent\nhas done. Right? So\nthis is super, super\nimportant. So let's hop\nback up to the\ntop level. Let's see\nhow our agents are\ndoing. Our add JSON\nexport agent, if we\nscroll to the bottom\nhere, it looks like\nwe're in the review\nphase and you can\nalways just scroll up\nand see the current\nstate object tracking everything\nthat we need to\nsee at a, you\nknow, review level. That's\nlooking great there. What\nabout our drag and\ndrop? Looks like we\nare isolated implementation phase\ncomplete. Nice tests have\nall passed. Fantastic. Final\ntest. So we're probably\nreviewing now. Yep. Okay,\ngreat. Also reviewing here.\nHere's our table random\ndata generation feature and\nmore mid-level prompt here.\nAnd we're using the\nheavy model set. This\nis important. Let's talk\nabout the heavy model\nset for a second.\nIf I scroll down\nhere, it is okay.\nImplementing the solution. This\nis probably the largest\nfeature that we're shipping\nright now or that\nour agents are shipping\nfor us right now.\nLet's go ahead and\nunderstand what model set\nis. We're adding a\nknob to our capabilities,\nright? You can encode\nany information dense keyword\nthat you want. You\njust have to make\nsure that your prompts\nrecognize it and pick\nit up. What do\nI mean by that?\nOf course, you know\nthat an IDK is\nan information dense keyword.\nThese are keywords that\naffect your agents, right?\nThey affect your prompts.\nWe've encoded this into\nour prompts into our\nADW. So What does\nthis model set have\nyou do? We know\nthat we can specify\nfeatures, chores, bugs, and\nwe can select our\nAI developer workflow. But\nof course, you're going\nto want to pass\nin more information into\nyour workflows. You're gonna\nwanna tweak some of\nthe agentic variables, and\nthis is one of\nthem. So what does\nthis do? Our model\nset changes the set\nof models that runs\nagainst our workflow. This\nis very simple. If\nwe open up agents.py,\nwe're gonna get to\nour agents file and\nyou can see exactly\nwhat this does, right?\nWe have a map\nbetween our custom slash\ncommands, right? Our prompts\nthat run our agents\nand every one of\nthem maps to either\na base model or\na heavy model, right?\nAnd you can see\nhere in some of\nour heavy models, right?\nHeavy forward opus, we\nare running a beefed\nup model. So this\nis all that this\ndoes, right? It gives\nus a little knob\nto turn to increase\nthe compute that our\nworkflow uses, right? In\nthis case, by compute,\nI specifically mean the\nmodel that we're using,\nall right? So exact\nsame prompts, exact same\nreasoning when it's called\nout. Inside of our\nprompts, we of course\nhave the, let's go\nto our chore.md, right?\nIf you just search\nthink, you can see\nwe have the encoded\nthink hard information dense\nkeyword. This is fantastic.\nYou can find this,\nyou know, all over.\nIf we just do\na search for this\ninside of all of\nour prompts, this is\nimportant for activating your\nreasoning model. So we\nare scaling our compute\nthere, but we have\nan additional knob here\nto scale it again.\nSo if we pass\nin heavy and the\nworkflow that detects this\nis going to be\nour classify ADW, right?\nAnd again, if you're\never wondering where this\nstuff runs, you can\nalways just type slash\nclassify ADW. Okay, and\nso it runs right\nhere, workflow operations, where\nwe classify the ADW\nat the beginning of\nthe workflow. To obtain\nthis JSON object. We\nwanna parse out the\nbase model, ADWID, and\nof course our slash\ncommand that we're going\nto run. And this\nis one of the\nfirst things that runs\nin our workflows so\nthat we can parse\nthis information out, right?\nAnd so we've encoded\nthis and you can\nsee we just use\nbase or heavy, right?\nSuper important idea here.\nYou can encode any\ninformation dense keyword you\nwant that changes your\nworkflows, right? And you're\nlikely gonna wanna pass\nthose in at the\ntop level to adjust\nhow your agents operate\na given task or\nfeature. That's that. Let's\nsee how we're doing\nhere now. Okay, so\nwe're still implementing. This\nis a heavy feature\nand we are running\nheavy models, right? So\nthis will take some\ntime. Looks like we're\n11 minutes in right\nnow. Let's continue to\nour other features. See\nhow we're doing. SDLC,\nupdating model. We wanna\nuse that 04 many\nfor our SQL natural\nlanguage generation functionality. So\nlet's go over to\nthe bottom here. Awesome,\nso check this out.\nSix minutes ago, this\nfeature completed. Let's scroll\nup to our review.\nThis looks good. All\ntests passed. We updated\nfrom 4.1, 04 many,\nit looks great. Fantastic.\nAnd we of course\nsoftware developer lifecycle. We\ncan see it all.\nWe can understand what\nour agent was looking\nat when it created\nsome things. And then\nwe also have our\nspec file, of course,\nwhich details out this\nchore, relevant files. New\nfiles, step-by-step, breakdown, blah,\nblah, blah, blah, blah.\nWe've covered all this.\nWe know how planning,\nbuilding, testing, reviewing, and\ndocumenting works, right? The\ngreat part is, is\nthat we're seeing it\nworking all together now.\nright? Digitized our engineering,\njust like we can\ncopy and paste a\nfile, we can copy\nand paste our engineering\nacross agents. This is\nthe power of the\nOutloop system. This is\nthe power of investing\nin your agentic layer\nof your codebase.\nThis is where scaled\nup agentic impact happens.\nNow, many engineers are\ngoing to gloss over\nthis. They're not going\nto pay attention to\nthis. They're going to\nstay in the loop\nand they're going to\nwaste a bunch of\ntime. Not you and\nI. CSV text doesn't\nmatch. This is a\nsimple patch workflow. It\nlooks like this completed\na while ago. Great.\nSo you do want\nto stay on the\nreview system as much\nas possible, right? You\nwant to build up\nyour review system to\nbe intricate, to be\ndetailed so that basically\nyou don't have to\nleave to know that\nyour agents have shipped\nthe work end to\nend. Here, we're just\nusing, you know, GitHub\nissues. We're posting literally\nright back to the\nissue that kicked off\nthe workflow. A lot\nof engineers, you know,\nyou're going to want\nto look at the\npull request. You're going\nto want to push\ncontent information to the\npull request. I do\nthink that this is\nan entire product category\nthat is important to\nbuild out. Having a\ncomprehensive review system is\na massive, massive edge\nfor increasing your review\nvelocity. Right here, you\ncan see, you know,\nthroughout tech, we're keeping\nit simple. We're showcasing\nconcepts, ideas, tactics, right?\nBy just using existing\ntechnology, you can spin\nthis up and get\nstarted right away. But\nit's important to note\nthat the review system\nis critical for increasing\nyour agent engineering velocity\nfor the review step.\nConcretely, We should have\na feature now that\nhere we go. That's\ncompleted. It's it's review.\nOkay. Now check this\nout, right? This is\nthe power of great\nreview. This is critical,\nright? Here's the review\nsummary enhance drag and\ndrop feature for both\nquery and table selection.\nSo check this out.\nOur agents. Took images\nand gave us proof\nthat the feature has\nshipped. Check this out,\nright? Drag and drop.\nWe now have this\noverlay right here. We\nhave this overlay right\nhere, right? Drop to\ncreate a table. And\nour screenshot for its\nregression testing, making sure\nthat everything looks good.\nThis is beautiful. Agents,\nthey're operating like you\nor I would, right?\nThis is what it\nmeans to have a\npowerful agentic layer, right?\nThey've uploaded screenshots. It's\nproof of value. Remember\nwhat the review step\nanswers. It's not, does\nit work? It's is\nwhat we built, what\nwe asked for. And\nyou can see here,\nthis is exactly what\nwe asked for in\nthe prompt. Drag and\ndrop over any block\nthat exists, right? Drag\nand drop feature has\nalmost been completed. So\nremember, we fired this\noff 27 minutes ago,\nand I wonder how\nmuch code we're gonna\nget here generated for\nus by our agents,\nmaybe two, 300 lines.\nYeah, nice, 300 lines.\nOkay, fantastic. That looks\ngreat. And so our\nother agent here, add.json\nexport, looks like it's\nworking through the review.\nLooks like it found\na blocking issue during\nthe review phase. So\nnow it's going to\ntry to fix this,\nso that's great. And\nour random data is\nstill implementing. This is\na big feature, it's\nrunning Opus. This is\ngonna be the ones\nwhere we might have\nto jump in, right?\nGo from Outloop to\nEndloop to kind of\nround out the implementation\nor understand what's going\non. Our increase drop\nzone surface area has\ncompleted. This is fantastic.\nSo all the work\nhere is done and\nthat means that we\ncan check out the\nPR. So let's go\nahead and open up\nthis PR. I'm going\nto copy the branch\nLooks like we have\n400 lines here. That's\ngreat. And now we're\ngoing to do some\nhands on review, right?\nSome in loop review.\nthat new branch. And\nwe should get the\nbrowser open up pretty\nsoon. You can see\nwe have open here,\nfire it up for\nus on our local\nhost on this device,\nright? My machine here.\nI'm using my resources\nto validate my agent's\nwork. Stop apps, reset\ndatabase, start in the\nbackground. And now we're\ngonna open up the\nbrowser. Don't do this\nhands-on manual engineering work.\nTeach your agent how\nto do it once\nand then run it\nover and over and\nover again and scale\nit across your team.\nOkay, there it is.\nThis has popped open\nfor us now. And\nremember we're testing our\ndrag and drop feature.\nSo I'm just going\nto move this right\nhere. Select five users.\nWe can fire that\noff. We'll of course\nget five users. We\ncan hit upload. You\ncan see previous items\nthere. We can hit\nour event analytics. That\nevents table got created.\nGreat. We can, of\ncourse, delete it. Blah,\nblah, blah. Let's refresh.\nAnd now let's drag\nand drop over this\nUI, right? Cause that\nwas that net new\nfeature. We're just doing\nsimple human in the\nloop testing here, drag\nand drop. Let's go\nand do that events.json.\nAnd yeah, let me\nmove this a little\nbit so you can\nsee this. That's not\nJSON. So check this\nout. Nice, clean drag\nand drop. Check that\nout. And down here\nas well, you can\nsee that's working on\nboth sections. Let's go\nahead and drop it\nhere. And look at\nthat. We have our\nevents table. I'll go\nahead and delete products\njust so we can\nget some more table\ndrops here. And let's\nopen this up and\nwe'll drag and drop\nproducts on the top.\nThat was added and\nwe don't have to\nkeep going on with\nthis, right? This is\nsimple application level stuff,\nbut you can see\nthat this feature was\nbuilt into Ant, okay?\nAnd not only did\nour agent build this\nfor us, it proved\nto us that the\nwork was done. Here\nare images and you\ncan of course take\nthis a step further.\nYou can build any\nmedia review system that\nyou need to for\nyour agents to prove\nto you that the\nwork is done, right?\nThe next most obvious\none to build out\nis video. Right? Have\nyour agents take video,\nupload it to a\ncloud bucket, and then\npost the URLs right\nhere on GitHub issues\nor whatever review system\nyou want to use.\nRemember the Peter framework\nand get a great\nreview, right? It's very\nclear that, you know,\nplanning is important. Building\nis important. Testing is\nimportant. Review is especially\nimportant, right? It's proof\nof value. Like we\ntalked about in our\nprevious lesson, It lets\nyour agents communicate to\nyou is what was\nasked for what was\nbuilt. Okay. And then\nwe of course document\nit. We're going to\nhave some documentation here.\nWe can just quickly\nsearch that since we're\non the branch or\nagent created that's app\ndocs enhance drop zone.\nAnd now we have\nthis documentation. It references\nthe original spec, right?\nOur codebase is\noperating itself, right? It's\ndocumenting. It's referring to\nthe original spec. The\nreason why we planned\nis much more than\njust to ship code,\nright? We have artifacts,\nright? We have artifacts\nfor agents. Okay. When\nyou combine all of\nthis with the conditional\ndocs, we of course\nhave our brand new\nfeature enhanced drop zone\nupdated in our conditional\ndocumentation. So now when\nour next agent runs,\nit knows that when\nit works with drag\nand drop implementing file\nupload, troubleshooting, blah, blah,\nblah, right? It knows\nthat when it hits\none of these conditions,\nPull in this documentation.\nThis lets our agents\nscale with the size\nof our codebase.\nPull in the right\ndocumentation when it needs\nto. Focus on building\nthe right thing when\nit needs to. And\nour agent is doing\nall this in its\nown isolated environment, in\nits own Git work\ntree, so that we\ncan parallelize all this\nwork up. This is\nbig. Some of these\nother features, let me\njust take a quick\nlook at these other\nfeatures. JSON, there we\ngo, check this out.\nWe got our JSON\nthere. That looks great.\nYou know, we don't\nneed to go through\nall these features, right?\nWhat I wanna communicate\nhere as we start\nrounding out tactical agentic\ncoding is that investing\nin the agentic layer\nof your codebase\nprovides you with asymmetric\nresults, okay? You can't\nvibe code this stuff.\nyou want to be\nahead of this curve,\nright? You want to\nbe pushing forward, lean\ninto this, okay? You\nwant to get these\ngains before anyone else\ndoes, right? This is\ntechnology. It always gets\ndistributed, right? But you\nwant to be at\nthe edge so that\nyou can get the\ngains as long as\npossible, right? I'm giving\nyou an information arbitrage,\nokay? You have an\ninformation edge now. And\nthen the question is,\nare you going to\nuse it? to invest\nin the agentic layer,\nright? This is what\nit all comes down\nto, okay? This is\nultra, ultra important stuff.\nSo the next natural\nquestion is, right? It's\nnot enough to push\nit to the edge.\nLet's go beyond the\nedge. What happens next,\nright? What happens after\nyour agents are, look\nat this, right? Your\nagents are testing for\nus, pie test, found\nan issue, five failed\ntests. Now it's going\nto resolve these issues.\nWhat happens when we\nget so good at\nthis that just like\nyou saw here with\nour drag and drop\nfeature, Your agent ships\nend to end and\nme reviewing obviously is\nimportant here for us.\nBut imagine you do\nthis for the 10th\ntime you shipped a\nchore or bug or\neven a feature end\nto end. What happens\nnext, right? When you\nget so good, when\nyou template your engineering\nso well in your\ncodebase, something will\nhappen. Okay. I want\nto zero in on\nthis idea here. Something\nis going to happen\nonce you become proficient\nat Outloop agentic coding.\nYou'll realize something incredible.\nThis human in the\nloop model is a\nbottleneck. I'm not catching\nany bugs anymore. I'm\nnot adding any value\noutside of the agentic\nlayer. I'm going to\nremove the human in\nthe loop review process\nfor this class of\nproblems. Once you come\nto this realization, and\ntrust me, if you\nbet big and invest\nin your agentic layer,\nthis will happen. You\nwill arrive at the\nnext order of magnitude\nthe Agentic Engineering velocity\nscale first we're in\nthe loop next we're\nout the loop and\nthen we're doing z\nt e zero touch\nengineering you'll drop yourself\noff the end of\nthe Outloop Peter framework\nand it becomes Pete\nnot Peter you'll drop\noff the review, okay?\nThis is the next\nstep. Let me just\nbe super clear about\nwhat this is. This\nis YOLO mode for\nyour AI developer workflows.\nThis is high confidence\nmode for agenting engineering.\nIt's maximum confidence mode\nfor agenting engineering. No\nreview, right? Just like\nyou've stopped coding, you'll\nstop reviewing. This is\nthe lesson seven tactic.\nTarget zero touch engineering.\nThis is the ultimate\nagentic coding Northstar. This\nis what your agentic\ncoding KPIs lead you\ntoward. Attempts at one,\nsize constantly scaling up,\nstreak constantly increasing as\nyou solve and ship\nproblem classes back to\nback to back with\none attempt and you'll\ndrop your presence down\nto one. You'll let\nyour agent ship end\nto end. When you\ndo this, you've achieved\nzero touch. Engineering. The\nbest Outloop agent decoders\nhave a presence of\ntwo. You show up\nat the prompt and\nyou show up at\nthe review, just like\nwe were here, right?\nOur presence for this\ndrag and drop feature\nwas two. Okay. We\nincreased it by going\ninto the loop, but\nwe only needed two,\nright? Prompt and review.\nIn the future, you'll\nrealize that you're wasting\ntime Reviewing. I know\nyou're probably O-faced right\nnow or thinking the\nO-face or maybe right\naway you just went,\nDan, absolutely no way,\nthat's crazy. This isn't\na real production application.\nWhat you're doing is\nyou're operating on a\ntoy app, you're pushing\nway too far. This\nis a pie in\nthe sky dream. I\nget that. I understand.\nLet's slow it down\na little bit. Okay.\nYou don't start by\nshipping a full feature,\nright? I'm not saying\ngo into your production\napplication, spend all your\ntime on one agentic\nworkflow and ship features\nto production, right? That's\nnot what I'm saying\nhere. Progress happens one\nstep at a time,\none day at a\ntime. First, go after\nchores, then go after\nbugs, then go after\nfeatures, right? Scale it\nup, solve these stupid,\nsimple problems that waste\nyour time. You know\nwhat they are. You've\nalready thought of them\nas you're working throughout\ntech. You've already thought\nof things you want\nto augment and automate,\nthen scale scale it\nup one step at\na time, okay? This\nis ultra important. We'll\nfire one of these\noff in just a\nmoment. If I open\nup the codebase,\nlet's get back to\nmain. So I'm gonna\nrun slash and loop\nand let's go back\nto main. In the\nbeginning, I mentioned we\nhave this new workflow,\nZTE. All ZTE does,\nthis will run the\nexact same workflow as\nSDLC and then it\nadds one more thing\nand you know what's\ncoming, right? We've hinted\nat this already. It\nis going to run\nship, approve and merge\nthe PR agentically. If\nnothing fails here, if\nyour agents get through\nyour engineering pipeline and\nthey've proven to you,\ngreat review with great\ntests, that the feature\nis working and you've\nrun this over and\nover and over, the\nwith Tactical Agentic Coding.\nStart small, solve a\nsmall problem set, and\nthen scale it up,\nokay? Especially for zero-touch\nengineering. So let's say\nthat you need to\nupdate the background color\nof your website or\nupdate some styles, right?\nSomething simple, right? Frontend\nis a great example\nbecause frontend is simple.\nIf you build it\nright, it should be\nsimple. Styles, components, APIs.\nThis is just, of\ncourse, a micro example.\nI just want to\nstress the point in\nyour background color, update,\nTorque, ADW, SDLC, ZTE,\nZero Touch Engineering, ISO,\nupdate, light green, Let's\njust say your designer\nis having a bad\nday, whatever, they wanna\nupdate some random styling.\nThey've decided that glass\nis the new big\nthing or whatever UI\nis the next big\nthing, right? This is\nnot something you should\never spend your time\non, right? This is\nnot engineering. So hand\nit off to your\nagents, right? This is\nlow hanging fruit. Your\nagent should be able\nto ship this end\nto end. Let's kick\nthis off and let's\nget a ZTE execution.\nIn a couple seconds\nhere, we're gonna get\nour initiation. Just gonna\ndetect that this is\na zero touch engineering\nworkflow. And you can\nsee here, right? We\nget this important message\nhere this workflow does\nall of this for\nus, right? And this\nis the key, plan,\nbuild, test, review, generate,\nship. This is where\nit all ends up.\nAnd yes, we're looking\nat primitive versions of\nthis. Yes, it's a\nsimple thing to do,\nbut yes, this is\nstill critically important. ZTE,\nzero touch engineering. We're\nstarting out with the\nplan phase. It'll run\na little bit faster\nbecause this is just\na chore running our\nbase model set, but\nyou get the idea,\nright? So this is\nnot worth watching. Let\nme just talk about\nthis idea a bit\nmore. And then let's\ntalk about the secret\nof tactical, logistic coding.\nWhat has this all\nbeen leading up to?\nYou can see here,\nwe've built up to\nthese incredible Outloop systems.\nOur codebase is\nrunning itself and we're\ncoming in to make\nsure things look good.\nWe're spending our time,\nbuilding the system that\nbuilds a system. And\nI know a lot\nof engineers, when you\nlook at the zero\ntouch engineering scale of\nagent decoding, you might\nthink that this is\nimpossible. There's no way\nyou're letting agents ship\nto production in your\nreal production application, right?\nYes, I completely agree\nwith you. We're operating\non a simple toy\napplication. There's no real\nrisk here, but that's\nall missing the point,\nright? I get that\nreal code basis have\na lot more complexity,\na lot more code,\na lot more wear\nand tear legacy code,\ncode debt, blah, blah,\nblah. Okay. I get\nit. I've been doing\nthis for over a\ndecade and a half.\nOkay. I know how\nthese systems look. I\nknow how they work.\nLet me just provide\nyou with a concrete\ncounter narrative for you\nto help you push\ninto the future and\nnot stick with the\ncurrent narrative. This doesn't\nhappen all at once,\nright? Like I mentioned,\nwe build this out.\none piece at a\ntime, okay? We're in\nthe age of agents.\nThis is phase two.\nSo let's act like\nit. Prepare for agentic\ncoding capabilities to go\nparabolic, okay? How do\nwe do this? We\nbuild the agentic layer\ninto your codebase.\nHere's a really, really\nimportant question to ask\nyourself. As models continue\nto improve, as tools\ncontinue to progress and\nbecome more capable, who\nknows what the next\ncloud code like leap\nis going to be?\nIf you don't invest\ninto the agentic layer\nof your codebase,\nyou know when agents\ncan solve your problem\nclass that you're working\non end to end\nwith no oversight? How\nelse will you know\nunless you're trying to\ndo this? Okay. I\ncan guarantee you right\nnow, you are doing\nengineering work you do\nnot have to do.\nI can tell you\nthat as a fact.\nOkay. Unless you're one\nof the one fractions\nof a percent of\nengineer that likely have\nalready been following a\nlot of my work,\nthere is work that\nyou are just doing\nthat you do not\nneed to do. Everything\nstarts small and then\nit compounds. Your first\nagent should ship a\nclass of chores that\nyou know you can\nship over and over,\nright? Simple stuff like\nthis, front-end changes, database\nmigrations, right? Simple, low\neffort, easy to validate,\neasy to test, encode\nyour engineering, template your\nengineering, let your agentic\nsystem, let your ADWs\nprove to you that\nthey can do this\nwork, right? That's your\nresponsibility to encode that\ninto the agentic layer.\nEverything starts small, think\nin the gray, but\nonce you start down\nthis path, you realize\nsomething very quickly, it\nwill compound. Your first\nagent ships a chore,\nyour next agent Agentec\nworkflows, start shipping bugs,\nthen features, and then\nthey'll do it five\ntimes and they'll do\nit 20 times and\nthen they'll do it.\nHere's the important part\nfive times in a\nrow. And you'll realize\nthat you add no\nvalue by reviewing. In\nfact, you slowed things\ndown. And this is\nthe key. Of course,\nhere in tactical Agentecoding,\nyou and I, we're\nnot focused on the\npresent. We're not focused\non the past. We\nwant to be on\nthat in that sweet\nspot, leaning toward the\nfuture. Here's a great\nvisual for you. The\nfuture is coming at\nyou at a constant\npace. You have three\noptions really four options\nyou can neglect the\nchange and just run\naway do it the\nold way go in\nbuilds a system. This\ngets you to an\nincredible place. And this\nis like a simple,\nsimple comparison, right? Imagine\nan engineer that runs\ntoward the future, right?\nThey set up agents\nin the codebase\nto solve problem classes.\nAt the end of\nthe day, a couple\nof weeks, maybe a\nmonth of investment, right?\nProbably not. You probably\ndon't need that. But,\nyou know, let's say\na week to a\nfew weeks of investing\nin your agent declare.\nOver time, all of\na sudden, they have\n90% confidence that a\nwhole class of chores\nor bugs will ship\nwith minimal risk. They\nwrite a single prompt,\nhit enter and ship\ninto production. Zero touch\nengineering. 90% of the\ntime, there's no issues.\nAnd that number keeps\ngoing up. Every tool\nrelease, every model release,\nevery time they improve\ntheir organic layer. Okay.\nNow imagine the other\nscenario. Let's say you're\nstanding still or you're\nmoving away, right? Say\nyou're running away. You\nopen up the terminal,\nyou look at JIRA,\nright? You look at\nyour task management tool,\nyou pull it up\nin your in-loop IDE.\nHopefully you're using cloud\ncode, but if you're\nnot on board with\nsome of these ideas,\nyou're probably maybe not\neven using it, right?\nMaybe you don't use\nan agent at all.\nYou write the prompt,\nyou sit, you wait,\nyou iterate, you retest,\nand you do all\nthis stupid stuff that\nyou can have your\nagents do. Okay, tell\nme who wins this.\nTell me who makes\ntheir business more money.\nTell me which engineer\nis better. Okay. I'm\ngetting like getting super\ninto this because it's\nso important. This is\nit guys. This is,\nthis is the peak.\nThis is the pinnacle.\nThis is the change\nthat you have to\nmake, right? There's the\ncode. There's the ADWs,\nright? We're going to\nbreak things down. We're\ngoing to go from\nthe compositional level up\nto concrete examples in\nlesson eight, but we're\ngoing to round things\nout in a fantastic\nfashion. But the real\nthing, the real hurdle,\nthe challenge of tactical\nagentic coding is about\nyour belief You have\nto believe that the\nagentic layer is worth\ninvesting into you. You\nhave to trust me.\nYou have to invest\ninto this, okay? If\nyou don't believe that\nyour agents can run\nyour codebase, you're\ncooked, all right? I\ncan't be any more\nblunt than I am\nhere. I'm trying to\ngive you everything you\nneed here, okay? If\nyou think that zero-touch\nengineering is in the\nfar future for you,\nthat's fine. You know\nwhat? You might be\nthis, right? There is\nno value in me\nreviewing this. So there\nwe go. We just\ngot the documentation phase.\nAnd in a moment\nhere, this is going\nto ship all the\nway out to prod.\nIn our case, prod\nis just pushing to\nthe main branch. There's\nnothing very easy to\nsee here, but for\nyou, this will be\nyour deploy, go to\nstaging, go to production,\nhowever your engineering is\nconfigured. How are we\ngoing to round out\ntactical agent decoding, right?\nWhat has this all\nbeen about? Obviously here,\nyou can see the\ntrend. It's about the\nagentic layer, but let\nme just share the\nsecret with you. Zero\ntouch engineering is the\nnext stage in the\nvelocity scale. This is\nan advanced edge next\nlevel concept, but this\nis something you wanna\nbe working toward. This\nis the tactic of\nlesson seven. Target zero\ntouch engineering. In the\nend, you want no\noverview, no oversight because\nit's been embedded into\nyour agents, right? Your\nagents have gotten so\ngood and your templates\nhave gotten so great\nthat your agents know\nhow you would do\nthe work. And you\nknow, how is this\npossible? It's only possible\nbecause you've encoded your\nengineering. You've told your\nagents, you've instructed your\nsystem, you've trained your\nsystem to know when\nthings are ready for\nproduction. Right, maybe you\nadd another step on\nthe software developer lifecycle.\nMaybe you've add that\nkey deploy check step,\nbunch of deterministic deploy\nchecks, whatever you want\nto do. Maybe you\ngo super hard on\nyour review step. Maybe\nyou add video to\nreview. Maybe you add\ndouble agent check, right?\nMaybe you parallelize the\nreview step so that\nthree agents have to\nsay, three pipelines of\nagents have to say,\nthis is right. You\ncan run the fusion\nchain on agents. Okay,\nit doesn't matter, right?\nIt really doesn't matter.\nAnd this leads us\nto the secret of\nTactical Agentic Coding. This\nis what everything's been\nbuilding up to. The\nsecret of tactical agentic\ncoding is that it's\nnot about the software\ndeveloper lifecycle at all.\nIt's about composable agentic\nprimitives you can use\nto solve any engineering\nproblem class. I'm just\ngonna say that again.\nThe secret of tactical\nagentic coding is that\nit's not about the\nsoftware developer lifecycle at\nall. It's about composable\nagentic primitives you can\nuse to solve any\nengineering problem class. The\nsoftware developer lifecycle is\npowerful, but it's a\nremnant of the past.\nIt's been very powerful.\nIt's still very relevant.\nIt's something that we\nbet big on, but\nthere's no doubt in\nmy mind, it is\nnot the optimal way\nto run software with\nagents. This is a\nnew paradigm of building\narbitrary AI developer workflows\nthat can and will\noutperform the software developer\nlifecycle. It's all about\nthe composable pieces that\nyou put together. It's\ngoing to look a\nbit different for every\nsingle organization and every\nsingle engineer. And yes,\nlikely your AI developer\nworkflows, right? Your end-to-end\nsystem will contain similar\nsteps. Right, plan, build,\ntest, review, document. But\nmy point here is,\nit's not about these\nsteps. It's not about\nthe software developer lifecycle.\nWhat we've done here\nis, throughout Tactical Agent\nDecoding, the key has\nbeen showing off how\nyou can use and\ncompose the new fundamental\nunits of engineering to\nsolve problem classes, right?\nSets of problems. We're\nnot solving one-off problems\nanymore. All we've been\ndoing is showcasing what\nthis could look like\ninside of the agentic\nlayer of your code\nbase, okay? Let me\nbe super clear. I'm\nsaying that this arrangement\nof ADWs is completely\narbitrary. There is no\none way to do\nthis. The one way\nis the way that\nships in your code\nbase. This is just\na starting point, right?\nThis is a package\nfor me to deliver\na message to you.\nIt's about how you\norganize your codebase.\nIt's about always having\nfeedback loops. Okay. We're\nnot coding anymore, right?\nWe've stopped coding because\nwe've templated our engineering\nand our agents can\nship on our behalf.\nWhen we ship, we\nadopt their perspective. And\nof course, when you\nput all this together,\nyou can stay out\nthe loop because you\nhave one agent, operating\non one prompt with\na single purpose. You\nhave more precision while\nother engineers are trying\nto stack up into\none context window. You're\nfiring strongly defined specialized\nagents that execute one\ntask at a time\nand hand off their\nwork. You are composing,\nyou are orchestrating intelligence.\nIt's about the primitives.\nThis is the secret\nof tactical agent decoding.\nLet's check our Zero\nTouch engineering workflow. And\nyou can see here,\nit has been deployed\ncoding. All right, so\nwhat happens next? Take\na moment to just\nappreciate what we've done\nhere. We have seen\nthe future of where\nthis is all going,\nright? We've transcended the\ntraditional engineering velocity scale\nin loop, Outloop zero\ntouch coding. You understand\nthat the agent layer\nis the highest leverage\npoint in your code\nbase. This is the\nplace where one X\ninput becomes 10 X\noutput and 10 X\ninput becomes 100 X\nif you invest in\nthis layer, okay? everything\nI've shown you, everything\nwe've worked through in\nTAC so far, the\nplan, build, test, review,\nand document is just\none way to compose\nagentic primitives. The software\ndeveloper lifecycle we've been\nusing is powerful. It\nworks, but it's a\npackage for me to\ndeliver a message to\nyou. The real secret\nis that it's about\nthe composable units, the\nagentic primitives, all the\nway down to the\nprompt level, all the\nway down to cloud\ncode, all the way\nup to how you\norganize your codebase,\nhow you add tests,\ndocumentation, how you add\ntypes, and how you\nbuild up prompts, specs,\nplans, templates, and at\nthe highest level, how\nyou organize AI developer\nworkflows, ADWs. You'll want\nto resist this and\nyou'll doubt that Outloop\nand ZTE are the\nfuture of engineering, but\nthis is the crux\nof tactical agent decoding.\nThis is the real\nchallenge I have for\nyou in this course.\nIt's not about the\ncode. The ideas are\npowerful, but the most\nimportant thing is that\nyou must update your\nbeliefs. This is a\nbelief change that you\nmust make for 10\nto 100x scaled engineering\nwith agents. And once\nyou do this for\nyourself, something incredible will\nhappen. Once you truly\nget this and start\nbuilding it out, once\nyou see the productivity\ngains, you're gonna have\nseveral aha moments and\nthen you'll realize that\nyou can unlock this\nvalue for your team\nand for your org.\nIn-loop agent decoding is\nthe lowest hanging fruit.\nDo not remain here.\nYou are an engineer,\nnot a coder. Build\nthe system that builds\nthe system and you\nwill become an irreplaceable\nengineer. Focus on the\nagentic layer over everything\nelse. Clear your schedule,\ntell your boss, tell\nyour lead, tell your\nteam, and most importantly,\ntell yourself, okay? Because\nif you do this\nright, it will change\neverything. What we're gonna\ndo next in lesson\neight, we're gonna blow\nthis idea wide open,\nokay? The primitives are\nthe atoms of agentic\nengineering. Master them and\nyou can build any\nmolecular structure you need.\nThink about what this\nmeans. Every codebase\nhas unique problems. Every\nteam has unique workflows.\nEvery domain has unique\nchallenges, but primitives remain\nconstant and composable. In\nlesson eight, your final\nlesson, we're going to\nfocus in on this.\nWe're going to do\ntwo things. We're going\nto revisit the atoms\nof agentic coding, the\nnew fundamental primitives of\nagentic coding that you\ncan use. And then\nwe're gonna look at\ncompositions of them. We're\ngoing to scale up\nand we're going to\nlook at different code\nbase types with their\nown agentic layers, solving\ntheir own unique problems\nthat you likely have\nencountered in your engineering.\nOkay. I'm going to\ngive you many code\nbases you can use\nto explore, understand, and\nquick start your agentic\ncoding of your agentic\nlayer. Okay, you'll see\nhow these primitives compose\ndifferently for web app,\nCLI tools, notebooks. Most\nimportantly, you'll understand how\nto jumpstart the process\nof building your agentic\nlayer for your code\nbase and your domain\nproblem. And finally, we're\ngonna look beyond the\nedge right at the\nend of lesson eight.\nJust like in principled\nad coding, we're gonna\nlook at how we\ncan best position ourselves\nto win today's engineering\nand tomorrow's engineering. Full\nrecap, you've reached zero\ntouch engineering. You now\nunderstand where this all\ngoes from in loop\nto out loop to\nzero touch engineering you've\ndiscovered the secret, you\nhave the full picture.\nAs you close the\nloop on this course,\nas you close the\nloop on tactical agentic\ncoding, you have to\nanswer this question. Are\nyou running away from\nthe future? Are you\nstanding still? Are you\nmoving toward it? Or\nare you gonna join\nme and sprint toward\nthe future with these\ntactics of agentic coding?\nGreat work here. Thanks\nfor following me through\nthis. I hope everything\nmakes sense to you.\nI'll see you at\nthe edge in lesson\neight.",
  "summary": "This advanced lesson reveals ZTE (Zero Touch Engineering) - the North Star of agentic coding where your codebase ships itself. The lesson demonstrates shipping five features simultaneously using parallel agent execution pipelines with Git worktrees for isolated environments. Key tactic: Scale Your Agents - use multiple isolated environments to run agent pipelines in parallel. The lesson progresses from In-Loop (prompting back and forth) to Out-Loop (AFK agents with PITER framework) to ZTE (zero human touch end-to-end). The secret revealed: Tactical Agentic Coding is not about the software developer lifecycle - its about encoding YOUR engineering practices into systems that can execute autonomously. The goal is building systems where agents know how YOU would do the work.",
  "key_concepts": "1. ZTE - ZERO TOUCH ENGINEERING: The North Star of agentic coding. Your codebase ships itself with zero human touch. Progress from In-Loop to Out-Loop to ZTE.\n\n2. SCALE YOUR AGENTS: The seventh tactic. Use multiple isolated environments to run agent pipelines in parallel. Doesnt matter if you use Git worktrees, VMs, or Docker - just that you CAN scale.\n\n3. GIT WORKTREES: A technique for parallelizing AI developer workflows. Each worktree is an isolated copy of the codebase where a specific agent can build without conflicts.\n\n4. PARALLEL AGENT EXECUTION PIPELINES: Run multiple agents simultaneously in isolated environments. Ship five features at once instead of one at a time sequentially.\n\n5. THE PROGRESSION: In-Loop (prompting back and forth at your device) to Out-Loop (AFK agents with PITER framework) to ZTE (zero touch, fully autonomous end-to-end).\n\n6. THE SECRET OF TAC: Tactical Agentic Coding is NOT about the software developer lifecycle. Its about encoding YOUR engineering practices into systems that execute autonomously.\n\n7. ENCODE YOUR ENGINEERING: Your agents know how YOU would do the work because youve encoded your practices into templates, prompts, and ADWs. Train your system to know when things are production-ready.\n\n8. END-TO-END SHIPPING: Plan, Build, Test, Review, Document - all steps automated. High-level prompts trigger full pipelines that deliver completed, tested, reviewed work.\n\n9. ORDER OF MAGNITUDE IMPROVEMENT: Fully investing in your agentic layer delivers massive engineering velocity improvements. What took hours now takes minutes with parallel execution.\n\n10. CUSTOMIZABLE VALIDATION: Add deploy checks, double agent reviews, video review, fusion chains on agents - whatever validation YOUR engineering practices require before production."
}