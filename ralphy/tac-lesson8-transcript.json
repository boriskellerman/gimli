{
  "video_id": "the-agentic-layer",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/the-agentic-layer",
  "title": "The Agentic Layer",
  "channel": "Agentic Engineer",
  "duration": 3700,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T04:08:01.109Z",
  "transcript": "Welcome to Tactical Agentic\nCoding, Lesson 8, your\nfinal lesson. Everything we've\ndone so far has\nled us here. You\nhave all the information\nyou need to become\nan irreplaceable engineer in\nphase two of the\ngenerative AI age, the\nage of agents. In\nthis lesson, we cement\ncritical Agentic Coding ideas,\ntactics, and beliefs by\nrevisiting the atoms that\nmake up everything we'll\ndo as Agentic Engineers\nmoving forward. We understand\nthat these tactics, they're\nnot bound to the\nsoftware developer lifecycle or\nany specific engineering workflow.\nThey're here to serve\nyour engineering. They're building\nblocks for you to\nuse to compose repeatable\nsolutions for your agents.\nWhen I say build\nthe system, that builds\nthe system, we're talking\nabout the new agentic\nlayer of your codebase.\nImagine a ring around\nyour codebase. At first\nit's thin, then it\nbecomes thicker as you\nscale agentics into your\ncodebase. Machines that operate\nwith your judgment, shipping\nyour way getting work\ndone autonomously in your\nproduct. In this agentic\nlayer, this is where\nyou template your engineering\nand teach your product\nto build itself. This\ncourse in its essence\nrepresents an opportunity for\nyou to pull the\nfuture into the present.\nThere's engineering work you're\nspending time on that\nyou don't need to\nbe. As time goes\non, as tools improve,\nas models continue to\nprogress, you'll be able\nto hand off more\nand more work to\nyour agentic layer. The\nirreplaceable engineer we set\nout to be in\nthe beginning of this\ncourse operates differently than\nengineers of today. We\nbuild the system that\nbuilds the system. We\noperate on the agentic\nlayer much more often\nthan we operate on\nthe application layer. At\nthe end of this\ncourse, there'll be a\nsingle guiding question you\ncan use to know\nwhether you're moving in\nthe right direction or\nnot. This guiding question\nrepresents the oil of\nthis course. All the\nAgentic KPIs, every\ntactic, it compresses all\nof it into a\nsingle question. When I\nset out to create\nthis course, I wanted\nto create a tactical\nday to day useful\nset of information for\nyou. And that's what\nI've done here at\nthe end of one\nlast question for you\nthat represents this entire\ncourse, but we have\nimportant ideas to discuss\nbefore we get there.\nIn this lesson, we'll\nwork through four unique\ncodebases, each with\ntheir own agentic layer.\nThe whole point here\nis to give you\nhands on quick starts\nyou can use to\nbuild that V1, that\nproof of concept, that\nminimum viable agentic layer\nof your codebase.\nLet's cover your final\ntactic of Agentic Coding.\nPrioritize agentics. This tactic\nhas been staring us\nin the face the\nentire time. This tactic\ncan drive massive return\non investment decision-making every\nsingle day you work\nand build with agents.\nIt's simple. It's everything.\nPrioritize agentics. More specifically,\nprioritize your agentic layer.\nAgentics refer to systems\nor entities capable of\nautonomous action and decision-making.\nThis tactic represents all\nothers, from target zero-touch\nengineering all the way\nback to stop coding.\nAll tactics are compressed\ninto this tactic. Prioritize\nyour agentic layer. Prioritize\nagentics. The trick of\nthis tactic is that\nit will fluctuate, but\nas a general rule,\nthe more time you\ninvest into your agentic\nlayer, the thicker you\nmake that layer around\nyour codebase, the\nmore your agentic layer\nwill be able to\nsolve problem classes on\nyour behalf. As a\ngood starting point, I\nrecommend half of your\nengineering time, at least\nhalf, should be spent\non the new agentic\nlayer. And of course,\nwhen you're starting out,\nwhen you're building it\ninitially, you're gonna wanna\nput in a lot\nof upfront effort. So\nlet's make this absolutely\nclear. There's the agentic\nlayer, and then there's\nthe application layer. And\ninside application layer, I'm\nbeing very vague. We're\ntalking DevOps layer, infrastructure\nlayer, database layer, and\nthe actual raw application\nlayer, okay? It all\ngoes under there. There's\nthe application layer, and\nthere's your agentic layer.\nI recommend more than\nhalf of your time\nshould be focused on\nthe agentic layer. As\nwe work through these\nfinal codebases, Keep\nyour eyes on the\nprimitives. Keep your eyes\non the composable units\nof Agentic Coding that\nmake up the work\nthat you're going to\nsee. Focus on the\npieces that make the\nwhole, from the individual\nagentic prompts up to\nthe composed multi-step AI\ndeveloper workflows. This is\nwhat matters. Not the\nsoftware developer lifecycle, not\na model, not a\ntool, not Claude Code.\nIt's the primitives, right?\nAnd to be clear\nhere, Claude Code represents\nthe first viable engineering\ntool that unlocks agentic\nengineering, that unlocks agentic\ncoding, but it won't\nbe the last, okay?\nWe know tools will\nchange and models will\nimprove. We can't fixate\non these, okay? I've\ntalked very little here\nas you've noticed throughout\nthe course I've talked\nvery little on clog\ncode specifically this is\nvery intentional okay this\nis not a clog\ncode course very clearly\nthis is a course\non Agentic Coding tactical\nAgentic Coding key ideas\nyou can bring to\nthe battleground of engineering\nwith agents every single\nday okay that's what\nthis has all been\nabout and in this\nlesson your final lesson\nwe close the loop\non this course. Let's\nstart by pushing you\ntoward the minimum viable\nagentic layer. Let's work\nour way through different\nexamples, different shapes of\nwhat this agentic layer\ncan look like. You'll\nsee a lot of\nsimilarities. I've repurposed a\nlot of the work\nwe've done up to\nthis lesson throughout these\ncodebases, but keep\nyour eyes on the\nprimitives. As usual, we're\ngonna open the terminal.\nLet's clone in the\nlesson eight codebase.\nWe'll CD in. If\nyou type LS, you'll\nnotice we have five\ndistinct Now I might\nupdate this architecture to\nmake this simpler and\nflatten them all. But\nat the time of\nfilming inside this code\nbase for simplicity, we\nhave five distinct applications.\nWe're going to work\nthrough three to four\nof these. Let's start\nwith the agentic layer\nprimitives. The agentic layer\nyour codebase, restarting\nprocesses, so on and\nso forth. And then\nwe get to the\ninteresting bits. So we\nhave a implement command.\nRemember, this is a\nhigher order prompt. It's\na prompt that takes\nanother prompt as an\nargument, right? We pass\nthis into the prompt.\nAnd then of course,\nwe have a very\nimportant piece of the\nagentic layer, your templates.\nThese are meta prompts.\nThey template out what\nyour engineering workflows look\nlike. Okay, if we\ncollapse everything here, you\ncan see a classical\nmarkdown prompt structure. And\nwhat we have here\nis very, very powerful.\nWe have plan format.\nDo not underestimate the\nplan format. We're having\nour agents do work.\nThey're researching the code\nbase and they're going\nto plan work, create\na plan to complete\nthe chore described. And\nso this is a\nV1 template meta prompt\nthat you can use\nto get started automating\nwork inside your code\nbase. This is powerful\nbecause we're taking a\nhigh level prompt that\nwill pass into this\nand then our agent\nwill do the research\non our behalf, right?\nIt can search your\ncodebase, it can\nnavigate, It can make\nconnections faster than we\ncan, and it's going\nto continue to improve\nfaster and faster, and\nit's going to get\nbetter and better. Okay,\nso here we're templating\nour engineering. And while\nwe're working through this,\nright, while you're building\nout your meta prompts,\nyou want to be\nthinking from your agent's\nperspective. Is this the\nengineering workflow and the\npattern that you would\nuse to solve the\nproblem set at hand?\nAnd notice how we're\nfocusing on problem sets.\nWe're focusing on problem\nclasses, not one-off fixes,\nokay? You wanna solve\nthe class of problems\nthat you're approaching. And\nyou can do that\nby templating your engineering\ninside of these powerful\ntemplate meta prompts. This\nis a prompt that\ngenerates a prompt. And\nthen of course, we\ncan have different variations\nof this, right? This\nis a template that\nsolves the problem of\nfixing chores, right? We\ncan also have one\nthat ships features. Okay.\nAnd so here we\nhave more details. We\nhave more information, but\nit's the same idea,\nright? We have a\nprompt, we have instructions,\nwe have code-based structure,\nand then we have\nthe plan format. Okay.\nThis is all familiar.\nWe've worked on this.\nThese are key parts\nof the 12 leverage\npoints of Agenda coding.\nWe have the in-agent\nleverage points, the core\nfour context model prompt\nand tools. And then\nwe scale that further,\nright? You have specs,\nyou have templates and\nyou have ADWs. So\nlet's talk about the\nhighest abstraction level. Once\nyou start collecting your\nprompts, once you start\nusing them right in\nthe loop, you want\nto quickly start moving\nout the loop and\nyou want to quickly\nstart scaling up and\nchaining together useful pieces\nof Agentic Coding. The\nbest way to do\nthis is to get\noutside the agent, get\noutside the prompt interface,\nright? Whatever application you're\nusing, you're gonna be\nwatching this in the\nfuture. Claude code will\nvery likely still be\naround, still be very\npowerful and useful. But\nthe whole point is\nthat you're detached from\nany tool. It's just\nabout Agentic Coding. It's\nabout tactics that you\ncan use to agentic\ncode. And one key\nconcept, the highest level\nof abstraction is the\nAI developer workflow. We\nhave a dedicated directory\nthat uses these prompts.\nHere, our agentic layer\nreally starts to take\nshape and starts to\ntake form. A great\nplace to start here\nis just the ADW\nprompt. You can literally\njust come in here\nand prompt against your\nagent. And this script\nis super simple. It's\ngot really great concise\nlogging. You can use\nthis to understand where\nand what the output\nlooks like from this\nClaude Code agent. This\nis where it all\nstarts, okay? So we\ncan just quickly run\na concise prompt here,\nclear this instance, paste\nthis, and I'll just\nsay, list all files\nin the ADWs directory\nand a concise output\nof their purpose. So\nwe can paste this,\nI'll update the path\nto ADWs, and then\nwe can execute this\ntop level script. This\nADW is calling an\nagent, okay? This is\ndistinctly different from any\nother type of code.\nOkay. This script is\nthe gateway into agentic\ncoding, right? It's the\nminimal version of what\nyou need to get\nstarted. And yes, it\nis just calling a\nClaude Code instance and\nmanaging all the surrounding\nstate. Just to mention\nit throughout the course,\nwe've been calling Claude\nCode right through a\nbash command, but you\ncan use the Claude\nCode SDK, their support\nfor both Python version\nmore complex, sophisticated, tying\nthem together with the\nright engineering workflows that\nactually deliver work for\nyou, okay? This is\nit. This is the\nthinnest layer. And now\nwe can stack this\nup and start progressing.\nInside of the ADW\nslash command, we can\ncall any slash command\nwe want. So say\nwe wanted to run\nthat slash start, we\ncan Just fire this\noff and just like\noperating in a Claude\nCode instance, right? Just\nlike being in the\nloop by creating a\nscript that can surround\nthe application, that can\nsurround any unit of\ncode, we are slowly\nmoving out the loop.\nright? I'm not responding\nhere. I'm not having\na conversation with the\nagent. I'm firing it\noff, having it operate,\nright? It's firing this\nslash start prompt, which\nliterally could be anything.\nAt first, you're fully\nin the loop, right?\nOperating inside of a\nClaude Code instance, right?\nTyping back and forth\nand back and forth.\nThis is a great\nplace to start. It's\na great place to\ndo deep work. It's\na great place to\nupdate and work on\nyour agent to glare.\nIt's a terrible place\nto stay, okay? So\nmany engineers are going\nto miss this mark.\nWhen you have a\nsuccessful product when you\nhave a product that\nyou're maintaining that you're\ngrowing the value of\nbuilding an agentic layer\nis parabolic okay it's\nabsolutely parabolic put 10\nminutes in get two\nhours of value out\nor more okay and\nhow do you do\nthat you wrap your\ncodebase in an\nagentic layer It starts\nthen, it's not very\nuseful at first, but\nas you keep adding\nnew AI developer workflows\nand you template your\nengineering inside your code\nbase and you make\nsure to always add\nfeedback loops so that\nyour agent can ship\nand auto improve, this\nlayer becomes more and\nmore important, more and\nmore valuable. Nice output\nthere. We have all\nthese extraction logs here\nwe can take a\nlook at. There's that\nfull breakdown. There's that\nsjson array. We've got\nthe final object and\nthe custom summary that\nyou can just build,\nput together whatever pieces\nyou want to see.\nSo again, this layer\nof control is really\nimportant. So we can\njust keep pushing that\nforward, right? So after\nyou get the prompt,\nslightly at the loop\nand your slash commands\nagain, slightly at the\nloop, you can then\nstart building real AI\ndeveloper workflows, right? Where\nyou chain together multiple\nprompts. Here we have\nchore implement. This is\nultra simple. It runs\nslash chore right here\nas a template and\nthen it runs slash\nimplement, okay? And this\nis, you know, there's\nnothing complicated happening here.\nIt's a bunch of\nlogging. I wanna really\nbring everything back to\nthe fundamentals here, right?\nThere's nothing complicated happening.\nWe're running two prompts\nback to back in\nan agent. These are\nagentic prompts, so they're\ndoing a lot more\nwork than normal. We\nhappen to be running\na template meta prompt,\nright? This is the\nchore file. And then\nonce that gets built,\nthe chore response has\nthis output. It outputs\na plan path, and\nthen we take that,\nand guess what we\ndo with it? We\npass it right into\nimplement. If you look\nat implement, you can\nsee that we have\none argument, which is\nthe plan. And this\nbegins infinite combinations and\ncomposables that you can\nput together to solve\nreal engineering problems. There\nare many, many ways\nto slice this, right?\nYou can make a\nchainable ADW, right? A\none, two, it just\ncalls one prompt and\nthen it passes the\nother end. You can\nmake all types of\nconfigurations, okay? I prefer\nthis nice explicit version.\nIt's a lot more\nreadable, understandable for yourself,\nfor your engineers on\nyour team, and of\ncourse, most importantly, for\nagents that you work\nwith. This is the\nfoundational layer, okay? And\nwe can of course\nrun this, right? So\nlet's just go ahead,\nplan, build something simple.\nof main in app\nslash star, okay? And\nso this will unnecessarily\nplan and build. We\ndon't need this much\ncompute for a simple\ntask like this, but\nI just wanna showcase\nthat you want complete\ncontrol over your agentic\nworkflow. The best way\nto do that is\nyou don't wanna keep\nthem in prompt form.\nYou wanna scale them\nup and fuse them\nwith the non-deterministic world\nof raw code. The\nwhole point here is\nthat you can use\nyour prompts inside of\nthis new agentic layer\nand scale up and\nbuild out unique developer\nworkflows that solve sets\nof problems. Right here,\nwe're creating a plan\nand we're building. The\nway we plan and\nthe thing we build\ncompletely depends on your\nuse case, but you\ncan see here we\nhave a plan generated,\nright? It's gonna be\nsuper, super simple, but\nit has all of\nour engineering practices encoded\nfrom the template meta\nprompt. And then of\ncourse apps right here,\nwe're gonna see this\nnew file pop up\nhere in just a\nmoment, right? We're implementing\nthe plan. There it\nis, main.sh, great. And\nour agent will love\nlikely automatically validate this.\nYeah. So it's going\nto run this. It's\ngoing to do this\nwork for us, right?\nexamples here and showcase\nthe result of the\nagentic layer, right? Showcase\nwhat the agentic layer\nwill give you as\nyou make the layer\nthicker and thicker and\nthicker, and as the\nagentic layer operates on\nyour codebase, okay?\nSo this is fantastic.\nLet's go ahead and\nopen up. the next\nlayer back in tech\neight. Let's open up\nthe multi-agent to done\napplication, not to do\nto done. Okay. So\nto done, what does\nthis do? If we\nopen up our apps\nhere, you can see\nwe're working in a\ndata science, classical Jupiter\nnotebook scenario. So we\ncan execute this top\nto bottom and we\ncan just see that\nwe're operating on a\nsimple tweets CSV file\nand just looking through\na bunch of tweets\nand running some arbitrary\nanalysis and classification on\nsome tweets sentiment distribution\n5050. That's definitely not\nthe true distribution. But\nyou know, you can\nsee here, we just\nhave a simple Jupyter\nnotebook where we're doing\nsome data exploration. Now,\nall of the application\nlevel work that we've\ndone here, it's all\nexample codebased work\nhere. So this isn't\nimportant. Okay, what is\nimportant is our agentic\nlayer. So whatever type\nof application layer you're\nworking with, every one\nof these agentic layers\ncan be built for\nyour codebase. All\nright, keep that in\nmind. Now, how does\nthis work? We have\na simple task management\nsystem. You can see\nwe have this file\ndown here, tasks.markdown. Let's\nopen this up and\nbreak down what's going\non here. Just by\nlooking at this file,\nyou should be able\nto understand that we\nhave a multi-agent Git\nWorkTree based system here.\nAnd so again, this\nis just another way\nyou can organize. I'm\ngoing to paste in\na new set of\nprompts here for our\ntask list. So I'm\njust gonna paste this\nin. We're gonna have\nour agents get to\nwork on this, okay?\nSo you can see\nhere, we're working across\nfive Git WorkTrees. They're\njust going to do\nengineering work for us,\nright? Across five WorkTrees.\nSo let's kick this\noff. We of course\nare going to open\nup our AI developer\nworkflows. This is where\nthe agentic layer is\nmanaged. and we have\nour trigger. So our\ntrigger is how we\nstay out the loop,\nright? This is pushing\nus from in loop\nto out loop and\neventually to ZTE. All\nwe're gonna do here\nis kick off our\nADW. So I'm just\ngonna open this, copy\nthe relative file path,\nUV run, and we're\ngonna kick this off.\nAnd this is gonna\nbe really interesting, okay?\nSo we have a\ngray area in loop,\nout loop system here.\nWe're operating on this\nkind of shared task\nfile. Every five seconds,\nour trigger is going\nto pick up on\ntasks that need to\nbe operated. And so\nyou can see here,\nit found seven tasks\nto kick off and\nwe're now going to\nstart creating these work\ntrees. Okay. So these\nare dedicated environments for\nagents to work in,\nright? We're scaling up.\nThis is an example\nof a thin agent\nlayer scaled up just\na little further. Okay.\nWe have this simple\nmulti-agent system where we\ncan delegate work. And\nthere's something really special\nabout this, right? This\nis a powerful system\nfor work, like data\nscience for data engineering\nwork, because oftentimes when\nyou're building out these\nclassifiers, when you're building\nup models, you're running\nmultiple versions, multiple experiments,\nright? And so this\nis a powerful way\nto do this. You'll\nnotice something very powerful\nhere too at the\nend. At the end\nof some of our\ntasks, we have tags.\nAnd so this is,\nas you can imagine,\narbitrary information we're passing\nin to our AI\ndeveloper workflows, right? That\nchanged the way the\nworkflow runs. Opus obviously\nkicks up our model,\nand then we have\na ADW plan implement\nupdate task. So this\nis going to run\na different AI developer\nworkflow for this set\nof work. You can\nsee where this goes.\nYou can see our\nagents are, I'm not\ndoing this by the\nway, right? This is\nall our ADWs and\nour agents starting to\npick up work and\nget to work. So\nwe're scaling outside of\nthe traditional UI, right?\nWe're pushing past the\noverkilled chat-based UI, right?\nWe have a two-way\ntask list and you\ncan see this yellow\nkind of sun emoji\nhere and a git\ncommit hash. This uniquely\nmarks this agent executing\non work, okay? You\ncan imagine as I\nwork here, you know,\nthroughout my day, I\nreview this work tree\nand as results come\nin, I can just\nadd and update tasks\nas my agent completes\nwork, okay? So this\nis a small tweak.\nThis is one or\ntwo files of our\nagents. And all of\na sudden we're able\nto do a lot\nmore with a multi-agent\ndedicated workspace system. Let's\ngo ahead and take\na look at what\nthis looks like, right?\nSo you can see\nvery, very similar setup,\nright? AI developer workflows.\nAnd then underneath all\nthat is our prompts\nthat run. Same pattern.\nYou're gonna see this\nover and over. These\nare the atoms. You\ncan see we got\nanother commit message there\nkicking off. We're adding\nour cron trigger. I'm\nnot gonna dive into\nall this. You have\nall this code available\nto you, right? So\nafter you finish this\nlesson, your final lesson\nhere, dive in, understand\nwhat you can do.\nOkay, these are all\nexample starting points. Then\nsame kind of deal\nhere, right? We have\nthat same ADW prompt,\nwe have slash command,\nbut then we have\nreal useful composed developer\nworkflows, right? Workflows that\nput together prompts and\ncode to do real\nengineering work. Most of\nthese workflows are just\ngoing to kick off\nthe build update task.\nIf you just search\nfor build, update task,\nyou can see that's\nthat workflow script that's\ngetting kicked off there\nby default. But if\nwe pass in our\nupgraded ADW ID, it\nwill also perform a\nplan implement, right? So\nit'll run this other\nAI developer workflow. Okay,\nso our trigger helps\nus stay further out\nthe loop so that\nwe can operate more\nquickly, right? We're not\nprompting back and forth\nand back and forth.\nWe're scaling up the\nnumber of agents we're\nrunning with this task-based\nsystem. Prong trigger helps\nus do that. And\nyou can see here\nagents are just rolling\nin work, right? They're\nrolling in work. And\nso you can imagine\nwhat these emojis are,\nright? Check means done.\nAnd we have this\ntimer. This means blocker.\nSo you'll notice, you\nknow, this timer here,\ndidn't start until the\ntwo above were checked\noff. Okay. So this\nis just an arbitrary\nagentic layer. I just\nbuilt this out this\nway. Okay. You can\nbuild it any way\nyou want. That's great.\nAnd so, you know,\nsame deal here, right?\nIf we jump into\nbuild update task, we\ncan just slash search,\nalways just slash search\nyour prompts. You can\nsee there, we initialize\nthe work tree. That's\none important piece. And\nthen we of course\njust call build. right\nslash build with the\ntask. It does the\nwork, writes the commit\nmessage and we can,\nyou know, look at\nbuild here. All of\nthis can be done\nin the loop, but\nthat's just the place\nyou want to start.\nOkay. Of course it\ncan be done in\nthe loop, right? This\nis the lowest hanging\nfruit of Agentic Coding.\nCourse you can open\nup and just write\nthe prompt yourself, right?\nAnd do the work\nyourself, but that's not\nthe point. You can't\nscale that way. Okay.\nRemember prioritize Agentics. Prioritize\nthe agentic layer of\nyour codebase. Don't\ndo the work by\nyourself. Teach your agents\nto do it. Teach\nthem how to solve\nthe problem class. Build\nthe system that builds\nthe system. We're operating\non that new agentic\nlayer. Prompts composed into\nAI developer workflows. Okay,\nbut you can see\nhere, you know, we're\njust passing that task\ndescription and then just\ngonna start do a\ncouple simple things, research,\nimplement, test, commit. This\nis more of like\na quick patch. And\nthen we have more\nsophisticated tooling. We have\na plan implement workflow,\nright? An architect and\nan editor, ultra powerful\npattern, especially when you\ncombine it. with template\nmeta prompts, which of\ncourse we have here,\nright? We have our\nplan prompt. This is\na generic plan. It's\nnot, you know, a\nchore or feature. It's\njust a plan, right?\nJust super general, super\nvague. You will be\nable to outperform these\nby going more specific,\nbut the simple plan\nprompt is a great\nplace to start. So\nsame deal there, template\nmeta prompt, very important.\nThis is a key\nleverage point of agentic\ncoding. You already know\nthat. We don't need\nto revisit that. You\ncan see here, we\ndivided up our ADWs\nand a couple of\nsub directories, just making\nthings a little easier\nto work with, right?\nYou will get to\na point where your\nADWs in itself, in\ncombination with your prompts,\nis its own kind\nof micro codebase,\nright? A wrangle layer\naround your codebase.\nAnd so you do\nwant to put good\nengineering patterns and practices\nas you scale it\nup, but keep it\nseparated from apps. Okay,\nkeep it isolated and\nseparated. This is not\nthe application layer, make\nthat clear. So let's\ngo ahead and take\na look at what's\nbeen done, right? If\nwe look at our\nwork, our agents are\njust cooking, right? They're\ngetting work done for\nus. I throw in,\nwhat did I throw\nin here? Seven, eight,\nnine, something like 10\ntasks and it all\nstarted in parallel on\nthese separate work trees.\nOkay, so let's just\ngo ahead and validate\nsome work. Okay, so\nenhanced, data training. So\nwhat we can do\nhere is open up\ntrees and you can\nsee we have the\nenhanced training data directory\nand I can just\nCD trees or actually\nI'll do this. I'll\ndo code trees and\nthen I'll paste this\nin and we're going\nto open this up\nand check this out.\nRight. So we have\na sparse checkout of\njust this directory, just\nthis codebase that\nwe're operating in. Right.\nSo it's a entire\ncopy of this environment\nof this codebase\nfor this agent to\ndo just this set\nof work in, right?\nSo let's look for\nthis tweets positive only\nthat will come up\nprobably pretty quickly. There\nit is, tweets positive\nonly, right? If we\nlook at the sentiment,\nwe can just search\nyou can take this.\nLet's go ahead and\nmove on to another\nagentic layer. Remember, it's\nall about the agentic\nlayer. There's so many\npossibilities here, so many\ncombinations, but Here at\nthe end of TAC\n8, I just wanna\ngive you concrete starting\nplaces and ideas for\nyou to start building\nyour agentic layer, prioritize\nyour agentic layer. Let's\ngo ahead and skip\napp three. I'll let\nyou open that up\non your own and\nlook through that. I\nwanna get to agentic\nprototyping. All right, so\ngo ahead and open\nthis up. So we're\ngonna code this. So\nwe have this code\nbase here all set\nup. And what does\nthis do? What is\nagentic prototyping? prototyping do.\nThis one's really cool.\nWe're fully out the\nloop here. Prototyping is\nultra important with the\ninsane pace of innovation\nin the tech ecosystem.\nYou want to be\nable to prototype quickly.\nWe can of course\nthrow agents at this\nproblem. So I have\na notion page here.\nand already you understand\nwhat this does already,\nright? We have an\nagentic prototyper as a\nnotion database in the\nboard view, okay? So\nthis is just a\nclassic board view and\nyou can see here,\nwe have multiple simple\nexamples of prompts right,\ncoming right out of\na Notion database. There\nare of course many\nways you can tweak\nthis and use this\nand improve it. We\nshould have a lot\nof our tags as\nproperties, but that all\ndoesn't matter. That's all\nbased on how you\nwanna set up your\nagents and your Outloop\nagentic systems. Remember the\nPeter framework. You have\nprompt input. For us,\nit's this Notion page.\nEnvironment, this is going\nto operate inside the\ntrees directory, which doesn't\nexist yet here, right?\nWe're gonna use dedicated\nGit work trees. And\nthen we have the\nreview system. And so\nthe review system is\ngonna be both the\nactual codebase results\nright inside the editor.\nAnd we're gonna get\nhigh level reviews as\nthese tasks progress. So\nlet me just go\nahead and kick this\noff and it'll all\nmake sense. If you\nwanna understand the agentic\nlayer, you open up\nADWs, okay? And if\nyou wanna stay out\nthe loop and look\nfor that starting point,\nyou open up the\ntriggers. Here we have\nADW trigger cron notion\ntasks. So another cron\njob that is going\nto execute. Let's go\nahead and run UV\nrun, fire this off.\nand we're gonna monitor\nand pick up Notion\ntasks every 15 seconds.\nAnd let me actually\njust reset this. And\nlet me just do\nthis a faster way.\nI'm gonna pass in\nthe once flag. Use\nthis for quickly testing.\nIt's just gonna run\nthe workflow one time\nand just pick up\nas many tasks as\nit can. So yet\nagain, another configuration of\nyour agentic layer. I'm\nnot gonna dive into\nthis one. I think\nyou're getting the pattern.\nYou're starting to understand\nwhat's happening. If you\never wanna find the\nprompt, you just look\nfor slash, right? And\nthere it is. Update\nNotion task, make work\ntree name, init work\ntree, get notion tasks,\nso on and so\nforth. And then we\nhave composed AI developer\nworkflows that actually do\nsome work for us.\nOkay. There's plan update,\nso on and so\nforth. You can see\nhere our cron, right?\nOur trigger in the\nPeter framework, our trigger\nis starting to pick\nup tasks and check\nthat out, right? It\nagentically picked up and\nmoved that task for\nus. And our agent\nis now going to\nstart working. If we\nopen this up, you\nknow, we can always\njust monitor and write\nwhatever report status update\nmessages we want to.\nThis is yet again,\nanother Outloop system. You\ncan wire up to\nagentic code, right? To\nbuild with agentics, to\nhave your agents operate\non your behalf, generating\na work tree name.\nGreat. work tree created\nand always, right, as\nalways, you can open\nup dot Claude, right,\ngo into commands and\njust see all the\npossible agentic capabilities, right?\nNow it doesn't tell\nthe full story, right?\nThis won't tell the\nfull story. If you're\nbouncing your deterministic code\nwith your non-deterministic agentic\nprompts inside of your\nADWs, right, you're going\nto need to read\nboth of these to\nget the full story.\nBut the primitives here,\nright, the atoms of\nAgentic Coding, they are\nyour prompts. This is\npart of the core\nfour. This is part\nof the in-agent system\nfor a reason and\na through-agent leverage point\nis because everything is\nbased on this, right?\nPlans, prompts, templates, ADWs,\nof important auxiliary directory,\njust paste in whatever\ndocumentation you need. But\nhere we have a\nprompt right, a meta\nprompt that builds out\nastral uv python model\ncontext protocol servers. All\nit needs is a\nprompt and then it\nbuilds out an mcp\nserver, right, based off\nthe documentation and our\nrequest, okay. And you\ncan see here very\nclearly right, template meta\nprompt, same structure, nothing\nnew happening there. You\nalready know about this,\nyou already know about\nwriting great prompts. You\nknow, you can scale\nthis to whatever type\nof codebase you\nwant to prototype, right?\nYou can imagine how\nuseful this can be.\nAnd so let's go\nahead and just quickly\ncheck in on our\ntask. In progress, not\nstarted, that's fine. Looks\nlike we picked up\nthree. So you can\nsee here, we have\nplans successfully created, plan,\nJSON format or bun\nscript, looks great. We\nhave, right, we have\nanother agent getting kicked\noff here, UV watch\nfile, so on and\nso on. forth right\nuv plan script and\nour agents are just\ngoing to progress here\nI'll probably skip through\nsome of this to\nsave some time but\nyou can see the\nworkflow right let me\nzoom out a little\nbit so you can\nsee the done column\nas well not started\nin progress human in\nthe loop review failed\nand done and you\ncan just manage everything\nhere always remember the\npeter framework this is\na review system that\nyou can use to\njust quickly operate outside\nthe loop whenever i\nneed to on my\nmobile device on a\ndifferent device you know\neven sitting right here\nright I can just\nquickly gather some documentation\nwrite up a quick\nprompt. fire off one\nof my templates and\ngenerate an entirely new\napplication here at light\nspeed, right? This is\nsomething your agents can\ndo, right? Yet another\nexample of work that\nyou don't need to\nbe doing if you\ninvest into the agentic\nlayer of your code\nbase. All right, so\nyou can see here\nwe're on the implementation\nstep. You slowly want\nto progress from in\nloop to out loop\nand the north star\nfrom lesson seven, you\nwant to target zero\ntouch engineering. This is\nwhat's going to happen\nnaturally as you continue\nto improve your agentic\nlayer. Soon you won't\nneed to review. I\nknow that sounds crazy,\nespecially if you're finishing\nthis course earlier on\nin the timeline of\ngenerative AI. This is\njust where everything is\ngoing and you want\nto lean forward. So\ncheck this out. We\nhave phase two implementation\nsuccessful. This is our\nMCP system info server.\nAnd so let's just\ngo and check it\nout. Feature MCP system\ninfo. So this is\nan MCP server that\ngives us system information,\naccessible to our agent.\nOkay. Let's do code\ntrees, feet, MCP. And\nI'm just going to\ngo all the way\ninto this here. So\nthis is the environment\nthat that agent completed\nits work in. And\nyou know, you can\nsee here that it\nmoved to done. It\nlooks like another task\ngot completed as well,\nbut this is finished.\nAnd if we click\nthis, you can see,\nLive updates, right? There's\nits summary. And of\ncourse, this is a\npresentational example. I've just\nkind of breezed through\nwhat this could look\nlike, but you can\nput anything you want\nhere. You wanna be\nobserving and monitoring your\nagentic system very well\nin your Outloop review\nsystem. Again, just examples,\njust working through this\nwith you so you\ncan understand, right? Everything\nI'm doing here is\nbuilt to help you\nunderstand what you can\ndo, okay? So let's\nlook through this here\njust super, super quickly.\nI don't wanna harp\non the exact details\ntoo much, but you\ncan see an environment\nall set here and\nwhat did this do\nso apps sys info\nmcp great what i\nwant to do is\nunderstand what this does\nso I'm going to\nopen up the readme\nthat agentically generated and\nI just want to\nsee here we go\nright I want to\nsee that dot mcp\ndot json file I'm\ngoing to create this\nat the top right\ndot mcp dot json\nright so if i\njust open up cld\nnow claude get there\nwe go get memory\ninfo mcp Get memory\ninfo. So I'm just\nrunning a random MCP\ntool that created by\nour agents and check\nthis out, right? That's\nworking perfectly. There's my\nmemory usage, 128, use\n32, available 93. Fantastic.\nOkay, so not to\nget too much in\nthe weeds of this\nexact tool, but we\ncan just do this.\nand we can do\nthis as well, right?\nGet CPU, get disk.\nOur agent created this\nfor us end to\nend, okay? You don't\nneed to be doing\nso much of the\ncheck your loot box\nall this is going\nto be available to\nyou don't fixate on\nthe exact details focus\non the agentic layer\nokay prioritize your agentic\nlayer let's look through\none more example and\nthen let's set the\ntable for the current\nphase of Agentic Coding\nthat we're in the\ncurrent age of agents\nokay so let's wrap\nup one more example\nI have something exciting\nthat I want to\nshare with you here\nif we open up\nour last example here\nwe have something familiar\nthat you've seen before.\nSo let me just\ngo ahead, shscripts start\nand shscripts aeserver start.\nAnd so we have\nsomething really, really, really\ncool here. So I'm\ngonna boot this open\nand you'll see something\nvery familiar. We have\nthe natural language SQL\ninterface that we've been\nworking in throughout the\ncourse. Okay. It looks\nlike our exact same\ncodebase. but this\nis actually very different.\nIf we type command\nP here, slash AEA,\nwe have an agent\ninside of our app.\nWe're talking with Nexus,\nhello. And of course\nwe can do something\nreally powerful. The power\nof agents isn't in\none, it's in many,\nslash AEA, spin up\nanother one, get some\nmore work done. We're\nnow talking to Roon\nas well. What is\nthis codebase about?\nOkay, and then over\nhere we'll say update\nthe generate random query\nbutton in the what\napp is this app\nfive, let's call it\ninterface to be generate.\nOkay, and so two\nagents operating for us,\nright? They're off doing\nwork. How does this\nwork? We broke one\nof our rules. Here\nwe go, check this\nout. Very, very cool.\nWe have a concise\nsummary, right? We're talking\ndirectly to our agents\nfrom inside the application.\nIf we quickly glance\nat the code, you\ncan see the exact\nsame structure. ADWs, this\nis the housing unit\nfor the agentic layer\nof your codebase.\nAnd then we have\n.Claude with our prompts\nwhere we put it\nall together. This is\nthe lower level atoms\nthat we compose together\nwhile using great leverage\npoints of Agentic Coding.\nSo it's all here.\nI'm not gonna go\ninto this in too\nmuch detail, but you\ncan imagine how this\nworks. You understand this\nlayer. We've been working\non this. We've been\ntalking about this. right,\nADW trigger, we have\na dedicated agent embedded\napplication server so that\nwe can access this\noutside the loop. In\nthis case, outside the\nloop is inside the\napplication. Okay, so there\nare many ways you\ncan play with this.\nThis is a very\npowerful idea. You can\nsee here our agents\nare doing work. They're\nresponding to us. It\nupdated this button for\nus. And this just\ngoes on and on\nand on. I'm gonna\nstop here. There's a\nlot of value in\nthis. This is a\ngreat place to branch\naway from the code\nitself, okay? The keys\nof the future of\nengineering are conceptual. It's\nall about the information\nyou have, the details\nof the code, They\nmatter, the details of\nthe prompts, they do\nmatter, which is why\nwe've broken them down\nto individual tactics. But\na lot of what\nmatters here is key\nbeliefs around what is\npossible with agents at\nyour side, with compute,\nwith intelligence that you\ncan now orchestrate. You\ncan see here throughout\nthese, you know, just\nthree, four examples, there\nare many permutations of\nthe agentic layer of\nyour codebase. This\nis the place to\nfocus, right? This is\nwhat it's all about\nnow. You can see\nthis is just a\nvery primitive, presentational version.\nYou can make your\nown fully built out\nagents inside your application\nthat can operate your\ndomain, that can operate\nyour problem set better\nand faster than you\nor any engineer on\nyour team can, right?\nAnd that's the whole\npoint, right? Template your\nengineering, give your agents\nyour capabilities so that\nyou can focus on\nthe more strategic, higher\nlevel decisions so you\ncan move up the\nstack, okay? So let's\nrecenter around tactical agentic\ncoding. What has this\nall been about? We\nset out on a\nsingle mission to become\nan engineer that can't\nreplace. Here in lesson\neight of tactical agentic\ncoding, you now have\ncode plus agentics. When\nyou put those together\nand you give them\nto your agent and\nyou adopt their perspective,\nanytime they're running, you'll\nunderstand how to build\neffective, powerful agents better\nthan anyone because they\nhave maximum leverage. When\nyou do that, you\ncan focus in more\non the agentic layer\nand template your engineering.\nThis is the way\nto set up and\nencode your engineering. You\nuse template meta prompts.\nprompts that output prompts\nin specific formats with\nspecific rules, guidelines, files\nto read, conditional documentation,\nso on and so\nforth, right? You saw\nthis throughout tactical agentic\ncoding. You saw all\nof this. This scales\nto any codebase.\nDon't make the mistake\nof thinking that the\nsimple toy examples we\nworked on here are\na bottleneck in any\nway. They're not. Don't\nuse anything as an\nexcuse to slow you\ndown here. I purposefully\nhyper-focus on the agentic\nlayer throughout this course.\nOkay, now what happens\nnext right once you\ntemplate your engineering you\nstart increasing your agentic\ncoding KPIs right? What\nare those? They're the\nmeasure of your success\nas an Agentic Engineer\nOkay, you want to\ndecrease the attempts it\ntakes for you to\ndeliver work with your\nagents you want to\nincrease the size of\nwork you can hand\noff to your agents\nyou want to increase\nthe streak of successful\nwork you're shipping with\nyour agents without making\nmistakes. And then you\nwanna drop your presence\nto the bare minimum.\nPresence is you showing\nup and writing a\nprompt and reviewing and\ndoing work with your\nagent. You wanna drop\nthis to zero. You\nwanna stay out the\nloop. There's in-loop agent\ndecoding and there's out-loop\nAgentic. More and\nmore as you progress,\nas you build up\nthe agentic layer of\nyour codebase, You\nwanna be staying out\nthe loop. You wanna\nbe building the system\nthat builds the system.\nThat underlines everything we've\ndone here and everything\nyou can do now.\nStay out the loop.\nAnd how do we\nensure that we can\ndo that? We tap\ninto one of the\ncritical leverage points. We\nalways add feedback loops.\nWe add tests. Okay,\nthese are validation commands\nthat your agent runs\nto confirm that their\nwork was successful. Okay,\nin the software developer\nlifecycle, we embedded lots\nof testing, lots of\nreviewing, lots of validation\nin the test and\nreview step. The software\ndeveloper lifecycle is a\nfantastic way to understand\nwhat you can do\nwith Agentix, what it\nlooks like to automate\nend to end. It's\na great starting example,\nbut it's not going\nto be exactly what\nyou need. You can\nbuild up any workflow\nthat you need in\nany format. It's not\nabout the software developer\nlifecycle at all. It's\nabout the composable pieces\nof Agentic Coding that\nyou can now put\ntogether to deliver more\nresults in the agentic\nlayer of your code\nbase so that your\nagents can operate on\nyour codebase. That's\nwhy we always add\nfeedback loops. The big\nlabs, the big three,\nGen AI companies, they're\nall doing this right\nnow, right? They have\nthese insane feedback loops\nwhere agents are operating,\nsolving problems, iterating on\nresearch over and over\nand over and over\nagainst some validation function.\nIf they can do\nthis at scale for\nserious, life-changing, world-changing problems,\nyou can do this\non your codebase.\nI can guarantee you\nthere is a validation,\na set of validations\nin your codebase\nthat once run ensures\neverything works perfectly, okay?\nThe only question is,\ndo you know what\nit is, right? Do\nyou know what those\ncommands are? Always add\nfeedback loops. Now, controversial\none, but it's important.\nOne agent, one prompt,\nOne purpose. There are\nlimits to what we\ncan do with agentic\ntechnology, okay? Especially if\nyou're further in the\npast and you're not\nthat far into the\nfuture, context windows are\nstill small. So how\ndo we alleviate this\nproblem? How do we\nsidestep it entirely? We\nfocus on building one\nagent with one prompt\nwith a single purpose.\nOne purpose agents. You\nsaw this throughout every\ncodebase we worked\nin. We're running one\nClaude Code instance with\nonly one exception, right?\nThe only exception is\nThis codebase, okay?\nThis is the only\nexception to that where\nwe are actually passing\nback in the session\nID back into this\nblack and white in\nengineering. There's gray, there's\nprogression, there's one day\nat a time, one\nstep at a time.\nSo at first you'll\njust solve simple small\nchores end to end\nand then eventually you'll\nrealize you don't need\nto validate this type\nof work and because\nyou always add feedback\nloops and you have\na concrete review step\nthat you've taught your\nagents how to use,\nright, maybe it's images,\nmaybe it's videos, maybe\nit's a multi-step review\nsystem, a multi-step review,\nad developer workflow, whatever\nit is, right, remember\nyou have all the\npieces to build, whatever\nyou need to now,\nyou'll run this and\nthat will be more\nthan enough. Not only\nwill you stay out\nthe loop, getting in\nthe loop will be\nharmful. So you'll drop\nthe review process and\nyou'll ship end to\nend. You will let\nyour product ship itself.\nTarget zero touch engineering.\nAnd finally, putting it\nall together, we prioritize\nagentics. If it isn't\nclear, this is the\nplace, the area of\nfocus of the largest\nreturn on investment. Let's\nbe super clear. What\nis the agentic layer?\nIt is the combination\nof traditional deterministic code\nthat is stored in\nyour ADW's directory as\na scriptable layer that\ncombines deterministic code with\nthe new non-deterministic agentic\ntechnology, the language model,\nthe agent, Claude Code,\nand whatever variants are\ngonna come next, right?\nYou combine these two\nthings. This makes up\nyour agentic layer, the\nold world of deterministic\ncode and the new\nworld of agentic prompts.\nThis is the agentic\nlayer. This is the\nlayer that can operate\non your codebase\nwith the highest leverage\npoint of Agentic Coding,\nthe AI developer workflow.\nAnd so we prioritize\nagentics because our agents\ncan ship better and\nfaster than us. Don't\nmake the mistake of\nthinking that you can\noutperform your team's best\nengineering practices encoded into\na template metaprompt that\nruns in an AI\ndeveloper workflow that kicks\noff five to ten\nagents per problem. You\nknow, like don't try\nto compete with that,\nright? Your place of\ncompetition is now net\nnew innovation. It's building\non the agentic layer.\nIt's using compute to\nsolve problems in an\ninteresting way. And this\nis all because you\ncan teach compute how\nto build. You can\nteach compute how to\nengineer your way. Okay.\nHere at the end\nof tactical Agentic Coding,\nlet's take this all\nthe way and compress\nour KPIs, our agentic\nconcepts, our leverage points\nand our tactics all\ninto a single question.\nThis leads us to\nthe final question, a\nfinal meta tactic, if\nyou will, that can\nguide you and direct\nyou on a daily\nbasis. Again, Tactical agentic\ncoding. Everything you've done\nhere, this entire course\nhas been designed to\nbe tactical. These are\npieces of information you\ncan think on a\ndaily basis to guide\nyou toward great agentic\ncoding and therefore agentic\nengineering. This is the\nlast question I have\nfor you. This is\nthe only thing you\nneed if you forget\neverything else. This is\nthe only question you\nneed to win that\ncan guide you. Okay,\nso right now on\na day-to-day basis when\nyou're working, ask yourself\nthis, am I working\non the agentic layer\nor am I working\nin the application layer?\nThat's it, okay? On\na day-to-day tactical level,\neven if you forget\nall eight tactics, this\nis all you need\nto think about. Am\nI working on the\nagentic layer or am\nI working on the\napplication layer? The majority\nof your time should\nbe spent, of course,\non the agentic layer.\nWhy is that? It's\nbecause you can teach\ncompute how to build.\nIt's because you can\nteach compute how to\nengineer your way. It's\nbecause you can scale\nyour compute beyond comprehension\ninside of the new\nagentic layer of your\ncodebase where you're\norchestrating intelligence. That's why.\nThis is why we\ndo it. Just like\nan engineer using AI\nwill outperform an engineer\nnot using AI, an\nengineer that is scaling\nup their codebase\nwith fleets of agents\nthat solve problem classes\ncompletely outperforms an engineer\nusing classical AI coding,\nclassical in-loop Agentic Coding,\nokay? You will not\nbe able to compete,\nokay? There is no\ncompeting with an agentic\nengineer. You must have\nfleets of agents operating\non your behalf to\ncompete with an agentic\nengineer. Now, the most\nimportant thing you can\ndo next after you\nfinish this course, this\nfinal lesson here in\nour last five, 10,\n30 minutes together here\nis invest in this\nlayer, prioritize agentics. On\nit solved the problem.\nNow I use this\nADW all the time\nthanks to you, right?\ngetting these wins, you\nrealize that there's nothing\nmore important to be\ninvesting in. You'll fully\nunderstand tactic eight, prioritize\nagentics, prioritize your agentic\nlayer. Of course, by\ninvesting in your agentic\nlayer, you're actually investing\nin your application layer,\nright? It's all about\nyour users, your product,\nand your company. This\nis a constant in\nthe sea of change.\nThis never changes, right?\nNever forget who this\nis all for. Customers,\nusers, team, company, you.\nThis all relies on\nyou being able to\ninvest in your agentic\nlayer. Do not make\nthe mistake of thinking\nyou're smarter than your\nbest engineering practices and\nyour best team's practices\ntemplated into your agentic\nlayer. Okay, don't make\nthat mistake. Okay, because\nif you're not wrong\ntoday, you will be\nwrong at some point.\nThese are massive mistakes\nthat will prevent you\nfrom becoming an agentic\nengineer. What is an\nAgentic Engineer? It's the\nirreplaceable engineer that builds\nthe system, that builds\nthe system. An agentic\nengineer operates on living\npieces of software that\nwork while they sleep.\nAnd so this is\nit. This is the\nframing. This is tactical\nAgentic Coding. You have\neverything you need to\nbecome an Agentic Engineer\nnow. All you have\nto do is answer\nthe question every day\nwhen you sit down\nto work. Am I\nworking on the agentic\nlayer or am I\nworking on the application\nlayer? If you're working\non the agentic layer,\nyou're likely moving in\nthe right direction. Command\nyour agentic layer to\nrun and control your\napplication layer. Okay, if\nyou're working on the\napplication layer, you must\nhave a good reason\nright, a deadline, right,\nor maybe you're testing\nsomething, right, maybe you're\nrunning some of your\nprompts in the loop\njust to make sure\nthat they'll work out\nthe loop, okay, or\nelse you're moving in\nthe wrong direction. You're\ngoing sideways while other\nengineers that have taken\ntactical Agentic that\nunderstand what's here and\nwhat's coming next, what\nopportunity is available to\nthem, they'll be moving\nup while you'll be\nmoving sideways, okay, full\nstop, bar none. What\nyou've done here in\ntactical Agentic is\nmuch deeper than you\nmight realize, what you\ncan now do is\nmuch deeper than you\nmight realize. We've described\nthe commoditization of implementation.\nAI coding is not\nenough. Coding has been\ncommoditized, but what we're\nseeing here, looking through\nthese examples, working through\nagentic layers, right, scaling\nup across the software\ndeveloper lifecycle, what you've\nseen here is the\ncommoditization of implementation and\nearly signs of the\ncommoditization of engineering, okay?\nAI coding is not\nenough. With Agentic Coding,\nnot only is code\na commodity, but the\nimplementation as well. This\nis only a net\nnegative if you show\nup late to the\nparty. You are here\nvery early. It might\nnot feel like it,\nbut you're here early.\nAllow me to help\nyou step out the\ntech bubble. You know,\nyou and I both\nlive in. You are\nearly, okay? You have\nthis information. The value\nof engineering is actively\nmoving up the stack\nto system design, system\narchitecture, encoding your domain\nexpertise for your agents,\nfor your product, for\nyour team, for your\ncompany, quality control, right?\nValidation review systems, and\nmost importantly, creative problem\ndecomposition, right? Which you'll\nthen encode in your\nADWs. This is bigger\nthan a course. This\nis a manifesto for\nthe next phase of\nsoftware engineering. This is\nthe guideline. This is\nthe framework. This is\nthe codex for agentic\nengineering. This is the\ngroundwork for a new\nrole of engineering, the\nAgentic Engineers, Agentic Engineering.\nYou want to be\none of the engineers\nthat internalizes this and\nbets on this reality\nnow. You don't want\nto fall behind. The\nAgentic Engineer builds the\nsystem that builds the\nsystem. Prioritize agentics. Thank\nyou so much for\ntrusting me. I have\nsomething to ask of\nyou. I am just\none man, one guy\nthat tries to push\nwhat he knows to\nthe edge over and\nover and over as\nmuch as possible. But\nno matter how much\nI push, no matter\nhow I optimize my\nday, my time, my\nschedule, my life, my\nprioritizable. So depending on\ndemand, depending on what\nyou choose there, I'll\nsteer in the direction\nthat accelerates the growth\nof as many cracked\nengineers like you as\npossible. So thank you\nthat and that'll be\navailable to you as\nyou finish this lesson.\nIt doesn't matter if\nyou know that the\nfuture is already here.\nWhat matters is that\nyou do something about\nit. You have to\nbe the one that\nruns toward the future\nwhile others walk away,\nrun away, stand still,\nor walk forward. You\nnow have everything you\nneed to win big\nin phase two of\nthe generative AI age,\nthe age of agents.\nYou only need to\ncatch one wave of\nchange everything and if\nyou do this right\nyou will change everything\nin this phase there\nare two things that\nmatter more than ever\nfocus and signal without\nthese misinformation hype trains\nand AI slop will\nlead you astray for\nvaluable information sources for\nengineering in today's world\nand tomorrow's make sure\nyou stay plugged in\nto the IndyDevDan\nYouTube channel I'm not\ngoing to stop until\nwe cannot build any\nlonger I'll be sharing\ncurrent generation ideas surrounding\ntactical Agentic Coding. I'm\ngoing to hold off\non a lot of\nthe core ideas from\nthe channel. I want\nto give you an\nedge and I want\nto give you a\ntime advantage, right? A\ntemporal advantage before I\nstart, you know, talking\nabout the details of\nthis course, talking about\nsome of the core\nconcepts and bringing them\nto light so that\nyou can have an\nedge here. I'll be\nsharing more about this\ncourse. I'll be sharing\nany potential updates. I'll\nbe sharing next potential\nbig ideas and whatever's\ncoming next. I'll be\nthere every Monday for\nyou and engineers and\nwill be focused on\nthe signal in all\nthe noise. I don't\nhave a ton of\nbandwidth. Nearly all my\ntime is consumed by\nmastering agentic technology, but\nthe time I do\nhave, I come to\nthe channel every Monday\nfor you and for\nengineers. to distribute the\ninsane potential of this\ntechnology. And every once\nin a while I\ncreate, you know, a\nfull on cohesive piece\nlike this Tactical Agentic\nCoding for you to\ngive you a large\nedge. Make sure to\nfollow the channel so\nyou don't miss what's\ncoming next. Generative AI\ntechnology is the most\npowerful technology of our\nlifetime. So this is\nthe message I wanna\nleave you with. Imagine\nyour future self looking\nback, feeling incredible, grateful,\nand happier than ever.\nWhy? It's because you've\nwon. You did it.\nYour product is successful.\nYour business is successful.\nYou achieved the status,\nthe respect, whatever you\nwere looking for, you\nfound it. You achieved\nyour engineering dreams. And\non that day in\nthe future, you sit\ndown, you start tinkering,\nright? You're building something\njust for the love\nof it, right? For\nno other reason other\nthan fun. You start\nreminiscing about this period\nin your life when\neverything started changing. And\nyou say this, when\nthe agents arrived, something\nchanged. We weren't just\nAI coding anymore. We\nstarted orchestrating intelligence. This\ncloses the loop on\nTactical Agentic Coding. In\na sea of noise,\nslop, thank you for\ntrusting me with your\ntime, with your engineering,\nwith your future, with\nyour career. I could\nnot have created this\ncourse. I could not\nhave created any of\nthese ideas. without executing\non them over and\nover and over and\nover, over years. So\nat the end of\nthis course here, I\nwant you to trust\nme one more time\nand put this information\nto use to change\nyour engineering forever. If\nyou do this right,\nit will change everything.\nPrioritize agentics. When the\nagents arrived, something changed.\nWe weren't just AI\ncoding anymore. We started\norchestrating Intelligence.",
  "summary": "The final lesson introduces the meta-tactic that rules them all: Focus on The Agentic Layer. Imagine a ring around your codebase that grows thicker as you scale agentics - this is the agentic layer where machines operate with your judgment. The lesson emphasizes that more than half your time should be spent on the agentic layer, not the application layer. Key insight: you can teach compute how to build YOUR way and scale it beyond comprehension. The tactics are not bound to any specific workflow - they are composable building blocks. The course concludes with the hierarchy: Prompts compose into Specs/Templates, which compose into ADWs (AI Developer Workflows). An engineer scaling fleets of agents completely outperforms classical AI coding or in-loop agentic coding.",
  "key_concepts": "1. THE AGENTIC LAYER: The meta-tactic to rule them all. Imagine a ring around your codebase that grows thicker as you scale agentics. This is where machines operate with your judgment.\n\n2. AGENTIC LAYER VS APPLICATION LAYER: Two distinct layers. Application layer includes DevOps, infrastructure, database, and raw application code. More than half your time should be on the agentic layer.\n\n3. TEACH COMPUTE HOW TO BUILD: You can teach compute how to engineer YOUR way and scale it beyond comprehension. This is why the agentic layer matters.\n\n4. COMPOSABLE BUILDING BLOCKS: The eight tactics are not bound to any specific workflow. They are building blocks to compose repeatable solutions for your agents.\n\n5. THE HIERARCHY: Prompts compose into Specs and Templates, which compose into ADWs (AI Developer Workflows). Focus on these primitives that make up the whole.\n\n6. FLEETS OF AGENTS: An engineer scaling fleets of agents that solve problem classes completely outperforms classical AI coding or in-loop agentic coding. There is no competing with an agentic engineer.\n\n7. BUILD THE SYSTEM THAT BUILDS THE SYSTEM: The agentic layer IS that system. It ships your way, gets work done autonomously, using your judgment encoded into templates and workflows.\n\n8. THE SINGLE IDEA: To become irreplaceable in phase 2 of the Generative AI age, focus on building and scaling your agentic layer. Everything else follows from this.\n\n9. UPFRONT INVESTMENT: When starting out, put significant upfront effort into building the agentic layer. This investment compounds as you scale agents into your codebase.\n\n10. ORCHESTRATING INTELLIGENCE: The agentic layer is where you orchestrate intelligence - composing prompts, templates, specs, and ADWs into autonomous systems that execute your engineering practices."
}