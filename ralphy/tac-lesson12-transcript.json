{
  "video_id": "multi-agent-orchestration-the-o-agent",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/multi-agent-orchestration-the-o-agent",
  "title": "Multi-Agent Orchestration: One Agent To Rule Them All",
  "channel": "Agentic Engineer",
  "duration": 3600,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T04:20:04.829Z",
  "transcript": "Engineers, Welcome to Agentic\nHorizon, Lesson 4. This\nlesson is going to\nchange the way you\nthink about agents. If\nyou like the way\nthings are, close this\ntab now. If you're\nready for the next\nstep, throw on your\nheadphones, cancel out the\nnoise, and let's focus.\nI'm very excited to\nbe here with you\nright now. We live\nin an incredible time\nof extraordinary opportunity. Our\npotential as engineers has\nnever been higher. With\nthe abundance of opportunity,\nthere's a ton of\nnoise, confusion, and the\nfear of change and\ninstability is always present.\nLet's silence the fear\nonce again by pushing\nwhat we can do\nforward and by understanding\nthe next opportunity available\nto us. There is\none mode of engineering\nthat matters above all\nnow, agentic engineering. Here,\nwe don't focus on\nthe application layer, we\nfocus on the agentic\nlayer. We build the\nsystem that builds the\nsystem. If you're watching\nthis, you've been scaling\nup your agentic engineering.\nYou've got better agents,\nyou're running more agents,\nand maybe you've built\ncustom agents specialized for\nyour domain-specific problems. But\nif you haven't yet,\nyou will hit a\nwall. There are hard\nlimits on the current\ninterface of agents. You\ncan't scale by hopping\ninto one terminal at\na time, writing one\nprompt at a time.\nAs a tactical agentic\ncoding member, you know\nthe solution to this.\nBuild a layer of\nagents around your code\nbase with repeatable workflows\nusing AI developer workflows\nand leverage points of\nagentic coding. But as\npowerful as this is,\nthere's an upfront investment\nwe need to all\npay down to build\nthis layer. So what\nif we had an\nintermediate step, a system\nof agents that helps\nus build before we\nhave an agentic layer\nand while we have\nan agentic layer? Because\nat scale, if you\nlose track of your\nagents, you lose control\nof your results in\nthe generative AI age,\nthe rate at which\nyou can create and\ncommand your agents becomes\nthe constraint of your\nengineering output. When your\nagents are slow, you're\nslow. When your agents\nhave a problem, you\nhave a problem. If\nyou're using agents at\nscale, you know exactly\nwhat I mean. Right\nnow, every engineer sits\nat one of these\nlevels. Base agents, better\nagents, more agents, and\ncustom agents. The theme\nhere is simple. At\neach step, you scale\nyour compute to scale\nyour impact. When you\ncombine this with your\nagentic coding KPIs, you\nunderstand where you are\non the agentic engineering\nproficiency curve. It's not\nabout what you can\ndo anymore it's about\nwhere you can teach\nyour agents to do\nfor you there's one\nmore level one giant\nleap forward I'm going\nto share with you\nin this lesson Engineers\nlike you and I\nusing agents every single\nday, we're all thinking\nabout the same thing\nand the votes for\nagentic horizon show it.\nIn order to scale\nyour agents, you need\nto manage your fleets\nof agents. Multi-agent orchestration\nis the next step\nin our journey as\nagentic engineers. So let\nme introduce you to\none powerful multi-agent orchestration\nsolution. The one agent\nrule them all. The\nOrchestrator Agent. This is\nthe single interface pattern\napplied to your fleet\nof agents. It's an\nexisting engineering paradigm that\ngreat engineers have used\nfor decades. We're applying\nthe single interface pattern\nto agents. But it's\nnot just the Orchestrator\nAgent that matters. We're\ncombining three pillars. The\nOrchestrator Agent, your unified\ninterface to your agents.\nYour Orchestrator Agent unlocks\nCRUD for your agents.\nThis gives you agents\nat scale. And lastly,\nwe're combining observability for\nreal-time monitoring of your\nagent's performance costs, and\nas you'll see, results.\nWhen you combine these\nthree, you get a\npowerful solution to multi-agent\norchestration. This is you\ncontrolling your compute at\nscale. Welcome to Agenta\nHorizon Lesson 4. Let's\nunderstand the one agent\nto rule them all,\nthe OA. Where is\nour input field? This\nis not a normal\napplication for normal users.\nThis is for you\nand I, the agentic\nengineer. We're maximizing information\ndensity without losing UX\nquality. If we have\ncommand K here, we'll\nsee our prompt input\ninterface. It has useful\nmetadata about the capabilities\nof this codebase\nwe'll cover in a\nmoment. We'll just start\nwith a simple ping\nprompt. Our orchestrator agent\nis going to of\ncourse give us a\nquick response. Now let's\nspin up some agents.\nHere we're gonna create\nthree individual agents. We're\ngonna have them summarize\nthe codebase, build\nan application structure summary\ninside of a markdown\nfile with mermaid tables.\nWe're gonna fire this\noff and truly show\noff the potential and\nthe capability of an\norchestrator agent. Now our\norchestrator agent is going\nto craft three new\nagents, and then prompt\nthem. So we're going\nto have a total\nof six unique tool\ncalls built around managing\nand orchestrating agents. You\ncan see here, here's\nour first agent, here's\nour second agent, and\nour orchestrator agent is\ngonna spin up our\nthird agent right now,\nour QA agent that's\ngonna do both the\nfront end and the\nback end summarization work.\nThere's our QA agent,\nand you can see\nright away, this is\na differentiated agentic coding\nexperience with multi-agent observability,\nyou can see everything.\nObservability is a key\ncomponent of a successful\nmulti-agent system. Why is\nthat? It's because if\nyou can't measure it,\nyou can't improve it.\nAnd if you can't\nmeasure it, you can't\nscale it, okay? If\nyou have 10 agents\ndoing the wrong thing,\ndoes it matter that\nyou have 10? Of\ncourse not. This is\nwhy observability is key\nand it's also why\nthe orchestrator is an\nadvanced agent decoding concept.\nIt comes last after\ncustom agents. You can\nsee here we have\nan interface that is\ncommunicating the work of\nevery one of our\nagents. So we have\nresponses, we have tools,\nwe have thinking. We\ncan, of course, filter\non any one of\nthese. We can filter\non responses, individual tool\ncalls. We can filter\non our individual agents.\nSo here's just our\nQA agent. The observability\nhere is essential for\nscaling impact. with a\nsingle prompt, I've deployed\nthree times the compute\nan engineer working in\nthe terminal has, okay?\nAnd this is just\nthe beginning. We have\ntwo fast agents. We've\ndivided this work into\nfront end, back end,\nand then we have\na primary kind of\npowerful agent that's going\nto do the QA\nwork of summarizing both\nthe front end and\nback end. And our\norchestrator took care of\nactually commanding and creating\nour agents. If we\nscroll back up, you\ncan see all six\nof those tool calls,\ncreate agent, create agent,\ncreate agent, and then\nthree command calls. Already,\nwe have this very\ninteresting pattern of our\norchestrator agent taking our\nhigh-level prompt and then\nwriting out in much\nmore detail the actual\nconcrete work that we\nwant done to our\nagents. Already, this is\na differentiated experience. I\nknow right away some\nengineers are gonna think,\naren't these just sub-agents?\nWhy aren't you just\nusing sub-agents? Having a\nprimary agent here connected\nto your orchestrator agent\nis differentiated. You're gonna\nsee this over and\nover and over. We\ncan do a lot\nmore when we control\nour agentic units with\nour orchestrator agent. So\nsome of our fast\nagents here running Haiku,\nthey're of course going\nto get work done\nquite a bit faster\nand when they complete\ntheir work, you're going\nto see something very,\nvery powerful. And you'll\nnotice throughout all of\nthis, our orchestrator agent\nhas stopped doing work,\nright? Its orchestration tasks\nfor the meantime is\ncompleted. It has created\nand commanded our agents.\nNow our agents are\ndoing the work. And\nif we dial into\nthe individual agent user\ninterface here, you can\nsee a couple of\nkey, key things. We\nhave the name, we\nhave the status, we\nhave of course the\ncontext windows. We're managing\nthe core four of\nevery single agent we\nspin up. If you\ndo not adopt your\nagent's perspective, if you\ndo not know what\nthey can do, you\ndo not know what\nyou can do. We\nhave our response messages,\nwe have tool calls\nand we have hooks.\nAnd of course we\nhave reasoning. You can\nsee here, none of\nour agents here are\nthinking they're not reasoning\nat all. That's okay\nfor these tasks. We\nof course have our\nmodels and our costs.\nNow, something incredible just\nhappened. As you can\nsee here, our primary\nQA agent has finished\nits work. We have\nits consumed assets, and\nit's produced assets. Engineering\nis all about communicating\nwork. So your multi-agent\nsystem should reflect that.\nIt should showcase that.\nAnd so right here\nin a single response\nmessage, you can see\nthe actual read files\nand the produced files\nfrom our QA agent\nat a glance. We\ncan do something really\npowerful. We can of\ncourse just see the\ndiff right here in\nline, but more importantly,\nwe can one click\ninto our editor. So\nnow we're operating inside\nthe loop. We're looking\nat this file. We're\nactually reviewing and understanding\nwhat's been done in\nmarkdown mode here. We\ncan see exactly what\nour agent has broken\ndown for us. And\nthis is a great\nopportunity to actually talk\nabout the codebase\narchitecture. And to be\ncompletely clear here, our\nmulti-agent application here, our\nagents, our Oracle Shure\nagent, this codebase\nis pointed back at\nitself. Okay, so the\nworking directory is the\nmulti-agent orchestration system, right?\nWe are using the\nsystem to build the\nsystem quite literally. Let's\ngo ahead and understand\nwhat this is and\nhow this looks, okay?\nSo you can see\nhere, four key components.\nAnd we asked for\nconcrete mermaid diagrams. We\nhave our front end\nlayer of a pina\nstore, We have our\nservices, all right? So\nwe're running HTTP and\nwe're running WebSocket. So\nwe're using both of\nthese to connect to\nour backend. In our\norchestrator service, we are\nof course using the\nClaude Agent SDK. Claude\ncode is the best\nagentic coding tool. It's\nnot just the agent\nor the agent harness\nthat makes this tool\ngreat. It is the\nextensibility of this tool.\nWe can build up\npowerful multi-agent orchestration systems\nlike this, thanks to\nhow pluggable the Cloud\nCode ecosystem is. So\nwe have our AI\npieces here. The most\nimportant thing here is\nthat we have separated\nour orchestrator agent from\nour command level agents.\nAll right, we also\nhave, this is super\nimportant as well, we\nhave a data layer.\nEverything we're doing here\nis operating and firing\ninto a Postgres database\nwith concrete structure. Why\nis that? Why haven't\nmade that architectural decision?\nIt's because this system\nis in fact an\nOutloop Peter system. We\nare observing work from\nour agents outside the\nloop we are quickly\noperating, right? You saw\nthat. This is quite\nliterally a prompt input.\nWe then have our\ntrigger, which is our\nHTTP requests coming into\nour server. And then\nwe have our full\non environment. In this\ncase, it's just running\nright on my local\nenvironment. And of course,\nwe have multi-agent observability\nto manage the result\nof our Peter framework.\nRemember tactic four, stay\nout the loop. You\nshould be compounding your\nengineering with each leverage\npoint of agenda coding\nthat you add to\nyour codebase and\nthen you build a\nsystem or you find\none that lets you\nsolve problems as you\ncontinue to move from\nin loop to out\nloop. There are so\nmany problems that you\ndo not need to\nbe sitting in the\nterminal prompting back and\nforth to solve. All\nright, keep in mind\na specialized tool like\nthis is going to\nbe more powerful than\nsome out of the\nbox cloud-based tool. Why\nis that? It's because\nthese tools are designed\nfor everyone's codebase,\nnot yours. When you\nbuild something like this,\nyou get specialization all\nthe way down. It's\nsuper important to note,\nI have this deployed\nfor several codebases\nI can access anywhere,\nanytime, through multiple devices.\nAnd it's all because\nit's designed as an\nOutloop system. This is\na critical component of\nthe system to mention,\nall right? So we\nhave a bunch of\nadditional documentation here. You\ncan see this agent\ndid a really great\njob of summarizing everything\ngoing on. There's the\ntable structure, and this\nis all gonna be\nhere for you to\ncheck out once you\nfinish this video. I'm\ngonna go ahead and\nclean up some of\nthis documentation. And if\nwe hop back to\nour agentic system, you\ncan see our front\nend and back end\nagents have also completed\ntheir work. We can\nsee all the files\nthey've consumed, we can\nsee the actual concrete\nproduced results. Okay. You're\nnot getting this with\nout of the box\nagent decoding tools. You're\nnot getting this with\nany cloud tool, right?\nThis is a specialized\nsolution for managing agents\nat scale. This is\nmulti-agent orchestration. So we\nthat we've designed it\nto be a, this\nis super important, we're\ngonna touch on this\nin a moment, we've\ndesigned it to be\na custom agent special\nspecialized at solving the\nproblem of managing other\nagents. And to do\nthat, we have, of\ncourse, adopted our agent's\nperspective. It is not\nalways observing the logs.\nIt cannot be. We\nhave to protect its\ncontext window. This is\ntrue for your O\nagent. This is true\nfor your primary agents.\nYou always need to\nbe monitoring and understanding\nthe core four of\nevery agent you boot\nup. Remember, on top\nof every feature, any\nlab builds, any UI\nthat you see, any\nexperience, it's all just\nthe core four. Don't\nlet anyone confuse you,\nokay? Context, model, prompt,\ntools. Do you know\nwhat these four leverage\npoints are at every\ncritical moment? All right,\nthis is key. As\nyou can see here\nthrough our interface, We\nhave a really great\nidea of the state\nof the core four\nfor all of our\nagents. Okay. And so\nyou can see here\nthe orchestrator agent, you\nknow, ran some specialized\ntools to actually check\nthe status of every\nagent. Check this out,\nright? Agent name. And\nwe're going to expand\nthis a little bit\nhere. Agent name. tail,\nagent name, tail. It\nis actually looking at\nthe response logs here\nand then it's communicating\nto us, all right?\nSo this single interface\npattern is very important\nhere for orchestrating agents\nat scale. We're protecting\ncontext windows, We have\nspecialized, dedicated, focused agents,\nright, focused on one\nspecific task. This is\nimportant. We're gonna touch\non that in a\nmoment. And then our\norchestrator agent is communicating\nto us, okay? We\ncan continue our work.\nThis is the powerful\npart of having a\nsystem like this, okay?\nbuild anything we need\nto to get the\njob done. So you\ncan see here, we\nhave a bunch of\nmetadata. We'll cover that\nin just a moment.\nLet's just run this.\nI'll say command all\nagents, create one section,\na single sentence of\neach key node in\nthe system. Quick, concise,\nenable thinking. All right,\nso let's get thinking\nmode turned on here\nand we'll go ahead\nand fire that off.\nSo once again here,\nthe pattern is the\nsame. We are talking\njust to our orchestrator\nand then our orchestrator\nis running the multi-agent\nprompts. Okay, so there\nit goes, prompt one,\nprompt two, prompt three,\nand you can see\nthat key, ultra thinking\nkeyword in our individual\nagents. We have the\nbrain icon here, and\nnow they're starting to\nactually think through what's\ngoing on here. This\nshould be just a\nquick summary. They're gonna\nmake a quick change\nto the top of\ntheir file. These aren't\njust one-off sub-agents where\nthe context is blown\naway or we have\nto kind of manage\nwhat or where the\nsub-agent was. These are\nprimary agents that we\ncan tap into over\nand over until that\nspecific job is done,\nokay? Something that's gonna\nhappen here, it's gonna\nbe really important. Here\nare our results. Once\nagain, we can just\ndial into these. We\ncan see all the\nconsumed files versus produced\nfiles. This differentiation is\nvery important. We can\ncontinue to run them\nuntil the job is\ndone. It's important that\nour orchestrator agent can\ntap into each agent\nwhen it needs to\ncommand them, read from\nthem. But again, we\ndon't want our orchestrator\nagent getting involved in\nthe actual work. It\nis just here to\norchestrate. This is our\nsingle interface into multi-agent\norchestration. Let's look at\nour front end summary.\nSo if we just\nclick into this, we\nshould see a front\nend key nodes. So\ncheck this out. We\nhave our key components.\nWe have our composables,\nwe have our services,\nand we have our\ncore files. So this\nis great, right? We\ngot a key summary\nhere. You can see\nall the key technologies\nwe used for the\nfront end. And this\nwas a great summary\nwritten up by our\nfast front end keyway\nagent. So this is\nfantastic. We can hop\nin the loop when\nwe need to, when\nwe understand what's done,\nwe're back out the\nloop. We are constantly\nmoving from in loop\nto out loop and\nthe multi-agent orchestration with\nthe O agent helps\nus reduce our presence,\nit helps us understand\nwhat our agents are\ndoing, and it helps\nus scale our agents.\nNow that the job\nis done, whatever work\nyou needed your agent\nto complete, it's finished,\nokay? Now we can\ndo something very powerful.\nThere's a journey that\nevery engineer goes through.\nFirst, you learn how\nto read code, then\nyou create code, then\nyou update code, and\nthen in the end,\nyou learn that the\nbest code is no\ncode at all. You\nlearn to delete. Command\nK, delete all agents.\nAgentic engineering is no\ndifferent. You must treat\nyour agents as deleteable\ntemporary resources that serve\ntheir context window, okay?\nFocusing your agent on\none task sidesteps all\nof these context issues,\nokay? Context rot, context\npollution, toxic context, whatever\nyou want to call\nit. You want your\nagents to be just\nlike you, a focus\nengineer working on a\nsingle task at a\ntime. Let your agents\nfocus, all right? And\nmulti-agent orchestration with our\nO agent lets us\ndo just that. What\nare we doing here?\nWe're tapping into the\nR and D framework.\nWe discussed this inside\nof the Elite Context\nEngineering Agentic Horizon lesson.\nWe are reducing and\ndelegating context to the\nmax, okay? By the\nway, if you haven't\ncompleted Tactical Agentic Coding\nand the previous Agentic\nCorizon lessons, stop this\nvideo, go watch those.\nAll of this will\nmake a lot more\nsense. We are compounding\nour engineering with tactics\nof agentic coding and\npowerful patterns over and\nover and over. Okay,\nevery single lesson matters.\nEvery single lesson was\ndesigned to have a\ncritical idea, a critical\ntactic to push what\nyou can do further.\nYou know, let me\nbe clear, I'm super\nexcited for larger effective\ncontext windows, but 200K\ncontext window is plenty.\nYou're just stuffing a\nsingle agent with too\nmuch work, just like\nyour boss did to\nyou at your last\njob. Okay. Don't force\nyour agent to context\nswitch. You know what\nthat feels like. Force\nit to focus and\nthen let it go\nhome back to the\ndata center. Delete it.\nSo very powerful stuff,\nright? We're gonna clear\nour logs here. Our\norchestrator agent is just\nready and waiting. It\nhas no agents in\nthe bank, but it\ncan create them on\nthe fly when we\nneed them to solve\nwork at scale quickly,\nokay? We're not opening\nup the terminal. We're\nnot setting anything up.\nOur orchestrator is doing\nall of that for\nus. We're just talking\nto the O agent.\nThis is a powerful\nmulti-agent orchestration pattern. Okay,\nso how does this\nwork? Let's just take\na step back. and\ntalk high level, how\ndoes this actually work?\nLet me be super\nclear about something. The\norchestrator agent is a\ncustom agent, okay? Its\nsystem prompt is completely\noverwritten. Its tools are\nspecialized. It's designed to\nmanage other agents. Using\nthe single interface pattern,\nyou talk to your\norchestrator agent and it\ncreates, deletes, and updates\nand manages your agents,\nokay? In fact, we\ncan push this even\nfurther, which we're going\nto do in a\nfuture agentic horizon lesson,\nit can manage your\nentire agentic layer. It\ncan call your ADWs,\nit can call your\nprompts, it can call\nyour agents, it can\ndo it all. This\nis why this is\nthe next level in\nthe agent scale framework.\nBase, better, more, custom\norchestrator. This is agentic\nengineering scale to the\nnext level. So what\nelse can we do\nwith this? This system\nleans on a powerful\nagentic framework. The incredible\npart about this system\nis that it is\ninteroperable with the entire\nClaude Code ecosystem. What\ndo I mean by\nthat exactly? If we\nhit control K, once\nagain, you can see\nall of this metadata\nwe're going to break\ndown one step at\na time. But right\nnow let's just do\nsomething simple. Create an\nagent to run slash\nquestion and ask if\nour orchestrator and agents\ncan use skills. Okay.\nWe're gonna ask a\nquestion. The orchestrator agent\ndoesn't do work outside\nof what it's specialized\nto do, which is\nconduct and orchestrate other\nagents. All right. So\nwe have our code-based\nquestionnaire agent that just\ngot spun up. It\nlooks like our orchestrator\ndecided this is a\nsimple task. So it's\njust gonna run a\nfast model to do\nthis. And she's gonna\nunderstand running the question\nprompt, let's focus in\non that, right? What\njust happened there? We\nwere actually having our\nagent run a slash\ncommand, a custom slash\ncommand, also just known\nas a reusable prompt,\nokay? Just by me\nsaying that, a whole\nworld of possibilities should\nbe activating in your\nmind. We have access\nto the entire cloud\ncode ecosystem here. We\nhave access to reusable\nunits of compute. we\nhave access to the\nleverage points of agenda\ncoding. We can tap\ninto reusable prompts and\nwe've taught our orchestrator\nagent. Once again, we've\ntemplated our engineering into\nour orchestrator agent so\nthat it knows how\nto run custom slash\ncommands for our other\nagents, all right? Super\npowerful, it's done already.\nIt's found the answer,\nright? 20K context, one\ncent, we have the\nanswer here. The answer\nis yes, orchestrator and\nagents can use skills.\nIt's telling us where\nyou can even see\nit's consumed files, where\nand how they figure\nthat out. Fantastic, right?\nWe are directly tapping\ninto a great agent\nhere, just a simple\nprime command. We're setting\nthings up, read some\nessential files, or you\ncan set up more\nmore important, more specific\nprime commands like this,\nright? Where you're specializing\nthe files, okay? Hopping\nback outside the loop\nhere, your agent can\njust run these, right?\nBoth the orchestrator and\nof course our primary\nagents, right? And our\nagent bank. And so\nyou can see there,\nit's just reading these\nfiles. You're not going\nto always want to\ndo this, but a\nprime command is of\ncourse gonna be useful\nfor your orchestrator agent\nto give it a\nhigh level understanding of\nthe codebase. But\nyou can see here,\nthe risk of course\nis we are loading\nup the context of\nour orchestrator agent. You\nwant to keep your\norchestrator focused on conducting\ncommanding other agents. Still,\nit's super important to\nmention we're using the\npowerful suite of tools\nthat allow us to\nuse agents in an\nextensible way. Okay. Using\nan agent in the\nloop is just the\nbeginning of what you\ncan do. Don't let\nthese other agent decoding\ntools fool you. Cloud\ncode and the agent\nIt's insanely high. We\nhave custom agents, built\nfor specific purposes, built\nfor specific use cases.\nWe can deploy at\nscale over and over\nand over. When their\njob is done, guess\nwhat we're gonna do?\nDelete the agent. Okay,\nthat's it. Right? This\nis the pattern. This\nis the loop. Okay?\nWe build agents to\ndo specific work. Once\nit's done, they're gone.\nThey're dust. Okay? Clear\nall. Now we're ready\nfor the next task.\nAll right? Scale, scale,\nscale, observability, orchestration. It's\nall here. This is\nthe next level of\nagentic engineering. We start\nat base, we add\nbetter, we add more,\nwe customize them, and\nthen we orchestrate all\nof them. Okay, I\ndon't care what user\ninterface you use. Of\ncourse, I'm gonna make\nthis available to you,\nbut the idea is\nthe same. We need\nmulti-agent orchestration, and the\norchestrator agent is one\nway for you to\naccomplish that task, all\nright? There is a\nfeeling you're gonna get\nonce you get this\nup and running, once\nyou start using this,\nthat is differentiated. I've\ncome back to this\npattern. I explore these\npatterns all the time,\nright? But I'm here\nsharing this with you\nbecause this experience, this\nDX, this developer experience\nis differentiated. Something is\ndifferent about this combination\nof UI, of UX,\nof agent understanding and\nagent communication. It's all\nabout the flow of\ninformation between your agents\nand understanding how you\ncan peer into the\ncore four to get\nmore, better, faster results.\nWe used a sub-agent\ntemplate to build a\nnew primary agent with\ndedicated settings. We specialized\nthe agent. Let me\njust go ahead and\nopen this up again.\nAnd I just wanna\nmention one big idea\nhere. If we just\ncollapse, course, prompt engineering\nis the skill, context\nengineering is the skill\ninside of this agent\nyou know, in the\nsystem prompt of this\nagent, we have once\nagain, templated our engineering.\nWe have a dedicated\nscout report, a dedicated\nstructure that we want\nour agent to report\nits results in, okay?\nTemplating your engineering inside\nof all these different\ntypes of compute, right?\nSub-agents, skills, prompts, reusable\nprompts. It's all about\nencoding the way you\nengineer, encoding the way\nyou solve problems. There's\na key theme of\nTactical Agentic Coding. You\nneed to be putting\nyour engineering into your\nagents. This is what\nmakes them special. This\nis what gives them\nyour unique advantage. Something\nkind of interesting to\ncall out here is\nif you can do\nthis work, if you\ncan do your job\nwith an out-of-the-box agentic\ncoding tool or an\nout-of-the-box cloud tool, how\ndefensible is your product\nreally? How defensible is\nyour work really? If\nit's just one, two,\nthree, four prompts away\nwith zero effort, all\nright? This is why\nspecialization, solving your problems\nvery well is very\nimportant. Inside of my\ncode basis where I'm\ndeploying this, I have\nso many specialized prompts\nand agents and tools,\nright? Additional tools for\nmy orchestrator to help\nthem run my domain\nspecific system better than\nanyone else can. Okay,\nthis is the key.\nThis is your differentiating\npoint, all right? This\nis another advantage I\nwanna concretely communicate to\nyou here. You always\nwanna be templating your\nengineering and understanding what\nthe core four is\nwith every agent you\nspin up throughout your\nprompts, throughout your system\nprompts, throughout your ADWs,\nthroughout your chains of\nis going to get\nto work here after\nour orchestrator kicks it\noff. There we go.\nAnd you can see\nhere again, we're using\ncustom agents, okay? Specialized\ncustom agents at scale.\nWe can spin them\nup and spin them\ndown with a single\nprompt, okay? So there\nit is. We're using\nour scout reports just\nfast and then we're\nusing a build agent,\nokay? Of course, you\ncan guess what that\ndoes. It's focused on\nactually making the code\nchanges and making them\nwell, okay? powerful example\nof multi-Asian orchestration. We\nhave agents doing work,\ncreating useful information sets,\nand they're going to\npass that off to\nthe next agent. Okay.\nSo we're talking plans,\nwe're talking logs, we're\ntalking results, we're talking\ndocumentation, and then our\norchestrator chains it all\ntogether. Look at what\nour orchestrator is doing\nhere. It is actually\ninvolved in this process.\nOkay. So our orchestrator\nis in a loop\nsleeping. You've probably seen\nthis pattern. Your primary\nagent will sleep, fire\noff some other agents\nto do some work,\nand then it'll check\nin on that. Right.\nSo this is a,\ncommon agent decoding pattern\nyou can use. And\nwe're doing it with\nour orchestrator agents. So\nwe're getting our orchestrator\ninvolved here. We're scaling\nup the compute to\nmonitor this multi-agent workflow.\nAnd so every 15\nseconds is going to\nrun check agent status\non the scatter to\nsee how the scatter\nis doing. And so\nyou can see there\nscatter has just finished\nthis work. We're not\ngoing to get our\nproduced assets, right? Every\nagent must produce a\nconcrete result. Otherwise, what's\nthe point? We can\nof course dial in,\nwe can see the\nsummary there and it\nknows exactly where to\nput these exact files.\nOf course, we can\none click in, we\ncan understand what's gonna\nhappen. The main thing\nhere is that the\napp header is gonna\nhave a couple items\nupdated, right? Problem statement,\nexecution summary, blah, blah,\nblah, all right? Classic\nagent decoding. Now our\norchestrator agent, still with\nvery minimal context. Keep\nin mind how much\nwork this orchestrator has\nconducted up to this\npoint, okay? And this\ncontext still floating along,\nit's because we are\nindeed all of the\ncontext, reduced, and delegated.\nWe have multi primary\nagents operating the actual\nwork. Now our orchestrator\nhas handed the work\noff to our builder\nagent. Okay, very powerful\nstuff there. There's another\ncommand agent tool and\nyou can see, check\nout this write up.\ncheck out this detailed\nwrite up our orchestrator\ngave to our builder.\nOkay. It is doing\nsome serious prompt engineering.\nYou can see the\nwork coming in there.\nKeep in mind, these\nagents are operating on\nthis project. They're operating\non themselves. Builder being\nvery precise because we\nhad a scouter look\nfor the changes to\nmake. Obviously relatively simple\nUI change, but we're\nputting a team of\nagents to make sure\nthe job gets done.\nIf you can deploy\na little bit more\ncompute, to have more\nconfidence and more trust\nin your agents, why\nwouldn't you, right? Compute\ncan solve so many\nof your engineering problems\nif you put the\ncompute to work. Okay,\nso here we are,\nbuilder here doing some\nthinking, right? We can\njust dial in on\nall the thinking of\nour agent here if\nwe want to. And\nof course we can\njust specialize on just\nour builder agent logs\nhere. If you just\nwanna see the individual\ntools, we can see\nthat as well. But\nwhat we really care\nabout most of all\nis the results. Our\norchestrator thinking one more\ntime, still executing, doing\nverification work, looks great.\nChanges are in place.\nIt's gonna check the\nsyntax for us. All\nthis is happening for\nus with our multi-agent\norchestration system, all driven\nby our orchestration agent.\nWe have put together\nthree critical pieces to\nunlock the next scale\nof agentic engineering. We\nhave an orchestrator, we\nhave CRUD for agents,\nso we can unlock\nagents at scale, and\nwe have observability. These\njust wanna show you\nmaximum potential. I'm gonna\nshow you what you\ncan really do if\nyou invest in the\nagentic layer, right? Make\nno mistake, the multi-agent\norchestration, your O-agent, it\nis a part of\nyour agentic layer. In\nfact, it is the\nkey to unlocking how\nto best organize, create,\nand use your agentic\nlayer. We don't have\ntime for that here,\nbut we are going\nto be diving into\nscaling multi-agent orchestration and\nconnecting it to your\nAI developer workflows and\nyour agentic layer, all\nright? The big advantage\nhere with the O\nagent is that you\ncan use this long\nbefore you have an\nagentic layer, which is\nreally important when you're\nfirst using this pattern,\nwhen you're first using\nthese ideas. Okay. So\nthere's a summary, right?\nOur orchestrator agent just\ncontinued in that agentic\nloop, checking the progress.\nWe have a live\nfeed going into our\ndatabase. We can just\ntap into with a\ncustom tool that our\norchestrator agent can use.\nAnd here we have\nconcrete results. We can\nof course blow this\nup a little bit\nto see this a\nlittle better. Obviously the\nwork is done. We\nhave the pills there.\nOkay. So let's deploy\none more task and\nthen let's talk about\noperating in the gray.\nLet's talk about the\nrealism around these types\nof systems. I want\nto talk off, limitations,\nwhat's missing, and then\nwe'll talk about what's\nnext for Agentic Horizon\nand what opportunity is\navailable for your Agentic\nEngineering. Once again, the\nagents are done, clear\nall agents. And then\nwe're gonna fire off\nanother workflow pushing the\ncompute even further. Let's\ngo ahead and clear\nall here. Our orchestrator\nis going to clean\nup these agents for\nus. There we go.\nCommand K, paste. This\nis the last prompt\nI'm gonna showcase to\nyou. Here we're gonna\ndo something a little\nmore complex, some more\nUI changes. We want\nour agent list to\ncollapse and we wanna\nupdate our orchestrator chat\nto go into small\nmode when browser width\nis less than 650.\nWe'll just be super\nclear here and say\nless than. Okay, we're\ngonna kick this off.\nAnd this is of\ncourse going to fire\noff an agentic prompt\ndesigned for our orchestrator.\nThis is something that\na lot of engineers\ndon't realize. Once you\nbuild a custom agent,\nyou can then write\nprompts, specialize for that\ncustom agent. Okay, detailed\nfor that custom agent.\nThis gets ultra, ultra\npowerful. There's a lot\nyou can do with\nthis, all right? This\nagent is gonna kick\noff. It's going to\ncreate a bunch of\nagents for us. It's\ngoing to deploy compute.\nIt's gonna handle this\nproblem for us, all\nright? So let me\nshowcase that prompt. And\nthis is the big\nadvantage you get when\nyou start specializing your\nagents. You can build\ncustom prompts that only\nthey can run. And\nthis should sound familiar\nand very in line\nwith all the ideas\nwe've been discussing. You\nget domain-specific expert agency.\nthrough prompts. Here's how\nthis workflow works. We\nhave plan with scouts,\nbuild and review. So\na three step workflow,\nTactical Agentic Coding members.\nThis should make you\nthink of something very\nsimilar. It should make\nyou think of the\nADW. Okay. We have\na multi-phase step plan\nhere, three phases with\na final report. And\nof course we have\na report section. We\nhave great consistent agentic\nprompt engineering. You know,\nthese ideas, it's so\nimportant to just establish\nthese great patterns so\nthat you can get\nto work and get\nthings shipped. Set up,\nWe're gonna create all\nof our agents upfront.\nIf we hop back\ninto our tool here,\nwe can see that\nwe have all of\nour agents. Our planner\nis currently executing. It's\nputting together all the\ninformation that our next\nagents will need to\nactually accomplish this task.\nOkay, so we have\na team of agents\nbuilt to accomplish a\nspecific task, each with\ntheir own role. Our\norchestrator agent is of\ncourse in a thinking\nloop. There's our response\nUI plan, check that\nout. And you can\nimagine that in our\nplan prompt, Our agent\nknows how we like\nto plan. We've templated\nour engineering and our\nagent has access to\nthat. So if we\njust close this, you\ncan see there we\njust passed phase one.\nSo that was our\nplan phase. So next,\nour build agent is\ngoing to spin up\nhere and start getting\nto work. This is\na classic workflow. If\nyou're agentic coding, you\nunderstand what's happening here.\nThe big difference is\nwe have agents that\nwe've spun up out\nof nowhere with our\norchestrator agent, powerful primary\nagents that we can\noperate on, and then\nour work can be\npassed off to the\nnext agent, and then\nthe next, and then\nthe next. Look at\nthis, planning took 21,000\ntokens. This is a\nrelatively small codebase.\nIf this is larger,\n2X, 3X, 5X the\nsize, you can see\nthis going up. We\nare constantly solving the\ncontext management problem with\nmulti-agent orchestration. We have\na planner, we then\npass it off to\nour builder and then\nour builder is going\nsuperior to agent handoffs.\nIt's more superior to\na blind sub agents.\nWe have a primary\nagent here that has\nbeen given context. It\ncan reference other files.\nIt is less ephemeral.\nWe can reprompt. We\ncan run continuation prompts\nthrough our orchestrator agent,\nso on and so\nforth. Right? So let's\njust go ahead and\nfinish up checking out\nthis prompt, right? So\nwe have, our build\nand then we have\nour final, right? But\nif we just scroll\nback up to the\ntop here, right? We\nare running an orchestration\nprompt. So our high\nlevel agent is kicking\noff three agents and\nit itself, you know,\nthrough each one of\nthese steps has multiple\nphases. It's going to\nwork through, through each\nphase is going to\ncommand, it's going to\ncheck, and then it's\ngoing to report. Okay.\nAnd it's going to\ndo this through these\nsteps. And then we're\ngoing to have a\nfinal report. We have\na concrete, report format.\nWe want our agent\nto communicate to us\nin the way that\nwe would want to\nbe communicated with, with\nanother engineer. We want\nit to be concise,\ninformative, information rich, but\nalso we want to\nfocus on actually getting\nthe work done. And\nwith this workflow, we\ncan do that. And\nthen we can have\na reviewer agent come\nin at the end,\nreview the work so\nthat we know it's\ndone right. I'm not\nhere to try to\nsell you some, sell\nyou some product, right?\nYou're going to have\nthis codebase available\nto you. As soon\nas you finish this\nlesson, you can play\nwith this. You can\ntake it, play with\nit, get it all\nset up. This is\nrunning on a neon\ndatabase. So if you\njust create a neon\ndatabase or a local\nPostgres database with Docker,\nhowever you want to\ndo it, I'm not\nhere to tell you\nhow to set up\nyour multi-agent orchestration or\neven that you need\nto use this. Okay.\nWhat I want to\ndo here is communicate\nto you the next\nlevel of agentic engineering.\nIt is very clear,\nit's crystal clear that\nmulti-agent orchestration is a\nkey step in scaling\nyour compute to scale\nyour impact. It is\nvery likely you're gonna\nsee big AI labs\nbuild out something like\nthis, okay? You're already\nseeing some primitive versions\nof this with the\ncloud-based tool where you\nfire off one agent\nat a time, back\nand forth, back and\nforth. You know how\nthat goes, okay? You've\nseen that, we're gonna\nwatch this evolve. What\nI wanna do here\nis just communicate to\nyou the next paradigm\nof engineering so that\nif you want to,\nyou can get ahead,\nyou can push your\nengineering. And at the\nvery least, you can\ntake some of these\nideas and roll it\ninto your own work.\nEven without the orchestrator,\nwhen you're operating in\nthe loop with your\nbasic agent, your basic\ncodex, Claude Code, Gemini\nCLI, whatever agent you\nlike to use, you\ncan build out more\npowerful workflows than you\nthink you can. You\ncan command more compute\nto get more work\ndone. If you wanna\ntake this to the\nnext level, multi-agent orchestration\nis waiting for you.\nNow, there are of\ncourse trade-offs to this.\nThe real trade off\nhere, the real balance\nis that this takes\ntime to build, right?\nVery obviously multi-agent orchestration\nand the O-agent cost\nupfront investment and you\nhave to manage your\norchestration agent, you have\nto manage the plumbing,\nthe database, the WebSocket\nbe a great direction\nto go. I should\nbe able to just\nquickly start a new\nagent or reference previous\norchestration agents and their\nrelated agents so that\nwe can work on\nmultiple systems, multiple code\nbases throughout single interface\nwith a single UI.\nRight now, if we\nhop into the code\nhere, this server is\nactually pointed toward one\nspecific codebase at\na time. I think\nThis is a great\nplace to start, but\nwe can push this\nfurther. Something else that's\nmissing. If we want\nto fork an agent's\ncontext window and basically\nduplicate an agent from\na specific point, this\nis one tool away.\nAnd thanks to the\nCloud Agent SDK, it's\na few modules away\nfrom being built out.\nWe should be able\nto fork context windows\nand fork agents at\nany point in time.\nOne big piece here,\nand frankly, the highest\nreturn on investment is\ngonna be some really\nwell-built out autocomplete and\ntab functionality basically a\ndedicated language model, likely\na cheap, fast model\nto help out with\nprompt engineering right here\nin the terminal with\nauto completes for agents\nslash commands, templates, tools,\nso on and so\nforth, right? Just to\nhelp speed up agent\ndecoding even further. Okay,\nit looks like our\nbuilder has finished its\nwork. This is fantastic.\nYou can see again,\nall the work done\none click away, right?\nResult oriented engineering in\na single interface, right?\nOur Outlook system is\nvery, very powerful here.\nA lot of systems\nrely on pull requests.\nThat's great, but it\nmisses a lot of\nthe story. It misses\na lot of the\njourney, right? We get\nall of it here\nwith our observability interface.\nSo our agent's finished.\nLet's see how it's\ndone here. Fantastic. So\nyou can see that\nthat worked, right? If\nwe go into large\nmode here and let's\nshrink right around, at\naround 650, we should\nsee collapse. There it\nis. Nice. So you\ncan see our shortened\nwindows and then it\nsizes up and you\nknow, we can collapse\nthis and just see\nour collapse mode here,\nget a little bit\nmore space. That's what\nthat looks like. So\nthis feature shipped, we're\nnow having our reviewer\nagent confirm that the\nwork was done. So,\nI hope you can\nsee how powerful this\nis, right? Three agents,\ndedicated, 21K, 17K, focus\ncontext windows, one agent,\none prompt, one purpose,\nfocusing in on tactic\nsix, let your agent\nwork and then let\nit go home. Big\nlabs are going to\nbe doing something like\nthis, right? You already\nsee it. with cloud\ncoding tools, these are\ncoming, all right? And\nthere's gonna be many\nvarieties of this, right?\nThere's gonna be your\nVibe coding one-shot prompt\ntools, and then there's\ngonna be your legitimate\nengineering tools. Obviously, we're\ngonna lean super hard\non the legitimate software\nengineering out of the\nloop agentic coding tools\nlike this system, but\nthese are coming up.\nWe want to have\na spectrum of tools\nwe can use. More\nspecifically, we wanna have\na dedicated solution for\nsolving our domain specific\nproblems with our specialized\nagents. Okay, this is\nthe agentic engineering advantage.\nYou can build agents\nthat know your problem\nbetter than anyone. Okay,\nbetter than any cloud\ntool, better than any\nteam. is the advantage,\nokay? And you can\nscale it hard now\nwith the multi-agent orchestration\nand the orchestration agent,\nall right? Now, there's\na big missing piece\nhere, another kind of\nfinal missing piece. How\ndoes this plug into\ndeterministic code? How does\nthis plug, right now,\nthis is very agentic,\nright? We've dialed up\nthe autonomy knob here\nquite a bit, which\nis great, that is\nthe direction, but we\nalso have a missing\npiece of deterministic code.\nWe're missing our AI\ndeveloper workflows. Okay. This\nis the big missing\npiece. And this is\nsomething that we will\nbe building and I\nwill be showcasing in\nupcoming agentic horizon lessons.\nIt's going to fit\nin very well with\nthe voting. Thank you\nfor placing your votes.\nThat information has been\nreally great for guiding\nupcoming lessons. I think\nif I do another\nlarge heavy hitting course\nlike this, who knows\nif I will, but\nif I end up\ndoing another one, I\nwill definitely incorporate your\nyour word, your ideas\ninto upcoming lessons. I'll\nship some lessons and\nI'll let the ecosystem\nwe can quickly observe\neverything our agents can\ndo. And we are,\nof course, being results-oriented.\nEvery agent reports a\nconcrete result of what\nit just did. The\norchestrator agent is the\nfirst pattern where I\nfelt the perfect combination\nof observability, customizability, and\nagents at scale. In\nthis lesson we spun\nup many, many agents\nwith dedicated focus context\neffortlessly. Multi-agent orchestration is\nthe name of the\ngame for the next\nlevel of agentic engineering.\nIt's not perfect. There\nare issues, you know,\nin this codebase,\nin this entire methodology\nof operating. I fully\nadmit to that. There\nare trade-offs everywhere. There\nalways are. But it's\nclear this pattern is\nviable for scaling your\nagentic engineering. Give this\na shot. You can\nsee our reviewer just\ncame in with the\nreview. We can one-click\ninto the loop, understand\nwhat's been done, and\nthen we can get\nout of the loop,\ngo back to the\nhigh level. We can,\nof course, clean up\nour agents with a\nsingle command. We can\ncontrol it all and\nmanage our compute better\nfaster than ever before.\nGive this a shot.\nAnd if you see\nbig AI labs picking\nthis concept up, remember\nwhere you saw this\nfirst. Great work here.\nI hope the gears\nare turning in your\nengineering mind. The orchestrator\nagent private codebase\nwill be available to\nyou. Link available in\nyour loot box. Any\nrelease or system that\nenables you to increase\nthe information rate between\nyour agents and your\nwork requires your attention,\nrequires your focus. The\norchestrator agent is one\nof those systems. Give\nthis a look. Link\nin your loot box.\nI'll see you in\nthe next Agentic Horizon\nlesson.",
  "summary": "This advanced lesson introduces the Orchestrator Agent (O-Agent) - one agent to rule them all. It combines three key capabilities: CRUD operations for agents (Create, Read, Update, Delete), a chat interface to command fleets of specialized agents, and real-time observability for monitoring performance and costs. The lesson demonstrates multi-agent orchestration through a web interface where you can spin up multiple agents simultaneously, track their progress via live log streams, and manage them through a single unified interface. This represents the next paradigm in agentic coding - controlling compute at scale. The system uses a database (Neon/Postgres) to persist agent state and enables workflows where agents can be created, monitored, and reviewed all through natural language commands.",
  "key_concepts": "1. THE ORCHESTRATOR AGENT (O-AGENT): One agent to rule them all. A master agent that commands fleets of specialized agents through a single interface.\n\n2. THREE COMBINED CAPABILITIES: CRUD operations for agents (Create, Read, Update, Delete), Chat interface for commanding agents, Real-time observability for monitoring performance and costs.\n\n3. MULTI-AGENT ORCHESTRATION: The next paradigm in agentic coding. Control compute at scale by managing multiple agents simultaneously through unified orchestration.\n\n4. LIVE LOG STREAM: Real-time monitoring of agent activity, events, and results. Watch agents work in real-time with full observability into their operations.\n\n5. AGENT CRUD OPERATIONS: Create new agents on demand, read their status and outputs, update their configurations, delete when complete. Full lifecycle management.\n\n6. INFORMATION DENSITY: The orchestration interface maximizes information density without losing UX quality. Built for agentic engineers, not normal users.\n\n7. PARALLEL AGENT EXECUTION: Spin up multiple agents simultaneously - have them work on different tasks (summarize codebase, build structure, analyze files) at the same time.\n\n8. REVIEWER AGENTS: Chain agents together - have reviewer agents come in at the end to verify work is done correctly before completion.\n\n9. DATABASE PERSISTENCE: Use Neon/Postgres to persist agent state. Track agent history, costs, and results across sessions.\n\n10. THE NEXT LEVEL: Multi-agent orchestration is crystal clear as a key step in scaling compute to scale impact. Big AI labs will build similar tools - get ahead now."
}