{
  "video_id": "the-12-leverage-points",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/the-12-leverage-points",
  "title": "The 12 Leverage Points of Agentic Coding",
  "channel": "Agentic Engineer",
  "duration": 2835,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T03:08:00.618Z",
  "transcript": "Welcome to Tactical Agentic\nCoding. This is lesson\ntwo. In lesson one,\nwe set the stage.\nIn lesson two, we\nstart performing. In order\nto become an irreplaceable\nengineer, we have to\nstop coding and learn\nto build systems that\ncan operate on our\nbehalf. To get there,\nWe need two things,\na framework that won't\nchange over time and\na tactic that shifts\nhow we engineer from\nAI coding to agentic\ncoding so we can\nmaximize not what we\ncan do, but what\nour agents can do.\nJust like with AI\ncoding, Agentic Coding is\neasy to start, hard\nto master. All the\nlow hanging fruit is\ngetting chewed up. It's\ntime to do the\nsmart work, not the\nhard work to get\nasymmetric return on your\nengineering. It doesn't matter\nleverage points of agentic\ncoding. There are 12\nleverage points of agentic\ncoding you can use\nto maximize your agent's\nability to execute your\nengineering work. Remember, the\ngoal is to become\nan irreplaceable engineer by\nbuilding increasingly self-operating machines.\nIn order to get\nwhere we're trying to\ngo, in order to\nbecome irreplaceable, we need\nhigh leverage agents that\ncan do real engineering\nwork in one shot\nthat we can run\nback to back to\nback to back. Right?\nWe want the longest\nhot streak possible of\nsuccess. When you stack\nup these leverage points,\nAgentic Coding success becomes\ninevitable. Now, what are\nthese leverage points? Let's\nbreak them down and\nlook at a few\nof them in action.\nThere are two types\nof leverage points in\nagent and through agent\nin agent leverage points\ncontain the core four.\nThese are in the\nagent because they're always\nwith your agent context,\nmodel, prompt, tools. We're\nvery aware of these.\nWe're very comfortable with\nthese ideas. We use\nthem all the time,\nevery day to get\nengineering work done. Through\nagents are external levers\nthat eventually interact with\nyour agent that have\nmassive impact on your\nsuccess. They typically flow\nthrough the context window.\nHere we have standard\nout types, documentation, tests,\narchitecture, plans, templates, and\nADWs. Let's shift from\ntheory to some practical\nengineering using the 12\nleverage points of agentic\ncoding. Let's go ahead\nand open up the\nterminal. Here we have\nin its system prompt.\nThat means we can\nquickly see the available\ntools with this prompt.\nWe can type slash\ntools and you can\nsee here we have\nanother baked in prompt\ntemplate we can just\nkeep reusing. If we\nopen up that file\nhere tools dot markdown,\nyou can see the\nexact prompt that's getting\nrun here. So let's\ngo ahead and copy\nthis out. These are\nall of the baked\nin tools. In order\nto really use tactic\nto adopt your agent's\nperspective, We need to\nsee what our agents\ncan see. We need\nto know what they\ncan do. Tools, as\nagent. So this is\ngreat. Now what we\ncan do is close\nthe server here and\nopen up a brand\nnew agent instance. Let's\nopen up a new\ncloud instance. Now we'll\ndo something great. Let's\ngo ahead and prime\nour agent again. We\nwanted to understand the\nstructure of our application.\nThe prime custom slash\ncommand is super, super\nimportant. This in combination\nwith the claw.md lets\nyour agent quickly get\nramped up with information\nabout your codebase.\nWe'll talk about that\nleverage point, the documentation\nleverage point more in\njust a moment, but\nyou can see our\nagent is primed. Now\nI want to run\nthe following. I want\nto say scripts start.sh,\n300s. So now we're\nkicking off our start\nscript inside of our\nagent. Okay. Inside of\nthe current version of\nClaude Code, it only\nshows the first parameter,\nright? Which we know\nfrom looking at things\nfrom our agent perspective,\nif we search for\nthe bash command, the\nfirst command is of\ncourse the command that\nwe want to execute.\nOkay. So we know\nthe tools our agent\nhas access to now\nlet's put it to\nwork. Let's really use\nthat leverage point. So\nit's running this right\nnow. That means it\nhas access to standard\nout upload data. And\nlet's drop this in\nhere once again. Okay.\nSo we have that\nerror. And now we\nknow for a fact\nthat our agent has\nseen the error. From\nour agent's perspective, it\nis seeing the standard\nout from the start\nscript, which shows output\nfrom the server and\nthe client. Fantastic. So\nnow I'm going to\nstop running this and\nthen I'm just going\nto prompt any issues\nwith the server. Now\nwe know there's an\nissue, right? But we're\njust validating it with\nour agent here. Let's\nsee what it comes\ntools, right? Because we\nknow exactly what our\nagent can see and\ndo. We're thinking from\nour agent perspective. It\nis a sub agent\nfor a keyword and\nfile searches. It's firing\noff a sub agent\nto do work for\nus. All right. So\nwe're getting a bunch\nof commands fired off\nhere. You can see\nwe're searching, check out\nthe search, right? Pulling\ntogether all the instances,\nall the locations of\nthis type. To be\nclear, when I say\ntypes, I'm talking about\nclasses, exceptions, interfaces, and\nall typing structures that\nrepresent a concrete piece\nof information in your\ncodebase. Okay, so\nit's finished 26 K\ntokens, seven tool uses\nand check this out,\nright? We have a\ntop to bottom flow\nof this type throughout\nthe application. Okay. Just\nhow you saw our\nagent searching here, This\nis how you can\nuse types to track\nthe flow of information\nthroughout your application, right?\nThis is a critical\nleverage point of agentic\ncoding. This gives your\nagents the ability to\nlook at flows of\ninformation throughout your code\nbase. All right. So\nwe go from data\nmodel, servers, types, client,\nand then we have\nit detailed inside of\nour original spec file.\nRemember that types are\nIDKs information dense keywords.\nThey point to exact\nlocations in your code\nbase and represent the\nflow of a specific\ntype of information. You've\nlikely done this where\nyou copy a type\nor a class and\nthen you search throughout\nthe entire application and\nit tells you where\nall instances of this\ntype is, which tells\na story about the\ndata and an information\nflow that you and\nnow, more importantly, your\nagents can follow to\ndeliver on engineering work.\nRemember that everything you\nname can be an\ninformation dense keyword. If\nyou start muddying your\ntypes and your data\nmodels and you call\nsomething, you know, something\neven like this, right?\nQuery request, query response,\nnot that good, right?\nThis is one of\nthose words that's like,\nData request, okay, terrible,\nterrible name. There's not\na lot of information\nhere. If your agent\never wants to search\nfor data or just\nrequest, it's cooked. Use\nthese information dense keywords,\nname things, be a\nlittle bit more verbose\nand direct. You wanna\navoid large file sizes.\nI like the limit\nof 1000 lines as\na loose, you know,\ngood max file size\nto have great code\nbased architecture. You want\nto have these markdown\nfiles, right? These read\nme's or these Claude.mds,\nwhatever the agent specific\ndocumentation file is. You\nwant to have that\nspread throughout your code\nbase available whenever you\nneed it. You can\nsee we have it\nhere. We have it\nin our tree. You\nreally want these inside\nthroughout your applications. We're\ngoing to be building\nthese out as we\ngo along in tactical\nagent to coding. All\nright. You want to\nseparate your services to\nmake things really clear\nwhere things are at\na high level. Stick\nto one responsibility per\nfile. You want to\nsync your test file.\nIf we open up\nthe server here and\nwe go to tests,\nright, we can see\nour tests represent the\nexact same folder structure\nas our server, right?\nWe have core and\nwe're testing everything in\nthe core, right? So\nyou want to mirror\nthese. It makes it\nreally easy for your\nagent to see and\nwrite tests. Obviously, we're\ngetting to test in\na moment here. That's\na really important high\nleverage point of agentic\ncoding. There are many\nways to organize your\nis probably the first\nleverage point you should\ngo after right next\nto standard out. We'll\ndig into testing in\nfuture lessons, right? Backend\ntesting is obviously a\nlot simpler. We also\nwant front end tests.\nWe want our agent\nto be able to,\nyou know, really look\nat our front end\nto see the results\nof its work. We\nwant it to be\nable to click buttons.\nWe're going to look\nat both front end\nand back-end testing with\nour agents throughout tactical\nAgentic Coding. Let's talk\nabout plans. So this\nis a popular high\nleverage point of agentic\ncoding. If we open\nup specs, we have\nthe initialize codebase\nplan here. And so\nyou can look at\nthis, you know, it's\nsome 750 lines long,\nlots of details, you\nknow, going into code\nexamples, front and back-end\ntypes, high level, so\non and so forth.\nMost engineers don't spend\nenough time communicating what\nthey want done. Put\nsimply, Plans are just\nprompts. Put accurately, plans\nare how you communicate\nmassive amounts of work\nto your agent. This\nis how we scale\nup our work. This\nis how we do\nmore in less time.\nAnd as you may\nhave noticed by looking\nat this, there is\nno way that I\nsat here and typed\nout 700 lines of\na plan. We are\ngoing to be planning\nwith our agent. We're\ngoing to showcase how\nyou can take your\nhigh level, low information,\nfrankly, bad prompt, hand\nit to your agent\nand let it generate\nthe first draft of\nyour plan for you.\nOkay. Planning is the\nfirst key step of\nthe software development life\ncycle. You need to\nknow what you want.\nYou need to define\nit and your ability\nto communicate that information\nis all about how\nwell you write your\njust walk through these\nand really understand what\nthese mean. This is\nhow we know we're\nimproving, right? It's not\nenough to vibe code\nto randomly ship a\nfeature. That's cool. That's\ntable stakes, right? That's,\nthat's the low hanging\nfruit. We need to\nknow we're improving. We\nneed metrics. Right? If\nyou don't measure it,\nyou can't improve it.\nSo we want to\nincrease size. We want\nto decrease attempts. We\nwant to increase our\nstreak and we want\nto decrease our presence.\nThese four make up\nyour Agentic Coding KPIs.\nAt the first level,\nwe have size. We\nwant to increase the\nsize of work we\ncan hand off to\nour Agentic Coding tools,\nto our agents. Okay.\nIf you're improving, you'll\nbe increasing the size\nof work, Right. So\nthis means writing bigger\nplans and that means\nthat your larger plans\nwill likely consume more\ntime, which will correlate\nto longer agent runs.\nRight. If you've been\nrunning five minute agentic\njobs, right, where your\nagent goes off for\nfive minutes and works\non your codebase,\nthat's good. We want\nthat number to go\nup 10, 20, 30,\nan hour, three hours.\nDon't underestimate the amount\nof work you can\nhand off autonomously to\nyour agent. So that's\nsize. If you're improving,\nyour agent decoding, this\nnumber goes up. Now,\nof course, we have\nattempts. You know where\nthis is going, right?\nWe don't want issues.\nWe don't want to\nmiscommunicate. We don't want\nto have to go\nback in after the\nprompt completes and fix\nissues. This is attempts.\nYou want to drive\nyour attempts down. Why\nis that? It's because\nattempts, when you have\nto come back in,\nprompt again, correct the\nmistake, this costs your\nthis vision will become\nclearer and clearer to\nyou. Okay, there's of\ncourse iteration along the\nway. Of course, as\nyou scale up the\nsize of your work,\nyou'll have to put\nmore attempts in, you'll\nbreak your streak, that's\nfine. We're gonna have\nhigh presence at the\nbeginning, but the goal\nis that you have\nconcrete KPIs you can\ndrive down, you can\ndrive to success, okay?\nThis is Agentic Coding,\nthis is tactical agentic\ncoding, this is how\nwe can know, right?\nNot guess, not vibe,\nthis is how we\nknow we're improving, all\nright? There are ways\nto systematize this inside\nof applications, inside of\nGitHub or Jira or\nwhatever you wanna use,\nbut right now, all\nyou need to do\nto be successful here\nthroughout tactical Agentic Coding\nkeep these numbers floating\naround your mind and\nknow that you can\nuse the 12 leverage\npoints of Agentic Coding\nto take your agent's\nperspective to improve these\nkpis okay and step\nby step we're going\nto automate the software\ndevelopment life cycle you'll\nnotice with all four\nof these kpis you\ncan improve them all\nby using one or\nmore of the 12\nleverage points of agentic\ncoding really four or\nmore right because the\ncore four are always\nthere. So, you know,\nfor example, does your\nagent get confused because\nyour codebase is\nusing dictionaries instead of\ntypes, right? Obviously the\nclear answer there, leverage\ntypes to improve your\nagent performance, all right?\nIs your codebase\nstructure inconsistent and confusing\nto navigate even for\nyour team, right? Okay,\nrefactor your codebase,\nbuild it for the\nnew age of agents.\nAre you still manually\nusing Claude Code. We'll\nbe using AI agents\nto do engineering work\nautonomously. This will be\nuncomfortable. As us engineers,\nwe love control and\nvisibility, but it's time\nfor us to let\nthat go. In order\nto let our code\nbase run itself, we\nhave to let go\nof control. We still\nneed to know exactly\nwhat's happening. We still\nneed to be able\nto observe, but we\nneed to let go\nof the hands-on engineering,\nright? We have to\nstop coding. This is\ngoing to be hard.\nThe hardest thing we\ndo in tactical agentic\ncoding is transition away\nfrom AI coding and\neven further away from\nmanual coding. The new\nage phase two engineering\nlooks less and less\nof what it used\nto look like. What\ndoes stay is architecture.\nWhat does stay is\ndirection. It's planning. It's\nthinking. It's engineering. It's\nbuilding out to create\nvalue, right? This is\nall about our products\nand our products are\nall about our users.\nOkay. Never lose sight\nof that throughout every\nlesson, throughout all the\nnoise, bring it all\nback to what this\nis all for. We're\nscaling up what we\ncan do. Once again,\nwe're going up the\nabstraction chain. Once again,\nEnglish is the new\nprogramming language and we're\njust digging into that\nfact and we're taking\nit where it's going\nbefore it gets there.\nOkay? These leverage points,\nthe largest consistent impact\non your ability to\ncreate engineering results with\none-shot agentic prompts now\nthis is important if\nyou want to create\npowerful sets of agents\nand deploy them across\nthe software development life\ncycle like we're aiming\nto do we must\nknow how to fire\noff a single powerful\nbecause they're so powerful,\nthey deserve their own\nlesson and notice how\nsome of the leverage\npoints are the node\nin the software developer\nlifecycle. Okay. In lesson\nthree, we'll focus our\nattention on one of\nthe most powerful leverage\npoints, the plan. You'll\nlearn to use meta\nprompting. We'll use higher\norder prompts and we'll\nbuild reusable plans that\nyou're agent can use\nto transform your high\nlevel prompt into low\nlevel accurate codebase\ndetails that will increase\nyour KPIs, right? Your\nkey performance indicators. You'll\nlearn how to write\nplans from your agent's\nperspective, plans that are\nso clear success becomes\ninevitable. Great work here.\nYou've got the momentum\nrolling toward the future\nof Agentic Coding. I'll\nsee you in lesson\nthree.",
  "summary": "This lesson introduces the second tactic: Adopt Your Agents Perspective. To maximize what your agents can do, you must see your codebase through their eyes. The lesson presents the 12 Leverage Points of Agentic Coding - ways to increase your agents ability to execute engineering work. The Core Four leverage points are: Context, Model, Prompt, and Tools. Eight additional leverage points include: Standard Out, Testing, File Organization, Documentation (CLAUDE.md), Memory (scratchpads), Hooks, MCP (Model Context Protocol), and Sub-agents. The lesson also introduces four Agentic Coding KPIs to measure improvement: Presence (time spent supervising - want down), Size (scope of work per prompt - want up), Streak (consecutive successful completions - want up), and Attempts (retries needed - want down).",
  "key_concepts": "1. ADOPT YOUR AGENTS PERSPECTIVE: The second tactic. Step inside your agents context window and see your codebase through its eyes. Maximize not what you can do, but what your agents can do for you.\n\n2. THE 12 LEVERAGE POINTS OF AGENTIC CODING: A framework of 12 ways to increase your agents ability to execute engineering work. These wont change over time as tools and models evolve.\n\n3. THE CORE FOUR: The four most important leverage points: (1) Context - what your agent can see, (2) Model - capabilities and intelligence, (3) Prompt - instructions and intent, (4) Tools - actions your agent can take.\n\n4. EIGHT ADDITIONAL LEVERAGE POINTS: Standard Out (agent sees terminal output), Testing (validation), File Organization (clear structure), Documentation (CLAUDE.md), Memory (scratchpads for thinking), Hooks (automation triggers), MCP (Model Context Protocol), Sub-agents (agent orchestration).\n\n5. STANDARD OUT: One of the highest leverage points. Your agent can see everything in standard output - errors, logs, results. Run scripts inside your agent session so it sees the output directly.\n\n6. FILE ORGANIZATION: Separate services clearly, one responsibility per file, mirror test file structure to source structure. Makes it easy for agents to navigate and understand your codebase.\n\n7. DOCUMENTATION (CLAUDE.md): The claude.md file primes your agent with information about your codebase. Lets your agent quickly ramp up on project context.\n\n8. AGENTIC CODING KPIs: Four metrics to measure improvement: Presence (time supervising - want DOWN), Size (scope per prompt - want UP), Streak (consecutive successes - want UP), Attempts (retries needed - want DOWN).\n\n9. ITERATIVE IMPROVEMENT: Start with high presence and small scope. As you improve your leverage points, drive presence down, size up, streak up, and attempts down. Use the 12 leverage points to improve these KPIs.\n\n10. SOFTWARE DEVELOPMENT LIFECYCLE AUTOMATION: The goal is to step-by-step automate the software development lifecycle by using the 12 leverage points and improving your agentic coding KPIs."
}