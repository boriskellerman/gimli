{
  "video_id": "building-agentic-layers",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/building-agentic-layers",
  "title": "The Codebase Singularity",
  "channel": "Agentic Engineer",
  "duration": 3500,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T04:25:12.521Z",
  "transcript": "Everything we've done so\nfar was built to\ndrive you toward one\nsingular moment in your\nengineering career. This one\nmoment will open many\ndoors for you while\nclosing others. Engineers that\nare able to reach\nthis one moment will\nbe rewarded for investing\nso much so early\ninto language models, prompt\nengineering, context engineering, agents,\nand ultimately agentic engineering\nwe've been building up\nto the codebase\nsingularity let's begin the\nfinal lesson of agentic\nhorizon with the most\nimportant idea from tactical\nAgentic Coding and work\nour way up to\nthe codebase singularity\nout of all the\ntactics concepts and agentic\npatterns we've discussed throughout\n13 lessons together there\nis one mental framework\nthat sits at the\ncenter, an idea so\nimportant that if you\ncapture it, it can\nchange the way you\nengineer forever. The agentic\nlayer. This is the\nnew ring around your\ncodebase where you\nteach your agents to\noperate your application on\nyour behalf as well\nand even better than\nyou and your team\never could. Focusing on\nbuilding the agentic layer\nof your codebase\nis the highest return\non investment action for\nany engineer in the\nage of agents we\nlive in why is\nthat as you know\nwhen you scale your\ncompute you scale your\nimpact we're not just\nAI coding anymore our\nagents can take actions\non our behalf and\nthis has changed engineering\nforever prioritizing agentics means\ngoing all in on\nthis idea. It means\ngoing all in on\ncompute as the best\nnew tool for engineers\nto crud, manage and\nmanipulate systems of information.\nCompute in its most\nuseful form is in\na prompt and a\nloop with tools, the\nagent. This transformed the\nbig three into the\ncore four, context, model,\nprompt, tools. A powerful\nabstraction that lets you\ntalk to information itself.\nAfter 13 lessons, you\nunderstand this now. You\nknow that the leverage\npoints of Agentic Coding\nfundamentally change what a\nsingle engineer can do,\nand therefore it changes\nwhat your team can\ndo and what your\ncompany can do. In\nour final lesson together,\nI wanna solidify everything\nyou've learned into a\ncomprehensive roadmap for building\nagentic layers. By the\nend of this lesson,\nyou'll understand the different\nshapes stages, and components\nfor building real agentic\nlayers for new and\nexisting codebases. And\nyou'll understand what the\nnext step is for\nimproving your agentic layer.\nSoftware is always evolving\nto better solve your\nusers, customers, and clients\nproblems. The current state\nof your codebase\nis only a step\nto the next state\nof your codebase.\nWe'll be putting together\nbig ideas from tactical\nAgentic Coding and Agentic\nHorizon to round out\nyour experience here. It's\nbeen incredible creating this\nfor you over the\npast year. Since its\nlaunch, thousands of engineers\nthat know agents of\nthe present and the\nfuture have upskilled what\nthey can do with\npowerful tactics of agentic\ncoding we've discussed here\ntogether. If you take\nthese ideas, in these\ncourses and put them\nto work as many\nalready have, you will\naccelerate past the industry\ninto a new role\nof engineering, agentic engineering.\nHere we build the\nsystem that builds the\nsystem. Owning the agentic\nlayer and knowing how\nto build them at\nwill at scale will\nmake you an invaluable,\nirreplaceable engineer. I mean\nthis when I say\nthis, if you do\nthis right, it will\nchange Everything there is\na massive career changing\nopportunity that will emerge\nas you build your\nagentic layer in moment\nin time, singular in\nnature. Once you've built\na sufficiently powerful agentic\nlayer, something will happen.\nThe codebase singularity\nin this moment, you,\nthe engineer will realize\none simple fact. My\nagents can now run\nmy codebase better.\nthan I can. I\ntrust them to ship\nmore than I trust\nmyself or my team.\nNothing ships to production\nwithout my teams of\nagents. Yes, this might\nsound crazy. It might\nsound far out, but\nif you've been pushing\nwhat you can do\nwith agents, if you've\nbeen putting these tactics\nto work already, maybe\nyou already see this\nfuture on the horizon,\nthe Agentic Horizon. I\ncan tell you this\nfor certain right now,\nthere is an agentic\nlayer that could exist\ninside your codebase,\nso powerful that your\ncodebase runs itself.\nThe only question now\nis, do you know\nhow to build it?\nBridging this gap is\ngonna be a key\npart of our mission\nhere in the final\nlesson. As we work\nthrough building agentic layers,\nkeep this idea in\nyour mind and think\nthrough what it would\ntake for you to\ntrust your agents to\nrun your codebase\nbetter than you could\nfrom prompt to production.\nI'm not saying this\nwill be simple, but\nwith everything you've learned\nso far throughout tactical\nagenda coding and agenda\nhorizon, this is now\na potential reality for\nyou. In this lesson,\nwe're gonna put together\nthe missing pieces and\nsee how we can\nattain the codebase\nsingularity. There are three\nconcrete classes of the\nagentic layer. Class one,\nclass two, and class\nthree each. defined by\na unique element that\nmakes them distinct from\nthe rest. Our whole\ngoal here is to\nlook at the components,\nthe raw elements that\nmake up the new\nring around your code\nbase where you have\nagents drive your engineering\nexperience and you drive\nyour agents. The green\nsquares here, the outer\nlayer, this is the\nnew agentic layer. The\ninner layer here, right,\nthese dark squares, this\nis going to be\nyour application layer. And\nwe're bundling a ton\nof things underneath your\napplication layer. We're talking\nabout your database, your\nfront end, your backend,\nyour scripts, all the\napplication stuff, even your\nDevOps stuff, right? This\nall goes underneath the\napplication layer. Why is\nthat? It's because we\nwant to be able\nto bundle your different\nrepositories underneath your agentic\nlayer. so that we\ncan do something like\nthis. Code bases often\ncontain more than one\napplication. So by bundling\nyour agentic layer around\nyour applications, right, every\nsingle application that's related\nability to run arbitrary\nend-to-end workflows. This is\nwhat the future of\nengineering looks like, fine-tuned\nto your specific domain,\nto your specific use\ncase. This is one\nversion of the end\nvision of how to\nreally scale your compute\nto scale your impact.\nNow let's dial in\nand start from zero,\nright? Let's reset because\nwe don't start here.\nWe don't start at\nclass three. We don't\nstart with powerful orchestration\nsystems. We start with\nnothing. So as mentioned,\nevery single codebase\nshould now have these\ntwo key components, the\napplication layer and the\nagentic layer. These two\nsquares here represent a\nbrand new codebase.\nNow, oftentimes you'll be\noperating in an existing\ncodebase that will\nlook like this, right?\nYou'll already have some\npieces, right? Modules, files\nof your application layer,\nand then you'll start\nadding on your agentic\nlayer around your code\nbase. Now, what does\nthis really look like?\nLet's start from a\ngreenfield, brand new application\njust to make this\nall clear. What exactly\nis in our agentic\nlayer? This is our\nclass one, grade one\nagentic layer. The thinnest\npossible agentic layer you\ncan have. A small\namount of code and\nyou have a prime\nprompt and or memory\nfiles. It doesn't get\nthinner than this. If\nyou have this, you\ntechnically have an agentic\nlayer. Now let's dive\ninto a concrete code\nbase structure to see\nwhat this looks like.\nThis is an example\nproject structure. We're gonna\nwork through several of\nthese to make it\nabsolutely clear what it\nlooks like to have\nan agentic layer surrounding\nyour application layer. So\nwe have application layer\nfiles, folders, directories, so\non and so forth.\nAnd we have our\nagentic layer files. If\nwe open up dot\ncloud here, dot commands,\nwe can see we\nhave this prime command.\nAs you know, the\nprime command effectively represents\na memory file, but\nthe big difference here\nis that you can\nactivate this whenever you\nwant to, and you\ncan fine tune the\nprime command to run\nany specific workflow you\nwant to. Okay. So\nthis is just a\nprompt that effectively activates\nyour agent to read\nspecific files, right? So\nthere's nothing new here,\nright? We have a\nclassic agentic prompt dot\nClaude, of course, is\nour memory file. That's\nalways going to load.\nYou've seen this, you\nunderstand this, you know\nthis. And oftentimes, I\nlike to take the\nagents.md if I'm working\nwith other agents and\njust reference that claw.md\nmemory file. This is\nthe simplest possible agent\ndeclare. Now in our\napplication layer, if we're\ngoing to user management,\nwhere we have a\nbackend for a user\nmanagement system, this is\njust a starting place,\nright? This is a\ngreat way to, when\nyou're creating a new\napplication, just start with\nsomething, An agent can\ncome in here and\nunderstand how to operate\nthis right away with\nthe memory file and\nwith the prime command.\nOkay, so as we\nwork through classes and\ngrades, we'll talk about\nthe compute advantage you\nget by scaling to\nthis class and grade\nof agentic layer. And\nthen we'll of course\ntalk about trade-offs. So\nthe compute advantage here\nis obvious, right? We\nget a clean minimal\nsetup. It's a great\nfoundation for agentic growth\nand agents understand context\nimmediately. It's a super\nsmall codebase. This\nis easily reproducible by\nanyone. There's no value\nin a codebase\nthis small. It's useless\nfor large codebases.\nwe have three key\nnew pieces, skills, MCP\nservers, and prime commands\nwith tool access. You\nluckily already know what\nthat is. All of\nthese three things give\nus the same thing,\ncustom tools that enhance\nour agents core four.\nLet's take a look\nat what this actually\nlooks like in an\nagentic layer. Class one,\ngrade three. Now we\nhave a couple additional\nbaseable files. You might\nhave a .mcp.json, Postgres,\nFirecrawl, JIRA, Notion, whatever\ntool you want to\nuse, you can now\nthrow it in here,\nbut that's not all.\nWe know that MCPs\nare very token heavy\nand we can just\nprompt engineer properly to\nget our agents the\ntools they need. One\nof the ways that\nthat can be done\nis with skills. Our\nagents have learned to\nmigrate the database. And\nso inside of this\nfile, you know, you've\nseen these before, we\nhave how to use\na specific tool and\nit can now use\nit to perform a\nspecific We're starting to\nspecialize our agents a\nlittle bit more outside\nof our sub agents,\nbut we can also\ndo things like this,\nright? Start and stop\napplication. If we open\nup this skill, we\nare just teaching our\nagent how to use\nscripts. There's no need\nfor an MCP server.\nOftentimes you can just\nbuild your own script\nthat exposes the right\nfunctionality. Here we have\na start and a\nstop tool that starts\nand stops the application.\nOkay. So we're just\nscaling up what our\nagentic layer can do.\nWe're giving our agents\nmore capability, right? We\nare scaling our compute\nto scale our impact.\nNow I have access\nto custom tools, skills,\nand prime commands, right?\nAnd keep in mind,\nthis is something that\nI want to keep\nemphasizing. Skills and MCP\nservers can both be\nreplaced with just a\nsimple prompt. Okay, so\nwe have this prime\nDB with tools. You\ncan teach your agents\nhow to execute CLI\ncommands. Here we're just\nusing PSQL, right? So\nthat our agent knows\nhow to interact with\nthe user management database\nfor this mock application.\nAnd so you can\nbypass everything by just\nunderstanding how the core\nfour works, context model,\nprompt, and tools, okay?\nNotice what we're doing\nhere, right? We're constantly\ngiving our agents more\ncapability. Custom tools is\na huge step. Grade\nthree is very important.\nNow, this is when\nprompt engineering and context\nengineering becomes more important.\nSkills, MCP servers, and\nprompts must have tools\ncarefully designed. This is\nwhere things can start\ngoing wrong. And a\nlot of engineers do\nget stuck at grade\nthree. They think they\nget past this, but\nactually their tools are\nterrible and they won't\nscale and they're chewing\nup tokens, they're burning\ncash and they're over\nengineering their tools, right?\nLike one of the\nmost common problems is\nthat engineers will have\nway too many tools\nand they need to\nactually learn how to\nbuild tools and give\ntheir agents just what\nhave a concrete closed-loop\nprompt. I'm being really\nverbose here with my\nlanguage inside of these\nmock prompts. You know,\nwe're following that three-step\nworkflow from tactical agentic\ncoding, lesson five, request,\nvalidate, Resolve. This creates\na closed loop where\nyour agent can spend\nand spend until the\njob is done. This\ndistinctly marks grade four\nagain This is a\nplace where engineers fall\noff and they miss\nout on using more\ncompute to get the\njob done. We're starting\nto split our prompts\nto focus on specific\nareas of this code\nbase. So things are\ngoing from really generic\nand vague, plan, build,\nto more specific. Test\nour backend, test our\nfront end, review with\nthis code how we\nlike to do it.\nAnd the advantages here\nare really clear. Once\nyou start using closed\nloop prompts in your\ncodebase, your agents\nstart resolving their own\nwork. You can create\nspecialized tasks, for your\nfront end, for your\nback end, for whatever\npart of your code\nbase. And it's all\nstill on this top\nlayer. Now we're not\ngonna dive into code\nbase organization too much\nhere. There are some\nleverage points of agentic\ncoding that we're not\ngonna reemphasize here. Here\nwe're focused on giving\nour agents the highest\ncapability possible so that\nthey are as autonomous\nas possible. Now there\nare some trade-offs here.\nAgain, things start to\nget more complex. You\nneed to know how\nto prompt engineer. This\nis why our agentic\nprompt engineering lesson was\nso important. You must\nknow how to write\nthese prompts. properly. Self-correcting\nagents is a massive,\nmassive win for your\nagentic layer. Let's move\non to grade five.\nHow does our agentic\nlayer continue progressing? Now,\nby this point, many\nengineers have many, many\nprompts, many agents, several\nskills. They've used many\ndifferent types of MCP\nservers and they start\nscaling their work even\nfurther with a key\nconcept we discussed in\nlesson three, templates. Now,\nmany engineers don't realize\nthey're writing templates, but\nthis is where you\nreally start templating your\nengineering, where you teach\nyour agent how to\nbuild like you would.\nAs you know from\ntech, we have bug\nfeature chore for our\nfront end and back\nend application. We'll have\nthings like new API\nendpoint, update API endpoint,\ntest new API endpoint.\nThe big distinguishing factor\nhere is templates. Now\nlet's just look at\nthe advantages here and\nthen we'll dive into\nwhat these look like\nexactly. Templates are structured\nplans with specific output\nformats for different types\nof work. This lets\nyou customize how you\nwant your agent to\nbuild. This is where\nyou can truly template\nyour engineering and teach\nyour agents to build\nlike you do. And\nthe most straightforward example\nof this is something\nlike the bug. So\nwhen you open up\nthe bug, you can\nsee a very similar\nformat. This was repurposed\nfrom TAC. We're now\nhaving our agents output\na specific format, a\nspecific output plan file\nthat will then execute.\nThis is ultra powerful\nbecause you get to\ndetail what your agent\ndoes right so not\nonly are we giving\nhigh level instructions we're\nsaying hey fill this\nout this is how\nwe solve bugs these\nare the steps these\nare relevant files here's\nhow you're going to\norganize your steps individually\nand then at the\nend we always run\nthat validation right we\nare embedding our closed\nloop prompts add more\ncompute to add more\ntrust in our systems\nand we're embedding this\nright we're templating this\nin to our prompts.\nThis distinctly identifies grade\nfive. This is kind\nof hard to see.\nIf you're just building\nout these random ad\nhoc prompts, it's hard\nto see this distinguishing\nfactor between a plan\nand a template, but\nit is massive. When\nyou start building templates,\nyour agent starts operating\nmore like you would.\nBecause for instance, right,\nGit codebase. These\nlanguage models, they know\nhow to operate Git\njust fine. Say you\nhave five applications here\nunder your application layer\ndirectory that's fine, right?\nYou can have five\ndifferent teams of engineers\nworking on all of\nthese, right? Obviously, just\nto be clear, you\nwant these to be\nrelated codebases that\nhelp feel a product\nexperience, right? If you\ndon't need your agent\nto see multiple code\nbases at the same\ntime, it's fine. Have\nthem be separate, duplicate\nyour agentic layer, right?\nBuild it out separately.\nAnd you know, again,\nspecialize it. Engineers go\nwrong here too. They\nthink they need to\nbuild a generic one\nsize fits all agentic\nlayer. That is not\nwhat we're doing here\nat all. Your agentic\nlayer should be specialized\nto fit and wrap\nyour codebase. Okay.\nMake it specialized. Right.\nAnd that's where templating\nbecomes really important because\nyou really start to\nshape all of your\nagentics, all of your\nleverage points of agentic\ncoding to your specific\ncodebase to your\nspecific use case. And\nby doing that, you\nbuild a distinguished unique\nproduct experience through your\napplication layer and through\nyour agentic layer. Okay,\nso push into making\nyour agentic layer unique\nand specialized for that\none codebase. Don't\nfocus on reuse, right?\nFocus on making these\nprompts great, for that\none codebase, okay?\nYou know, compute advantage\nis exactly what you\nwould think. Agents fill\nin your templates, bug\nfeature chore. We can\nnow build specific prompts\nfor specific problems that\nwe solve in this\ncodebase, all right?\nTrade-offs, of course, with\nevery class and grade\nwe move through, we\nhave to invest in\nthis, right? And over-templating\ncan reduce agent flexibility.\nThis isn't usually a\nproblem, but it is\nsomething that can come\nup if you're defining\nthese structures that are\ntoo strict, that don't\ncapture the full scope\nof the work you're\ntrying to do and\ntemplates should evolve as\nthe codebase changes\nand evolve. You know,\nthe big trade-off with\na lot of your\nagentic layer is going\nto be, you're going\nto have to maintain\nthis. You're going to\nhave to grow it.\nOkay. The agentic layer\nis a unique investment.\nNow let's move on\nto grade six. So\nthings have expanded, right?\nYour codebase is\ngrowing. Your product is\nsuccessful. It's not enough\nto just run a\nsingle prompt. You're now\nat the stage where\nyou are prompt chaining\nor you're running agentic\nworkflows, right? So now\none prompt now references\nmany prompts and or\nsub-agents and other skills,\nokay? For instance, you\nknow, the most concrete\nexample of this is\nthe plan build workflow.\nFirst you write the\nplan and then you\nbuild it. You can\nhave two separate agents\ndo this work. You\ncan have one agent\ndo the work. We\ndon't want to violate\ntactic six too much,\nbut when you're starting,\nanything is on, right?\nJust get the job\ndone. So what does\nthis look like in\na concrete codebase?\nLet's take a look.\nSo we're just gonna\nfast forward here. Just\nwanna reveal everything so\nit's super clear, right?\nThis is a massive\nstep in your agentic\nlayer. When you start\nchaining together prompts and\nagents, you are building\nout the first versions\nof the most powerful\nleverage point of agentic\ncoding, the AI developer\nworkflow, okay? So this\nis ultra, ultra powerful.\nLet's take a look\nat this. Let's look\nfor one of the\nmost foundational ones here,\nmulti-step workflow where we're\ngonna launch parallel scouts\nand then we're gonna\ncollect scout results. We're\ngonna synthesize all their\nfindings into a single\nfile. Again, in our\napp reviews, you can\nsort of this in\napp docs, wherever you\nwanna store it. And\nthen we're gonna run\nplan with scouts. So\nbefore this agent runs\nand does, you know,\nthe main work, we\nfirst run sub agents\nto research and look\nfor information, okay? The\nexact details of this\nprompt They don't matter.\nYou've seen prompts like\nthis before, but the\nkey is this. You\nwant to be able\nto chain together prompts\nto create composite workflows,\nright? Also known as\nprompt chains or agentic\nworkflows, right? Series of\nsteps, okay? Now, of\ncourse, the limitations are\nall very obvious, right?\nYou must know what\nyou want to build.\nYou have to know\nwhat you're doing. because\nwhen you start chaining\ntogether at this level\nof complexity, things can\nfall apart very quickly,\nright? These can also\nbe harder to debug,\nespecially if you start\nthrowing everything in a\nsingle agent and especially\nas you get close\nto that context window\nlimit, right? We talk\nabout the R and\nD framework. We talk\nabout a lot of\nways to get around\nthese problems in previous\nlessons. Feel free to\nreference those lessons as\nyou work and run\ninto these issues over\nand over. For the\nnext few years, everything\nis just managing your\ncore four and then\nscaling it up with\nmore better custom and\norchestrator agents. We'll get\nto that in a\nmoment here, all right?\nContext engineering becomes not\njust important, but it\nbecomes a requirement at\nthis stage. At this\npoint, you must be\nadopting your agent's perspective.\nYou can't write a\nfive agent long prompt\nchain without knowing the\ncontext that every agent\neight, and it leads\nus to codebases\nthat run themselves. I\nhope you can see\nthat. I hope you\ncan see that's, you\nknow, we've been slowly\nbuilding up to all\nof this, right, over\nevery tact lesson, over\nevery AH lesson. It\nleaves up to the\nAsian expert. Okay. And\nof course, you know,\nthis is where agentic\nprompt engineering, context engineering,\nthese are all now\nhard requirements. Okay. In\nfact, requires a high\nlevel of prompt engineering\nand context engineering. Okay.\nSo, you know, we\ntalked about this before\nyou have a whole\nmental model and agent\nis keeping track of\nit knows where file\nreferences are. It understands\nthe kind of core\nunderlying thing that a\nspecific area of your\ncodebase manages. And\nthen you have surrounding\nprompts, right? So you\nhave a question prompt\nto ask questions to\nthis expert when you're\nbuilding or want to\nunderstand You can plan,\nyou can build, and\nthen of course you\ncan chain it together.\nNow again, I wanna\nbe super clear about\nthis. It doesn't matter\nif this is a\nset of prompts. I\nalways recommend you have\na set of prompts\nto build off, but\nyou can build this\ninto a custom agent,\nsub agent. You can\nbuild it into a\nskill. You can build\na prime prompt. You\ndon't need a skill.\nSkill is just a\nmarkdown file that references\nother files. You can\nbuild this by hand.\nThe composite type doesn't\nmatter, but what does\nmatter is always thinking\nabout increasing your compute\nadvantage with powerful techniques\nlike this, all right?\nBecause this gives us\nself-improving expertise and then\nyou can build specialized\nworkflows on top of\nthat. But this uniquely\nidentifies a class seven,\ngrade seven agentic layer.\nYou have built experts\ninto your codebase.\nI just wanna be\nsuper clear. The form\nfactor doesn't matter that\nmuch because everything turns\ninto the context model\nprompting tools. The question\nfor you is, do\nyou have a specialized\nagent that can operate\nspecific parts of your\ncodebase better than\nyou can, increasingly so.\nAgain, all this stuff\ntakes practice, right? I'm\nbetting here that the\nnext few years of\nengineering is spent building\nout these class one,\nclass two, and class\nthree agentic layers. This\nleads us directly to\nour next class, class\ntwo, grade one. This\nis where we start\ngetting that second tier,\nclass two, Grade one\nis uniquely identified by\none big change we\ntalk about in lesson\nfour of tactical agentic\ncoding. As you can\nsee here, we are\nnow pushing into ADWs.\nWe don't have a\nfull ADW yet, but\nyou can see we're\nstarting to put together\nthat second layer. Class\ntwo, also known as\nlayer two, is where\nyou build out an\nout loop system, okay?\nThis is the Peter\nframework. This is where\nwe are staying out\nthe loop and we're\nmaking sure that our\nagents can operate our\ncodebase without us.\nNow grade one is\nus building out the\nfabric of this. So\nwe have for instance,\na web hook. So\nan HTTP endpoint that\nyou expose, of course,\nwith the right security\nand all that. This\nmeans you can call\nthat endpoint through an\nexternal service, Slack, Jira,\nDiscord, GitHub, right? We\nuse GitHub and tactical\nagenda coding, but you\ncan set up whatever\nOutlook system you want.\nBut in this very\nfirst bare version, right,\nclass two, grade one,\nyou can just execute\nprompts against your code\nlayer that then calls\ninto your key agents.\nNow here we are\nrunning agents via an\nagent SDK. So this\nis where programmatic agents,\nright? Building your own\ncustom agents become super\ncritical. We talk about\nthis throughout TAC. This\nis how you stay\nout the loop, right?\nThis is Outloop agentic\ncoding. This is where\nwe start building up\na deterministic scripting layer\nfor orchestrating our agents.\nAnd so we have\nthat core agent SDK,\nwhich just defines all\nthe SDK functionality, and\nthen we can prompt\nagainst it. Now you\nprobably have noticed that\nwe are missing the\nactual full AI developer\nworkflows here. That is\nwhat defines grade two,\nright? So at this\npoint, your codebase\nis very, very built\nout. You have lots\nof agents running around\ndoing work for you,\nand now things go\nparabolic. This is a\nmassive step in your\nagentic layer. Now we\ncan run complete workflows\nthat do specialized work\non your application layer\nthrough your agentic layer\nend to end. All\nright, so let's keep\nin mind everything we've\ndone so far. We've\ngot class one agentics\non that first layer,\nprompts, sub agents, skills,\nclosed loop prompts, prompt\nchains. It's all under\nthat first layer and\nwe're just scaling that\nup over and over\nsolving different problems. And\nthen we have our\nindividual application layers. So\nwe have our front\nend application, our back\nend application. All right,\nand this simple example,\nof course, in your\ncodebase and in\ncodebases, I operate\nthis shape is going\nto look very different\nbased on where you\nare, right? You might\nhave a lot of\nKorean squares missing. You\nmight have a lot\nof things that you\nshould or need to\nbuild out on your\nroadmap, but that's the\nwhole point of this,\nright? So you can\nidentify what's your class,\nwhat's your grade, and\nhow can you move\nforward, all right? So\nclass two, grade two\nis huge because we\nnow have AI developer\nworkflows. As mentioned, this\nis the highest leverage\npoint of Agentic Coding.\nWhy is that? It's\nbecause you get deterministic\ncode plus non-deterministic agents.\nYou get the best\nof both worlds. You\nget full control in\nbetween each agent step,\nright? We're talking logging,\nvalidation, retries. You get\nto track everything, right?\nYou know, this, let\nme be super clear.\nThis is how this\nmulti-agent AI developer workflow\nis running. Instead of\nyour AI developer workflows,\nyou can use anything\nto omit to your\nfront end, right? I\nlike to use WebSockets\nfor this. You can\npull, you can do\nwhatever. In TAC, we\nlooked at returning comments,\nreturning updates to the\nGitHub issue. You can\ndo this to your\nGitHub PR. A lot\nof cloud-based Outloop agentic\nsystems, they already do\nthat. Instead of ADWs,\nwe now have our\nagentic workflows. Now this\nis massive. This is\nwhere you're going to\nget massive, massive value.\nEngineers that reach this\npoint will be closer\nto anyone to the\ncodebase singularity and\nto truly controlling their\ncodebase from anywhere\nwith the highest capability\nbecause they know their\nagents perspective. They know\nwhat will happen when\nthey run these workflows.\nWhat do these concretely\nlook like? We've already\nlooked at these in\nTAC, but we have\nraw code that just\nruns the agents directly.\nAnd then surrounding it,\nwe have whatever deterministic\ncode, whatever logging, whatever\nto rule them all.\nNow, In this level,\nwe of course have\neverything we had before,\nevery grade, every class\nstacks. We have our\ntwo back and front\nends. You might have\nadditional codebases, right?\nYou could have four\nGit sub module code\nbases here. You might\nhave six, right? It\ndoesn't matter. As long\nas your agents can\nsee everything, as long\nas your agents have\nfull visibility and can\ntap into every code\nbase, into every file\nit needs. That's what\nmatters. We of course\nhave our class one\nagentics on that first\nlayer and our class\ntwo agentics on that\nsecond layer. Now we\nmove to the orchestrator\nlevel and it's quite\nsimple. There will be\nalmost no changes here\nexcept for this. Inside\nof your application or\nin a dedicated directory\ninside your ADW's directory,\nyou will have an\norchestrator. Now it is\nnot clear how to\nbest build this or\nwhere exactly to place\nthis. I have built\nversions where I have\nthe orchestrator in its\nown application. It then\nreferences the ADWs. And\nthis is how this\napplication is running. So\nwe have a nested\napplication. that references the\nagentic layer. This is\nokay, it's messy and\nthere's a lot of\ncode reuse, but you\ncan also place this\ndirectly inside the ADWs.\nYou can make this\nentire application and this\nis where things really\nrequire great engineering, okay?\nIt gets so hard\nto maintain all of\nthis and to orchestrate\nyour orchestrator agent running\nother agents, but the\nimpact here is absurd.\nIt's absurd. Okay, so\nlet's talk about this,\nright? So what is\nthis exactly? what we've\ntalked about in our\nmulti-agent orchestration lesson, okay?\nThis is a version\nof this, right? This,\nyou know, to be\nsuper concrete, what we\nhave here is a\nworking version of that\nexactly. We control our\nslash commands from here.\nWe can reuse sub-agents\nand build them into\nconcrete primary agents, right,\ncommand level agents. We\ncan see our existing\nagents, fixer, reviewer, builder,\nand we can see\nour orchestrator tools. Our\norchestrator agent is a\ncustom agent, right? Everything\ncomes back to the\ncore four and your\nability to scale your\nagents from a base\nagent to a better\nagent, to more agents,\nto custom agents, and\nthen ultimately to the\norchestrator agent, okay? This\npipeline runs alongside you\nbuilding out your agentic\nlayer. And the orchestrator\nagent itself represents the\ntransition to a class\nthree agentic layer. You\nhave all these prompts,\nsub-agents, skills, these powerful\nleverage points of agentic\ncoding. You have these\nprompts, prompt chains, all\nthese skills that you\ncan stack and compose,\ndifferent MCP servers that\nsome agents work with\nwhile others don't need\nto, tons of sub-agents\nto parallelize and scale\nyour compute. There's gonna\nbe a point where\nthe orchestrator agent is\nthe solution to controlling\nand best managing your\nagents, right? And all\nof your agentics, okay?\nSo what you're effectively\ndoing here is building\na custom agent that\nis a lead engineer\nthat can CRUD command\nand manage other agents,\nright? It's running CRUD\non agents. This gives\nyou centralized control over\nyour agentic layer. This\nalso operates as your\nOutloop system. Now, to\nbe super clear, you\ncan have both and\nyour orchestrator agent can\nin fact just be\nin the terminal, right?\nThis can be in\nthe loop, but the\nbest version of this\nwill be an Outloop\nsystem that again, you\ncan customize and fine\ntune. You can build\nprompts and agents and\nskills highly specialized for\nyour codebase. So\nthis is ultra powerful,\nright? Of course, the\ntrade-off here is the\nsame as it always\nis. You will need\nto maintain this It\nis hard to build\nand it requires experience\nand skills above the\nrest of the pack.\nIf you push through\nthis, if you do\nthis, you'll be rewarded\nfor it. All right.\nno feeling like talking\nto an orchestrator agent\nthat understands your problem.\nI use working versions\nof this specialized in\nproduction codebases I\nhave, and it is\nlike nothing else. When\nyou truly customize an\norchestrator that understands your\nagent experts, your AI\ndeveloper workflows, and they\ncan just chain together\nand conduct, right, and\na prompt chain or\nan AI developer workflow,\nbut you can do\nvery, very interesting, complex\nthings because now you're\nprompting a orchestrator that\nunderstands your agents, your\nprompts, your skills that\nthen prompts and communicates\nback and forth with\nyour command level agents.\nSo there are very,\nvery powerful workflows that\ncan occur here. Because\nnow you have, again,\nwe have this multi-level\nconversation happening, getting work\ndone with multiple teams.\nSo your orchestrator agent\ncan spin up, as\nyou saw here, multiple\nteams of agents focused\non multiple problems. We\ndon't want to violate\ntactic six at this\nlevel of scale. Things\njust get too complex.\nYou want to have\none agent with one\nprompt solving one problem.\nOne agent, one prompt,\none purpose. So the\nplanner agent just planned.\nWe can dial into\nany one of its\nlogs. We can see\nwhat it was thinking.\nWe can see the\nsummary. Every event, every\nindividual event here is\ngetting summarized by a\nsummary agent. then we'll\nreport it back to\nus. We can dial\ninto the main details\nif we want to,\nwe can fire off\nsystem logs, right? That's\nall well and good,\nright? We need peer\nobservability so we can\nunderstand what happened completely.\nYour Orchristian developer workflows\nare very powerful because\nit creates an open\nstream of communication. These\nagents, we can now\ntalk to any one\nof these agents from\nthis workflow at any\ntime, okay? And we\ncan continue, we can\nask them questions, we\ncan continue to push\non these workflows, okay?\nAnd to be clear,\nyou know, these ran\nan AI developer workflow,\nnot an orchestrator developer\nworkflow. Okay, the orchestrator\njust fired this off\nand walked away, okay?\nAnd why is that?\nIt's because this is\nvery powerful, but here\nwe're relying on non-deterministic\nsystems for these large,\nmassive chains, these huge\njobs, right? The last\npiece to our class\nthree, grade three system\nis this. It is\nmaybe what you would\nexpect. It's the highest\nleverage point of agenda\ncoding once again, okay?\nAI developer workflow plan\nbuild. The big difference\nbetween our orchestrator developer\nworkflows is that this\ncan use raw code,\nokay? You know that\nI am ultra agent\nforward, but none of\nit matters if we\ncan't track it, observe\nit, control it and\nmake sure that it's\nall running properly by\ngiving our orchestrator the\nability to run AI\ndeveloper workflows. We now\nreach the final stage\nand we reach something\nlike this. Some user\ninterface like this, some\nprocess like this, some\ncodebase like this.\nThis codebase will\nbe available to you.\nThis is my final\ngift to you here\nin Agentic Horizon. So\nyou can understand how\nyou can build out\nsomething like this. This\nis just a vision.\nIt's an example, right?\nWe now have both\nthe log stream view\nand we have the\nADW's view so you\ncan see these full\nend to end pipelines\nwhere we move closer\nand closer towards zero\ntouch engineering and the\ncodebase singularity. Okay.\nThis is the final\nlevel. This is class\nthree, grade three. We\nhave now given our\norchestrator agent everything it\nneeds to run our\ncodebase, right? And\nthe big piece where\nwe can have high\ntrust in this system\nis through our AI\ndeveloper workflow, right? So\njust imagine you have\ntons of these that\ndo entire workflows, right?\nYou've built out different\ntriggers, you've improved your\nmodules, right? We have\ntons of prompts now.\nAnd this is of\ncourse, it's just an\nexample codebase, right?\nThis is where you\nreally can scale your\ncompute to scale your\nimpact super hard because\nyou have so many\ntools at your disposal,\nall controlled and guided\nby an orchestrator agent,\na custom agent that\nyou've taught how to\nrun your codebase.\nStar of Agentic Horizon.\nYou wanna push your\nagents to engineer like\nyou can and better\nthan you can, all\nright? So let's boil\nthis all back down.\nWhat has happened? What\nhave we learned in\nTactical Agentic Coding and\nAgentic Horizon? First, we\nstop coding. Use the\nbest tool for the\njob, agents. If you're\nstill writing code by\nhand, you will not\nget to any sufficiently\ncomplex level of your\nagentic layer. You must\nadopt your agent's perspective.\nThink as your agents\nwould and give them\nthe leverage points it\nneeds to ship. Imagine\nyou are your agent\nright before you hit\nenter, right before you\npass in that context\nwith this information, could\nyou solve the problem\nyou're going to ask\nyour agent to solve?\nThis is critical for\nknowing how to build\nout teams of agents,\nright? Template your engineering.\nIf you cannot encode\nwhat you would do\ninto your prompts, into\nyour plans to create\nthese templates, you will\nnot get repeated agentic\nsuccess because your agents\nwill jump off ship,\nit'll do random things.\nThese are non-deterministic. No\nmatter how good they\nget, these models will\nchange in nature. When\nyou template your engineering,\nyou're giving your roadmap\nto success. You're giving\nyour engineering best practices,\nright? You're saying this\nis how we solve\nbugs, this is how\nwe build out API\nendpoints, This is how\nwe integrate with this\nservice. This is how\nwe do X, Y,\nZ. And you teach\nyour agents to do\nthat. You must template\nyour engineering into your\nagentics. Next, we stay\nout the loop. Once\nyou start scaling up\nthese agentic workflows also\nknown as prompt chains,\nand you start building\nout these great skills\nand great sub-agents, it's\ntime to get out\nthe loop. This forces\nyou to build the\nsystem that builds the\nsystem. You want agents\nthat can run while\nyou're not there. You\nwill not scale your\nagentic layer if you\nare stuck in the\nterminal prompting back and\nforth and back and\nforth. You must stay\nout the loop. Tactic\nfive. Always add feedback\nloops. If your agents\nare causing bugs, they're\nnot working properly in\nyour system, you probably\njust haven't given them\nthe right tools to\nreflect on their work\nand make correction. Use\nclosed loop prompts to\nhave your agents validate\ntheir own work. More\ncompute should equal more\ntrust, not less. If\nit's less, you're doing\nsomething wrong. Request, validate,\nresolve. Now, one of\nthe most important tactics\nof all, you wanna\nbe building one agent\nwith one prompt one\npurpose. Why? Because a\nfocused agent is a\nperformant agent. It's the\nexact same thing for\nyou and I. If\nyou have multiple tasks,\nif you're feeling scattered,\nif you keep context\nswitching, you will make\nmistakes. This effect is\nexaggerated in our agents\nbecause they have limited\ncontext windows. There are\ntwo problems in there\nand the chance they\naccomplish both go down.\nThere are just one,\nmake it super clear\nand be precise with\nyour details. And it\nwill very, very likely,\nin fact, it will\nhave the highest chance\nof accomplishing that one\ntask. Okay. With the\norchestrator agent, we can\ndo this better than\never because you just\nspin up agents when\nagents deployed into applications.\nThis is how you\nbuild the orchestrator. If\nyou don't know how\nto build custom agents,\nyou're at a massive\ndisadvantage for not just\ncode-based specialized agents like\nthe orchestrator, but for\nall types of product-focused\nagents, all right? Then\nwe looked at multi-agent\norchestration, the next paradigm\nof Agentic Coding. First\nyou're in the terminal,\nthen you get out\nthe terminal, you're running\nyour agents and your\nteams of agents from\nan external service, and\nthen you build a\nmanager of your agents\nthat then you run\nagainst, all right? Multi-agent\nis the future of\nagents. There's no way\nto accomplish the amount\nof work we need\nto accomplish without multiple\nagents, so why not\nteach a specialized agent\nhow to run your\nsystems? And then finally,\nwe looked at agent\nmanagement. experts. This is\nthe most slept on,\nhighest return on investment\nopportunity for engineers. You\ncan build experts into\ncustom agents. You can\nbuild them programmatically. You\ncan customize the system\nprompt, all the tools,\nyour user prompts to\nbuild a specialized agent\nthat solves one problem\nextraordinarily well. This is\nthe future of product\nand codebases with\nagents. They are experts.\nThey do one thing\nvery well. Okay, all\n13 lessons are now\navailable to you. You\nhave access to these.\nPlease rewatch these. These\nare not one-shot videos.\nI built these to\nstand the test of\ntime. These are the\ntactics and the skills\nthat you'll need to\nwin in the age\nof agents. Everything comes\ndown to this. In\nthe beginning, we set\nout to become an\nirreplaceable engineer in phase\ntwo. The phase of\nagents is the phase\nof Agentic Coding. It's\nthe phase of agentic\nengineering. We are now\ncommanders of compute. We're\nusing teams of agents\nto accomplish work on\nour behalf. our agents\nhow to build like\nwe can, and then\nwe scale it. We\ngo from base to\nbetter, to more, to\ncustom, to an orchestrator\nthat runs it all\nfor us. We've painted\na complete vision of\nwhat this looks like.\nWe've shared code, we've\nshared ideas. It's been\nincredible. building this for\nyou over the past\ncouple years. Thank you\nso much for trusting\nme. It takes so\nmuch effort to build\nout these ideas, right,\nto synthesize it and\nto really make it\nsomething that I can\nshare is, it's extremely\nchallenging. And then to\ntrust someone to deliver\non these ideas is\na risk that you\ntook. So I want\nto really thank you\nand appreciate you here.\nI want you to\ntake these ideas and\nwin. I am always\ntrying to boil down\nmost powerful ideas for\nengineers into their atoms\nand just hand them\nto you and say\nsolve your problems build\nyour company deliver value\nto your users because\nthat's what it's all\nabout this is engineering\ntools will change models\nwill improve we know\nthis there will be\nconstant endless change but\nwhat you have now\nthe tactics of agentic\ncoding and all the\nskills and key ideas\nfrom Agentic Horizon. And\nI'm going to record\nthe entire process end\nto end. The process\nof building a valuable\nfour to five figure\nper month business that\nruns agents. This is\ngoing to push me\nto my very limits.\nI don't know if\nI'll succeed. I might\nhire a small team\nto help me accomplish\nthis, but ultimately I\nwant to take on\nthis challenge to prove\nto myself and to\nprove to you, the\nengineer, what you can\nreally do with this\ntechnology. I want to\nshowcase that if you\ninvest in the right\nplaces and the right\npeople and the right\nideas that you can\ntruly increase your engineering\nability by orders of\nmagnitude. So if I'm\nsuccessful here, you, other\nAgentic Horizon members will\nbe the first to\nknow and this is\nsomething that i might\npotentially roll into the\nnext course if i\nfail i am not\ngoing to be building\nanother course i am\nnot going to be\nputting out another product\non my own probably\nfor some time the\nstakes are here the\npressure's on and i\ncan't wait to create\nthe future where i\ncan share the next\ngeneration ideas of agentic\nengineering with you where\nwhat a single engineer\ncan do is no\nlonger limited. If I'm\nsuccessful, you'll be the\nfirst to know. Once\nagain, at the end\nof the road here,\nI want to thank\nyou for trusting me.\nI'll see you on\nthe channel. We'll continue\nto push what we\ncan do and maybe\nthere you'll see glimpses\nof what's coming next.\nI want to make\nthis super clear. If\nyou take the ideas\nfrom TAC and AH\nand apply them, really\nput them to work.\nIf you trust me\none more time, If\nyou do this right,\nit will change everything.",
  "summary": "The final lesson combines all ideas from Tactical Agentic Coding and Agentic Horizon toward one singular moment: The Codebase Singularity. This is the moment when you realize your agents can run your codebase better than you can - nothing ships to production without your teams of agents. The agentic layer is the new ring around your codebase where you teach agents to operate your application on your behalf. The lesson recaps all tactics: Stop Coding, Adopt Your Agents Perspective, Template Your Engineering, Stay Out The Loop, Close The Loops, One Agent One Prompt One Purpose, Scale Your Agents, and Focus on The Agentic Layer. The orchestrator agent controls and guides all tools - a custom agent youve taught how to run your codebase.",
  "key_concepts": "1. THE CODEBASE SINGULARITY: The singular moment when you realize your agents can run your codebase better than you can. Nothing ships to production without your teams of agents.\n\n2. THE AGENTIC LAYER: The most important idea from TAC. The new ring around your codebase where you teach agents to operate your application on your behalf - as well or better than you.\n\n3. TRUST YOUR AGENTS: The key question - do you trust your agents to ship more than you trust yourself or your team? Building toward this trust is the goal.\n\n4. RECAP - STOP CODING: Use the best tool for the job - agents. If youre still writing code by hand, you will not reach sufficient complexity in your agentic layer.\n\n5. RECAP - ADOPT YOUR AGENTS PERSPECTIVE: Think as your agents would. Before hitting enter, ask yourself: with this context, could YOU solve the problem?\n\n6. RECAP - TEMPLATE YOUR ENGINEERING: Encode what you would do into reusable prompts and templates. If you cannot encode it, your agents cannot learn it.\n\n7. BUILDING AGENTIC LAYERS: Bridge the gap between where you are and the codebase singularity. Think through what it would take to trust your agents completely.\n\n8. ORCHESTRATOR AS GUIDE: The orchestrator agent controls and guides all tools - a custom agent youve taught how to run your codebase.\n\n9. TEAMS OF AGENTS: Build teams of specialized agents that work together. Each agent handles its domain while the orchestrator coordinates.\n\n10. THE AGENTIC HORIZON: The future where sufficiently powerful agentic layers mean your codebase runs itself. Investing early in agents opens doors while closing others."
}