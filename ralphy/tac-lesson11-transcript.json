{
  "video_id": "building-domain-specific-agents",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/building-domain-specific-agents",
  "title": "Building Domain-Specific Agents",
  "channel": "Agentic Engineer",
  "duration": 3900,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T04:15:46.513Z",
  "transcript": "Agentic engineering leads every\nengineer down one single\npath. Better agents, more\nagents, and then custom\nagents. If you can\nprompt engineer and context\nengineer a single agent\nsuccessfully, then the next\nstep is to add\nmore agents. Scale your\ncompute to scale your\nimpact. Then once you\nlearn to delegate work\nto sub agents and\nnew primary agents, there's\nonly one place left\nto go, custom agents.\nBut why? Isn't Claude\nCode, Codex CLI, the\nGemini CLI enough. The\nout-of-the-box agents are incredible,\nbut there's a massive\nproblem with these tools.\nThey're built for everyone's\ncodebase, not yours. This\nmismatch can cost you\nhundreds of hours and\nmillions of tokens, scaling\nas your codebase grows.\nThis lesson is about\nflipping that equation. Here,\nwe master custom agents\nso your compute works\nfor your domain, your\nproblems, your edge cases.\nThis is where all\nthe alpha is in\nengineering. It's in the\nhard specific problems that\nmost engineers and most\nagents can't solve out\nof the box. You\ncan't walk up to\nthese problems and solve\nthem without unique domain\nknowledge. And custom agents\nlet you pass your\ndomain specific unique knowledge\nright to your agents.\nCustom agents let you\ndo a few special\nthings. You can take\nthe core four context,\nmodel, prompt, and tools\nand scale them beyond\nthe defaults. You can\nsolve domain specific problems\nwith targeted repeatable workflows.\nCustom agents also let\nyou protect protect your\ncodebase, protect your\nassets, and protect other\nengineers from agents calling\nthe wrong tools at\nthe wrong time. Ultimately,\ncustom agents let you\ntake two tactics of\nAgentic Coding to their\nlimit. They let you\ntemplate your engineering, directly\ninto your agent and\nthey push the one\nagent, one prompt, one\npurpose tactic to its\nlimits. And sometimes it's\nnot about building 100%\ncustom agents at all.\nBy knowing how to\nuse programmatic agents like\nthe ClaudeCode SDK, you\ncan deploy out of\nthe box agents like\nClaudeCode programmatically and just\nmake a few tweaks\nso that it performs\nbetter for your use\ncase. You don't always\nhave to reinvent the\nagent from zero. In\nthis advanced lesson and\nwe showcase eight unique\ncustom agents built on\nthe Claude Code SDK,\neach one showing you\nhow to deploy across\nyour stack, products, and\nengineering lifecycle. The agents\nare on the horizon.\nIt's time to master\nagents by going all\nthe way to the\nbare metal, to the\ncustom agent, so you\ncan scale your compute\nfar beyond the rest.\nAs usual, we're gonna\nstart simple and progress\nthrough more capable agents\nstep-by-step so you can\nunderstand how to build\nthese from zero. In\nthe building specialized agents\ncodebase, inside of\napps, you can see\neight custom agents. We're\ngonna break down. Some\nof these have multiple\nagents embedded within each.\nLet's start simple with\nthe Pong agent. So\nhere's a simple agent\nthat's gonna showcase the\nmost important aspect of\ncustom agents. You can\nsee we have a\nsimple, concise user prompt\nand agent response, and\nwe have some session\nstats. Let's run this\nagain, all right? Let's\ngo ahead and change\nour prompt. Hello, simple\nprompt. We're just getting\nstarted with custom agents.\nI said hello, it\njust responded with Pong,\nokay? Summarize this code\nbase. Okay, there's my\nuser prompt. And once\nagain, the Pong agent\nis responding again with\nPong. What's going on\nhere? Let's ask it\nwhat's happening. Can you\ndo anything other than\nPong? Okay, there's a\nuser prompt and okay.\nSo all this agent\ndoes is Pong. type\none more here. I'm\njust going to write\nking. This silly agent\nencapsulates the most important\nconcept when you're building\ncustom agents. No matter\nwhat we prompt here,\nthe response is always\npong. Why is that?\nLet's dive into this\nfile. So the first\nmost important concept is\nnone other than the\nsystem prompt. We are\nusing the Claude Code\nSDK and we're setting\nup only two things.\nWe're modifying just two\naspects of this agent,\nbut it changes everything.\nSo you can see\nCloud4Sonnet and here the\nsystem prompt. So let's\nopen up the system\nprompt. You can see\nwe have this dedicated\nload system prompt method.\nThere's the path to\nthe prompt. Let's open\nit. We have completely\noverwritten the Claude Code\nsystem prompt with this\ntitle of our agent\npurpose. And we have\na simple three line\ninstruction. You are a\nPong agent, always respond\nexactly with Pong. That's\nit. The system prompt\nis the most important\nelement of your custom\nagents. with zero exceptions.\nWe are modifying the\ncore for specifically the\nprompt. But now we\nhave two very important\nprompts to pay attention\nto, system prompts and\nuser prompts. The system\nprompt affects every single\nuser prompt the agent\nruns every single one.\nSo all of your\nwork is multiplied by\nyour system prompt. So\nhow does the Cloud\nCode SDK work? Let's\ngo ahead and break\ndown the key ideas.\nThe SDK works like\nthis. You set up\nyour options, you set\nup your agent. Here\nwe're just running the\nquery and then you\nhandle the response. The\nClaude Code SDK is\na powerful tool for\nputting together agents. As\nyou'll see, as we\nprogress, all the pieces\nare there and they're\nincrementally adoptable. And then\nlastly, we're just doing\nsome logging. That's it.\nof our agent, right?\nA simple 150 line\nPong agent. Most of\nthis is just logging.\nWe're setting up the\nagent. We're then querying\nthe agent, we're then\nhandling the response of\nthe agent. And take\nnote of these specific\nblocks that you can\nreport. We have our\nagent message blocks, we\nhave a result message,\nand you can parse\nspecific information out of\nthese as you'll see\nas we progress. But\nthis is the Pong\nagent, and this showcases\nthe power of the\nsystem prompt. Remember, all\nthat work that the\nClaude Code team has\nput into making a\ngreat agent, right? The\nClaude Code agent that\nyou know and love\nis now gone. Okay,\nyou have to be\nvery careful with the\nsystem prompt. We now\nhave a new product.\nThis is not clog\ncode anymore. Okay, might\nbe using the same\nmodel, but the system\nprompt is truly what\nbuilds the agent. Now,\nof course, we are\nstill using the tools.\nThat's important to call\nit here. As you'll\nsee, as we progress\ninto more and more\ncapable custom agents, let's\nmove on to our\nsecond agent, the Echo\nagent. Inside of our\necho agent, you can\nsee a similar structure.\nWe have a single\nPython script here that\nwe're gonna execute, uv\nrun echo agent py.\nAnd we're gonna see\na similar structure, right?\nWe have our echo\nagent kicking off, user\nprompt, agent response, but\nhere we have something\ndifferent. Here we have,\nof course, a custom\ntool. So our agent\nis saying, I'll use\nthis tool, and then\nwe have this tool\ncall block here, and\nthen we have the\nresponse of the tool\ncall, and then our\nagent response, right? So\nthese are all unique\nelements coming out of\nour agent. You wanna\nbe keeping track of\nthese, right? Keep track\nof the core four.\nIf you understand the\ncore four and how\neach element flows and\ncontrols your agent, you\nwill understand compute and\nyou'll understand how to\nscale your compute. Let's\ngo ahead and echo\nourselves. So I'm gonna\nsay echo this string\nand then I want\nit in reverse in\nuppercase. Repeat two times.\nHere we're just playing\nwith the tool that\nour custom agent has.\nAll right, so there's\nthe user prompt, there's\nthat call. In reverse,\nthis text comes out\nto custom agents are\npowerful. We ask it\nto repeat. repeat and\ngo uppercase. So that's\nexactly what our agent\nhas done. Okay. We're\nscaling up a little\nmore. We're adding a\nfew more capabilities to\nour agent as we\nexplore custom agents. Let's\nunderstand what's going on\nhere in the echo\nagent, same structure. I\nalways love collapsing everything.\nAnd you can just\nquickly understand what's going\non. We have main,\nwe have a tool\nand we have our\nsystem prompt. Always look\nfor the system prompt\nand then look for\nthe custom tools. We\nhave a couple of\nparameters here. Then we\nhave something special. So\nonce again, you can\nalways just search cloud\ncode options. We have\nan MCP server built\nin this script, create\nSDK MCP server, and\nwe're passing in a\nsingle tool. So this\nbuilds an entire MCP\nserver in memory for\nour agent. This is\nsuper powerful. So let's\nlook at our echo\ntool and understand what\nit does. Tools for\nyour Claude Code SDK,\nthey're built like this,\na decorator. We then\nhave the name, we\nhave the description, So\nkeep in mind, The\ndescription of your tool\ntells your agent how\nto use it in\naddition to the actual\nparameters that get passed\ninto your tool. In\nthe actual arguments, you\njust pass in a\ndict and then you\ndo whatever you want\na simple agent. It\ndoesn't need powerful intelligence.\nSo we've dropped down\nthe model. As you\nprogress through each agent,\nkeep in mind, we\nhave the 12 leverage\npoints of agentic coding\nthat we're paying attention\nto. But whenever you\nsee Claude Code options,\nisolate the core four.\nHow will the core\nfour be managed given\nthis setup? Now we\nhave something else here\nthat's important to call\nout. We're using the\nClaude SDK client class\ninstead of our pong\nagent where we were\njust using that query\ncommand. All right. So\nquery is for one\noff prompts and the\nClaude SDK client is\nfor continuous conversations. Let\nme show you exactly\nwhat I mean here.\nLet's clear this and\nlet's run this once\nagain with follow up.\nSo if we kick\nthis off, our agent\nis going to run\nthat same prompt like\nnormal, but then it's\ngoing to continue the\nconversation. We're going to\npass in another follow\nup prompt, I'm gonna\nsay concisely summarize our\nconversation in bullet points.\nAnd so here it\nis, right? Our agent\nquickly responds, follow up\nresponse, concise summary, one,\ntwo, three, four. Our\nagent has kept track\nof the conversation because\nwe're using the Claude\nSDK client and because\nwe've written multiple query\ncalls. You can see\nwe have two here,\nfollow up prompt and\nthe original user prompt,\nall right? So we\nhave both the tool\nuse block that we\ncare about and we\nhave the text block.\nYou can stream all\nthe messages coming back\nout from your agent\nafter you query and\njust take them in,\nright? Take them in,\ndo whatever you want\nwith them. Here, of\ncourse, we're just logging\nwith clean, rich panels,\nconcisely communicating what's happening\nwith our agent. If\nyou don't know what\nyour agent is doing,\nif you don't adopt\nyour agent's perspective, it\nwill be hard to\nimprove them and tweak\nthem and manage them.\nSo that's what we're\ndoing here. And you\ncan see the followup\nprompt. We fired off\nthat additional query. and\nwe just looked for\nthat one response, right?\nWe're looking for a\ntool use block and\nreally we only were\nlooking for the text\nblock here, right? This\nis not actually that\nuseful. This is a\ncustomization with a few\nmore capabilities, right? We've\nspecified the model, we've\ngiven it a custom\ntool to work with,\nbut here's something interesting\nthat if you're using\nthese agents left and\nright, you probably haven't\nbeen paying attention to.\nIf we run this\nsame agent and we\njust drop everything down\nhere and we just\nsay list your available\ntools. we are actually\nstill running a lot\nof the Claude code\nbaked in tool set.\nSo check this out,\nright? These are all\nthe Claude code tools\nplus our tool. And\nso everything that's going\ninto your agent winds\nup in the context\nwindow at some point.\nWe have 15 extra\ntools, 15 extra options\nthat our agent has\nto choose from and\nselect to do the\njob we've asked it.\nNow our Echo agent,\ndoes not need any\nof these tools. All\nright. And so as\nwe progress, we're going\nto find to and\nwe're going to get\nmore control over our\nagent. If you ever\nrun the slash context\ncommander, understand what's going\ninto your agent. You\nknow that these 15\ntools consumes context. It\nconsumes space in your\nagent's mind. We're going\nto learn how to\ncontrol that knob in\nour next agent. The\nlast thing we want\nto point out here\nis our echo system\nprompt. Okay. Very simple.\ntool names only. Okay.\nSo these are the\ntools, the only tools\nthis agent has. So\nin contrast, to our\nEcho agent, our calculator\nagent only has these\ntwo tools, okay? This\nis a fine-grained focused\nagent. Very clearly you\ncan see we have\na different agent experience,\nwe have a different\nagent interface. Okay. Before\nwe were running scripts\nthroughout tack, we ran\n80 W's, which are\nscripts in our new\nagentic layer. That's great\nfor true engineering workflows.\nMost agents for engineers\nwill be deployed in\na script somewhere, but\nyou can also use\nagents in terminal UIs,\nright? You can build\nup your own personalized\nversion of really any\nterminal based application. And\nthen of course, as\nwe'll progress, you can\nbuild up full agents\nas backend methods and\nas data streamers and\ndata Anyway, let's focus\nhere, calculator agent. Let's\ndo some calculations, right?\n55 Fahrenheit to Celsius.\nSo we have the\nconverter here. It is\nconverted that for us,\nright? So user prompt\ncame in, we called\nthe tool right away\nand the agent has\nresponded to us, right?\nTwo decimal places, looks\ngreat. 125 meters to\nmillimeters. Again, using that\ncustom converter there, it's\nbeing very concise with\nits response. It's just\ngiving me the answer\nI'm looking for, right?\nA fine-tuned calculator agent.\nI know, still simple,\nbut we're working working\nup to more complexity,\nstacking it on. I\nwant you to understand\nthe primitives. Primitive understanding\nis critical for scaling\nup what you can\ndo. Don't start with\nbig things, start with\nsmall things, right? Everything\nlarge is a few\nsmall things that you\nunderstand fundamentally first. Okay,\ngreat, so we have\nthis tool called, let's\nrun the other tool,\nright? This is just\nour unit converter. Let's\nrun something like this,\nright? Best deal, 500K\nhome at 5% or\n600K at 4%. It's\ngonna take a little\nbit more thought here\nfrom our agent. So\nlet's see what it\ndoes here. Agent response,\nthere's a tool call.\nHere's another tool call.\nRunning it again over\n30 years, you'd save\nXYZ, approximately save XYZ\nwith the home at\n500K at 5% interest,\nokay? Again, just showcasing\na simple example in\nagent, fine-tuned, customized to\ndo one thing very\nwell. Let's break down\nthis agent, all right?\nCalc agent. You can\nsee a couple things\nright away. I'm already\nat the sweet spot\nhere. Cloud code options.\nWe have our built-in\nMCP server with our\nspecific allowed but the\nmost important part here\nis this. At the\nbeginning we ran list\nall tools, it only\nhad our two tools,\nright? We can keep\nasking, right? List available\ntools, again, function name,\nand params only. So\nour agent is going\nto think a little\nbit and give us\nthis response. There it\nis. There is our\nexact tools. Okay. So\nyou can see here\nwe have this big\ndisallow tools block. Our\nagent is specifically not\nallowed to use these\ntools. These tools do\nnot end up in\nits context window. Very\nimportant. This is not\nan option, right? There's\nno read option for\nit anymore. They can't\nsee this. Okay. You\nalways have to adopt\nyour agent's perspective. The\nClaude Code options is\nhow you understand your\nagents core for minus\nthe user prompt, right?\nThe user prompt comes\nin via our client\ndot query. All right.\nAnd of course here\nwe are focused on\nthe Claude Code SDK.\nEvery other agent SDK\nwill have some version\nof this. All right.\nSo yes, We are\nbig Claude Code fans\nand yes, we will\nalways use the best\ntool for the job\nand we think bigger\nthan single tools, right?\nThis is not about\na single tool. This\nis about the best\ntool for the job\nand understanding agents and\ncustom agents at large,\nserver. And these are,\nof course, our only\nallowed tools. Now, we\nare using the powerful\nCloudForce Sonnet. If you're\noperating in the future,\nhopefully you have something\nmore powerful, but don't\nlet these models fool\nyou. It's not the\nmodels that are the\nlimitation, the bottleneck anymore.\nIt's you and I.\nIt's our ability to\nwield better agents, more\nagents, and now custom\nagents. Okay, we have\nthis new current session\nID. This is important.\nLet's go ahead and\nunderstand how this works.\nAnd just to mention\nit again, right? Same\nworkflow. You set up\nyour options with the\nClaude Code options. This\nbasically configures your core\nfor you then set\nup the SDK. So\nwe're mounting the agent\nwith the options and\nthen you run your\nprompt. You then manage\nthe responses. Your agent\nis going to do\nwork for you. Do\nyou know what it\nis? You know this\nby managing its responses.\nAll right. So you\ncan see here we\nhave two unique messages,\nassistant message and result\nmessage. Now, these might\nchange. in the future,\nright? It's very likely\nthese change. The key\nidea is that you\nunderstand how to manage\nthe primitives of your\ncustom agent. If we\nlook at this, our\nresult message is giving\nus session ID or\nwe can get our\ntotal costs here. This\nis just information on\nthe message when you're\noperating a result message,\nokay? And so we\nuse this to continue\nthe session. Right. And\nthat's what this resume\nparameter does. So we\ncan just keep prompting\nback and forth. We\nhave our own micro\nagent that we can\nchat to in the\nterminal over and over\nand over. Okay. So\nthis is a form\nfactor you can use.\nOf course, after you\nfinish this lesson, everything\nis going to be\navailable to you in\nthis codebase. It's\ngoing to help you\nquick start building your\nown custom agents and\nunderstanding what you can\ndo with custom agents.\nAll right. So this\nis great. It's also\nreally important to call\nout these SDKs, specifically\nthe Claude Code SDK.\nIt has built in\nprompt caching. So you\nwill be saving money.\nby using this out\nof the box, right?\nBy just tuning and\ntweaking your custom agent\nwith the Claude Code\nSDK. Let's scale up.\nLet's move on to\nmore capable agents and\nlook at an interesting\nand on-tapped use case\nof agents. Next we\nhave our social hype\nagent. We're starting to\nbuild up a more\ninteresting, more complex, kind\nof built out code\nbase. We're adding complexity\nas we add capabilities\nto our agent. Let's\njust go ahead and\nkick this off and\nunderstand how this works.\nUVR, social hype agent.\nWe're gonna kick off\nour social hype agent\nand notice here we're\npassing in keywords and\nthen we're going to\nrun this dash n\nwhich is a notification\nprompt any mention of\nnew language model releases\nany mention of hacking\nprompting or educational posts\nsurrounding these companies okay\nlet's fire this off\nand let's understand what's\nhappening here so this\nis not a terminal\ninterface this is not\na script this is\na stream handler so\nwe're looking at the\nblue sky fire hose\nweb socket it's blasting\nout events to this\nservice from this web\nsocket and then we're\nlooking for specific keywords.\nThis is just a\nterminus of code, right?\nThat's not new. That's\nnot interesting. This is\na simple string contains\ncheck, but what is\ninteresting here, our agent\nis now going to\npick up the keywords\nand then run a\nsentiment analysis. So check\nthis out. Claude Code,\nintegration news, Zencoder adding\nsupport for Claude Code\nand other CLI coding\nagents. Perfect, okay, right\non topic, right on\ntopic. I was a\nlittle worried when I\nran this, you know,\nduring this lesson that\nwe get some not\nso clean outputs here,\nbut so far so\ngood. New OpenAI tech\nrelease. OpenAI partners with\nJoni Ive on AI\ndevices with ChatGPT for\n2.026 launch. And I'll\njust pause here for\nnow, right? So you\ncan see how the\nsystem works top to\nbottom. That was perfect.\nWe got a couple\nruns, couple executions. and\nwe looked at some\n5,000 messages from this\nWebSocket firehose. All right,\nwhat is our agent\ndoing? You can see\nour worker. And inside\nof our worker, we\nare firing off. We\nshould be able to\nsee that pretty soon\nhere. Queue task, filtering\nthe content. And if\nwe have a match\nkeyword, we increase our\nmatch. We create this\nobject and then we\nput it on a\nqueue. Of course, what\ndoes our queue do?\nYou could guess exactly\nwhat this does. Our\nqueue kicks off. You\nguessed it. If we\nopen up Analyze and\nNotify, we can see\nhere, we have a\nClaude Code SDK client.\nAll right, so you\ncan always just search\nfor these inside this\ncodebases to understand\nwhere your custom agents\nare getting set up.\nSo first things first,\ncheck out the options.\nThis is our custom\nagent that we've built\nfrom scratch to be\na great data analysis\nfor this stream of\ninformation. That's a specific\nuse case, right? A\nspecific problem that we're\nprocessing. What's the system\nprompt, right? All this\nis important, but the\nmost important thing by\nfar is your agent\nsystem prompt. What's the\nlaw that you're your\nagent obeys, what's the\nhigh level objective, what\nis the purpose of\nyour agent that will\naffect every single user\nprompt, right? That's why\nyou always focus here.\nFirst, let's open up\nsocial hype system prompt.\nOnce again, look at\nthe directory structure, nice\nand clean, very consistent.\nWe want consistent code-based\narchitecture for our agents,\nfor ourselves, for our\nteams, all right? Come\nto the prompt. collapse\neverything, we can see\na more built out\nprompt structure. If you've\ntaken the agentic prompt\nengineering extended lesson inside\nof agentic horizon, you\nknow exactly what this\nis and what the\nstructure is and why\nit's valuable. Let's go\nahead and take a\nlook at the purpose\nanalyzing real time process\nstreaming accurate summaries classified,\ndetermine when to warrant\na user notification. Okay,\nso we're just operating\non a live stream\nof data. This is\na data streaming agent\nand we're doing something\nreally cool here inside\nof our system prompt,\nwe're passing in a\nvariable much like our\nuser prompts, but of\ncourse these aren't running\nover and over and\nover. We can't dynamically\nuse this. So the\nmoment we set this\nup, it's locked in,\nwhich is perfect for\nour use case, right?\nAs long as this\nagent runs, I just\nwant it to look\nfor this, okay? And\nso we can encode\nthat in the system\nprompt This is to\nbe clear, a static\nvariable that is dynamically\nupdated, right? This can't\nrun multiple times. It\nruns a single time,\nright? This updates to\nwhatever my prompt was\nat runtime when I\nkick up this agent\nand that's it, right?\nNot to be confused\nwith true dynamic variables\nfor Claude Code, you\nwould run something like\nthis, right? Dollar sign\nargument or dollar sign\none, right? This is\na dynamic variable. Every\ntime the user prompt\nruns, this will get\nupdated. This is not\na user prompt. This\nis a system prompt.\nThis is the law\nfor the agent. always\nrun with this exact\nsame setup. We're going\nto do a quick\nreplace on this. You\ncan just search this\nand see exactly where\nthat's happening. Load system\nprompt. Let's move into\nthis. And then we\nhave that getting templated\nright there. Right? So\nexactly as you would\nexpect inside of our\nutils, we have a\nlittle bit more structure\nin this codebase.\nAll right. We have\na nice set of\ninstructions. All right. So\nwe can just collapse\nat the third level\nhere. And we also\nhave a workflow. Now,\nControversially, we're putting the\nworkflow right inside the\nsystem prompt. Why is\nthat? It's because we\nalways want this agent\nto do the same\nthing over and over,\nokay? So you can\nembed workflows in your\nsystem prompt if you're\nsure that that is\nwhat you want to\nhappen every single time\nyour agent executes, all\nright? The Claude Code\nsystem prompt does not\nhave a workflow like\nthis because it's a\ngeneric multi-purpose engineering agent.\nBut we're building a\nsocial hype agent, right?\nWe have a specific\nuse case, a specific\ndomain problem, and we\nknow the workflow. So\nyou here, but let's\ngo ahead and continue.\nYou can see here,\nwe're not getting any\nnotifications, but our agent\nis processing this one\nmatch item so far\nbecause we saw, looks\nlike we saw a\ncloud here, GPT, right?\nuser message, of course,\nall anonymized. Let's proceed\nto our next powerful\nagent. So what's a\nQA agent? How does\nthis work? What's going\non here? This agent\nkicks things up a\nnotch. Let's go ahead\nand just fire this\nup. UVRQA agent.py. You\ncan see here we\nare back in the\nterminal. We have a\nterminal interface. This agent\nis a specialized agent.\nIt is veering into\nthat advanced context engineering\ncapability. This agent is\nan expert. Check out\nthe elite context engineering\nextended lesson to understand\nagent experts at a\ndeeper level. We have\na simple version of\nan agent expert here.\nLet's break it down.\nThis is a code\nbase question and answer\nsystem. So you can\nimagine this being useful\nfor, of course, understanding\nthe codebase for\ngetting new engineers ramped\nup for performing engineers,\njust understanding how to\nbuild out a new\nfeature. So list all\nyour tools. from your\nsystem prompt. And you\ncan see here we\nhave a new message\ntype. This is the\nsystem message. So we\nhave some really important\ninformation here. You can\nsee all the tools\navailable right away. And\nyou can see our\nMCP server. We are\nalso using the Firecrawl\nMCP server here, right?\nSo this agent is\nconnected to and runs\nthe Firecrawl MCP server.\nSo your custom agents\ncan access MCP servers\njust like your in-loop\nagents can. So you\ncan see here, it's\ngot a nice summary\nof all the tools\nshow in bullets, name\nonly. Check this out.\nWe have 13 tools\nand you can see\nwhich tools specifically are\nenabled for our code-based\nQA agent. task, bash,\nglob, grep, read, some\nweb searching and some\nfire call searching. We\nprobably don't need both\nof these web searching,\nbut I wanted to\nadd these as fallbacks\nfor you if you\ncome in here and\nyou don't have the\nfire call MCP server\nset up. So summarize\nthe key way agent,\nthink hard. We're gonna\ntap in to the\nagent's reasoning capabilities. There\nyou can see we\nhave a thinking response\nblock that we're parsing.\nThere's the read, there's\nour tool audit. We\nare auditing its tools,\nright? We have governance\nand permission checks built\ninto the agent. And\nyou can see here,\nit has read that\nfile. It's understanding it.\nIt's breaking it down\nfor us here. Tool\nmanagement, rich UI, Claude,\nSDK integration, security features.\nThere it is. There's\nour nice summary. We\nhave more important agents\nto get to, but\nyou can see how\nvaluable this can be\nfor yourself, for new\nengineers, and for planning\nupcoming features, we have\na codebase QA\nagent dedicated, specialized for\noperating this small code\nbase right here. Okay,\nhow does this work?\nQA agent, let's open\nit up. Let's collapse\neverything that's got a\nhigh level view, 570\nlines, main. You can\nalways just look and\nsearch for the key\npieces of information. We\ndon't have any tools,\nso no custom tools\nhere, but we can\nof course search Claude\nand we're taken right\nto the most important\nelement of Claude Code\ncustom agents using the\nClaude Code SDK. We\nhave the options, right?\nThis is where we\ndeclare the majority of\nthe core four. And\nso we have a\nnew addition here. We\nhave some hooks. We\nhave our resumes. We're\ngonna continue the conversation.\nOf course, we're explicitly\ndeclaring the model. We're\ngetting rid of some\ntools. We're allowing some\nother tools. And most\nimportantly, above all, we\nhave our own system\nprompts. Understand the system\nprompt. QA agent system\nprompt. Look at that\nconsistent codebase. Once\nagain, no confusion anywhere\nover and over and\nover and over. Once\nyou find the winning\npatterns, keep using them\nwe're adding an MCP\nserver. So this is\nan important capability. You\ncan build custom agents\nand you can tap\ninto the rich model\ncontext protocol ecosystem. A\nlot of the tools\nthat you'll want and\nneed already exist. We\nhave that resume so\nwe can continue conversations.\nWe have our allowed\ntools, which are specific\ncode-based searching tools, right?\nThis agent cannot write.\nIt's a QA agent.\nWhy would it need\nto write anything? So\nwe are making that\nclear in our tools,\nright? Remember the core\nfour, context, model, prompt,\ntools, custom agents, Let\nyou control all of\nthese very quickly and\nquickly. consistently, right? This\nis encoded, right? This\nis quite literally in\ncode. So our agent\nwill always perform this\nway. That's our allowed\ntools, disallowed tools. And\nthen we have something\nspecial here. We have\nhooks. If you've used\nClaude Code hooks, you\nknow exactly what this\nis. This is how\nwe can tap into\nthe permission system. So\nwe're blocking environment variable\nfiles. We have two\nmatches here, pre-tool use,\npost-tool use. Here we're\njust doing some logging,\nright? Log tool usage.\nWe're just calling this\nmethod. That's what these\ndo. These just point\nto specific methods. And\nthen in pre-tool use,\nthis is where things\ninteresting hooks. Of course,\nwe're just logging usage,\nbut here in our\nhook matcher, when we\nmatch the read command,\nblock environment variable files.\nAll right, we don't\nwant this to happen.\nAnd we can of\ncourse just test this,\nread the dot in\nfile, right? And pay\nattention to what happens\nhere. Our agent is\ngoing to think, but\nthere we go, blocked\naccess to this environment\nvariable. It tried to\nread the sample, which\nwe should allow, but\nthis custom agent doesn't\ncare. It blocks everything.\nAll right, so now\nit's just reporting that.\nAnd yeah, so it\ncan see its own\ncode. So it's spoiling\nthe fun here, but\nyou can see there\nour hook blocked reading\ndot M in the\nfile path, right? blocked\nit completely and we\ngave it a concise\nresponse format telling it\nexactly why it was\nblocked, all right? And\nthen we have warnings\nfor other types of\nfiles. You can do\nanything you want in\nyour hook file, much\nlike you can with\nyour tools. But this\nis important. You can\ntap into the hook\ncapabilities with your custom\nagents. You can see\nhere, this is essential\nfor governance, for control,\nfor permissions in all\nof your agents. We\ncan ask questions, we\ncan let it search.\nIt runs multiple agents\nto get things done\nquickly. Feel free to\nuse this as a\nstarting point for your\nown code-based QA agent.\nLet's move on to\nricher applications where we\nembed our agents into\nuser experiences. Next we\nhave a try copy\nwriter. And now we\nhave a more built\nout structure, backend, frontend,\nprompts. We have this\nfired up here and\nlet me just go\nahead and clear this\nout and restart this.\nAnd we have our\nbackend, we have our\nfrontend. Let's go ahead\nand understand what this\ninterface is, all right?\nSo this is a\ntry copy writer. We're\nnow moving our agents\ninto user interfaces. So\nI'll just start by\ntyping hi and you\ncan see something interesting\nright out of the\nbox. We have one\nagent generating a response\nwith six variations. multi-variation\ncopywriter agent. I have\nwith one prompt, six\nvariations coming out of\nthis agent. All right,\nvery powerful, but it's\neven more capable than\nthat. Okay, I can\nvia its agent response.\nI don't want any\ntools running here. I\ndon't care about tool\ncalling here for this\nproblem, for this use\ncase, tool calling is\nuseless for me. This\ndoes not provide value\nto our users, to\nour customers in this\nspecific use case, but\nwe do have this\nsystem prompt. And let's\ngo and open this\nup, right? If we\ncollapse as normal, we\nhave the following. Purpose,\nvariables, instructions, examples. If\nyou're noticing a pattern,\nthat's good. You're understanding\nwhat's going on here.\nAnd this is actually\nwrong here. This is\na bug. You're a\ncopywriter that responds with\nnumber of versions, unique\nversions. There you go.\nIt started with three\nand then I bumped\nit up to number\nof versions. You can\ndynamically select how many\nversions your agent responds\nwith, all right? Number\nof versions, we pass\nthis into the system\nprompt and lock it\ninto stone, right? We\nturn it into the\nlaw of the agent,\nokay? Then we have\nour instructions, respond JSON,\nvariations, blah, blah, blah.\nThe most important part\nis down here, right?\nExamples, here's what the\noutput structure looks like.\nWe have the primary\nresponse and we have\nour multi-version copy responses.\nOkay. And so it\nis important from a,\nyou know, prompt engineering\napplication perspective. It is\nimportant that this agent\ncan see every variation.\nOtherwise you need to\ncoordinate multiple agents to\nget this done by\nusing the system prompt\nand by building a\ncustom agent, every unique\nversion can come right\nout of this one\nagent. And that means\nthat it has all\nthat context, right? It\nhas those tokens inside\nof its context window.\nSo when it's generating\nthe unique versions, it\ncan generate them properly.\nAnd you know, I\nleft another bug in\nhere, my bad. Let's\njust search for three.\nOkay, there we go.\nSo that was the\nlast one. So here\nwe of course just\nreferencing this variable that\nwe're declaring at the\ntop of the file,\npowerful language models will\nbe able to reference\nthis and know exactly\nwhat we mean here.\nAll right, so fantastic.\nSo this is the\nsystem prompt, this controls\nthe behavior of our\nagents, I highly recommend\nwhatever response format you\nreturn from your agents\nif you're responding with\nJSON, you create a\nconcrete object. If we\nsearch that here, you\ncan see we have\nthis in a field,\nright? In a Pydantic\nclass. If you're in\nTypeScript land, you'll use\nZod, but here we\nuse Pydantic, all right?\nSo response format, multi-version\nthis is really cool,\nright? Our build agent\nis now processing. So\nthe planner is done.\nYou'll notice the UI\nis gonna be a\nlittle kind of glitchy\nhere because it is\nupdating on itself. And\nso it's actively starting\nand restarting the server\nand the client, but\nthat's fine. Our web\nsocket should pick this\nup and continue processing.\nSo there you can\nsee the spec. We're\noperating on that plan.\nWe're operating in the\nreview now. So if\nI hit refresh, there\nwe go. We can\nsee that we're in\nthe review step now.\nOkay, so. Very cool\nway to just kind\nof see how agents\ncan work together and\nthen you just package\nit in a nice\nUI. Then you can\ndo more than you\never could before, frankly,\nright? We have a\ndedicated workflow working step\nby step by step,\nplan, build, review, and\nhanding it off to\nthe next stage in\nthe process, okay? You\ncan see here our\nreviewer agent, there's all\nof its tools, and\nyou can see it\njust operating, doing work\nfor us, right? We're\nusing a lot of\nthe out-of-the-box Claude Code\ntools, right? If you\ndon't need to reinvent\nthe wheel, don't do\nit. Let's be super\nclear about this. The\nClaude Code, running the\nbase Claude Code agent\nis incredible. We've been\nusing it since Claude\nCode was released. You\ncan see here, we\njust moved to shipped.\nThere we go, update\ntitles. And you can\nsee here, guess what\nhappened? Plan, build, review,\nand ship agents. Both\ntitles updated. This work\nshipped with a single\nprompt outside the loop,\nright? This is a\nperfect example of an\nout loop review system\nusing the Peter framework,\nright? Our tickets are\nour prompt input and\nreview system. We dialed\ninto this a ton\ninside of TAC. If\nyou haven't finished the\nTAC lessons, you should\nprobably stop watching this\nvideo immediately and finish\nTAC. It's all about\ntransitioning from in loop\nto out loop. to\neventually ZTE. We have\na couple of cool\nthings to point out.\nSo seven slash main,\nlet's get into custom\nmicro seven and just\ncollapse, right? Let's understand\nthis at a fundamental\nlevel, scroll to the\nbottom here, 400 lines\nfront end. And I\nthink we have a\ncouple additional files here.\nYeah, we have our\nmodules, agent orchestrator and\njust a config file,\nright? I don't think\nany of this here\nis interesting. What is\ninteresting is the agent\norchestrator. So let's come\nin here and let's\njust search our cloud\ncode options, right? This\nis a great place\nto start when you're\njust quickly looking through\nagents and you want\nto know where to\nstart. So we have\nthe following configuration. Super\nimportant here, we do\nhave hooks. So we\nare limiting our agent.\nWe're giving our planner\nagent a right hook.\nAnd we're basically just\nsaying, where is it\nexactly? We're saying a\nnormalized path here. We're\ngetting the path to\nwhatever it's trying to\nwrite to. And we're\nmaking sure that our\nwriter agent can only\nwrite to our plan\ndirectory. There is no\nother reason for a\nplanner to do anything\nelse. So we're making\nsure with permission checks\nvia hooks. You saw\nthat throughout, write aloud\nwhen our spec was\ntrying to get written\nright here, right? And\nwe can of course\nopen up the spec.\nIt should just be\nin the specs directory\nright here. There we\ngo. And you can\nsee exactly what this\nis, right? So it\njust wrote up this\nnice spec here. This\nis a plan. So\nit doesn't really follow\nany traditional prompt engineering,\nagentic prompt engineering structure,\nbut this is just\na plan to get\nwork done, right? It's\na plan to operate\nand ship. You can\nsee here, probably a\nlittle bit overkill, 175\nlines, but still good\nto have, right? We\nhave a full plan.\nWe have a trail\nof success. in our\ncodebase from planning\nto building to reviewing.\nWe also have in\nthis micro SDLC a\nreview file here as\nwell. So our agent\nnot only planned, it\nwrote a review for\nus as well. So\nthat's fantastic. And let's\nget back to our,\nwhere did that go?\nAgent orchestration, right? So\nwe have this tool\nhere, right? Planner right\nhook, fantastic. And this\nis one of our\nagents configurations. We can\nof course go into\nour planner prompt and\nsee exactly what our\nplanner is doing. There's\nthe planner prompt. And\nhere we also have\nindividual user prompts that\nwe're passing in as\nwell. So we have\nplanner user prompt. Okay,\nyou can see the\nstructure here, system prompts,\nand we have user\nprompts. So we're separating\nour prompts, we're creating\ndedicated spaces. These aren't\ncustom slash commands. These\nare dedicated prompts, we\ncould for sure make\nthese custom slash commands,\nbut for the SDLC,\nit's much easier to\njust have concrete files\nthat we then replace,\nokay? Classic agentic prompt\nformat here for prompts\ngoing into your agentic\ncoding tools. We have\nthe title, the purpose,\nis doing something interesting.\nIt's appending its system\nprompt to the clawed\ncode system, okay? So\nwe're not blowing it\naway We're just adding\nsomething, all right? I'm\ngonna leave this all\nhere for you to\ncheck out and to\nunderstand. We have a\nmulti-agent workflow wrapped in\na UI. We are\nextending Claude Code in\nmost cases, modifying a\ncouple things, adding some\npermission checks, some hooks.\nIn our planner agent\nand in our review\nagent, we're just appending\nsystem prompt. So this\nis an important idea.\nYou don't always need\nto blow away the\nClaude Code system prompt,\nall right? So very\npowerful. This is of\ncourse a demo. This\nisn't gonna work in\nall cases, but you\nhave this available. to\nyou to test out,\nto understand how you\ncould build something like\nthis. Let's move on\nto our final agent,\nthe UltraStream agent. Our\nfinal agent looks like\nthis. Similar structure, backend,\ndata front end modules,\nsystem prompts, and we\nhave a couple of\ntest files. We have\nsome data here. Let's\nunderstand this server, kick\noff the backend. Once\nagain, I'm gonna run\nwith reset so that\nit clears out the\ncurrent database. We have\ntwo agents. We have\nour streaming agent on\nthe right and we\nhave our chat interface\non the left. And\nas you can see\nhere, our streaming agent\nis a live process\nfeed of incoming logs.\nSo you can imagine\na log file coming\nin from your backend,\nDatadog, GCP, AWS, wherever\nyou handle your logs,\nJust intake that information\nand let your agent\nprocess on it and\nfilter for important information\nlike this alert. All\nright. Just by sitting\nhere in this UI,\nI got this alert.\nThe streaming agent is\nsummarizing the logs. It's\nunderstanding the logs, it's\ningesting them. And it's\nletting me know if\nthere's something that needs\nmy attention. We have\nan alert here. So\nI can dial into\nthis with our inspector\nagent on the left.\nI'll say a list\nissues one through three\nlog summary only and\nuser. So we're taking\nthat off. And of\ncourse, our agent is\nlooking at this formatted\ndata. It's calling its\nown tool set built\nup for this specific\nuse case, right? This\ndomain specific use case.\nAnd then it's outputting\nsome markdown here for\nus, all right? So\nwe have the severity\nhere, a summary, and\nthen the user in\nwhich it was responsible\nfor, right? Very cool,\nvery interesting, all right?\nAnd so we actually\njust missed log four,\nso include, log four\nand just show summary\nuser. There is our\ntool read. It's reading\nfrom this data stream.\nAnd there are a\ncouple really, really important\npieces here happening with\nthis application, right? There's\nthe severity. And then\nwe can do something\nlike this, right? We're\nin this domain specific\napplication where we have\nagents working for us.\nAlert support about issue\nnumber four. While we're\ndoing this, you can\nsee another high issue\nis gonna come in\nhere. Our agent is\ngonna let us know\nthat there's a new\nalert. So there's another\nissue for us to\nprocess. But you can\nsee here, right, we\nhave notified our support\nteam about this issue,\nokay? You can imagine\nyour support has this,\nAnd it's the other\nway around, right? Support's\nletting the engineering team\nknow, engineering teams letting\nPM know, whatever. You\ncan literally do anything\nunder the sun. The\nimportant thing here is\nwe have two agents\nhelping us operate a\nstream of important information,\nhelping us filter it\ndown piece by piece\nby piece. All right,\nhow are we able\nto build this powerful,\nrich user experience, a\nmulti-agent experience? Let's go\nand close this. This\nis my favorite agent\ncombination, by the way.\nAnd why is that?\nWhy is this my\nfavorite? It's because it's\nreally showcasing the fact\nthat you can use\nagents, not just in\nUI, in operating data\nstreams. You can produce\noutputs with one agent\nand have other agents\nlike the inspector agent\nconsume the output as\nits input from another\nagent, right? There's just\nso many multi-agent configurations\nthat are untapped and\nunexplored. So this is\nall under a single\nfile, which is probably\nnot correct since we're\nup at 1,400. So\nthis is gonna be\nharder for an agent\nto read, but you\ncan see here, not\ntoo bad either, right?\nWe have concrete headers.\nThat'll be a little\nbit easier to understand\nand read if we\nneed to quickly filter\nthrough and search through\nwhat exactly the application\nis doing. But anyway,\nwe can of course\nsearch at tool to\nfind all of our\ntools. And more importantly,\nwe can search for\nClaude Code options. We\nhave custom agents, right?\nfact, if we threw\nall of these logs\nin here at the\nsame time, it would\nnot be able to\nprocess them without taking\na lot of time,\na lot of tokens,\nand that means a\nlot of capital. But\nwe of course have\nbuilt fine-grained tools to\nhelp our agent operate\nthis specific use case.\nYou cannot do this\nwithout serious prompt engineering\nwith a out of\nthe box agent. Okay,\nwe have a tool\nfor this domain specific\nSaving money, saving tokens,\nsaving time. Start line\nindex, inline index, you\ncan see our agent\nis processing logs and\nchunks, right? So we're\njust incrementing 45 through\n50. If we go\nback up, you can\nsee 40 through 45,\n35 through 40. So\nwe are reading just\na few lines and\nprocessing just a few\nlines. We're not overwhelming\nour agents. We're constantly\nthinking from our agent's\nperspective. And you can\nsee here, here's how\nwe're doing it. We're\nprocessing that very quickly\nusing a sub process\ncommand. And that just\ngets the work done\nfor us on this\nfile, cleaning up old\ncache entries, so on\nand so forth. All\nright, feel free to\ndive into the code\nmore. I just wanna\npoint out this fact\nthat we are building\na specialized agent to\noperate on a file\nin a token efficient\nway, okay? So that's\nour stream agent. And\nwe can of course\nsee all the tools\ngetting built up here.\nIt's then producing a\nsummarized log one piece\nat a time. If\nwe open up our\nstream agent system prompt,\nyou can see here,\nwe have a couple\nof static variables. We\ncould dynamically set these\nstatic variables, but these\nare just purely static.\nWe're letting our agent\nmanage its own context\nwindow. with this variable\nthat updates some code\nthat clears the context\nwindow by updating the\nsession ID. We have\nlines to read and\nthen once again, rinse\nand repeat, right? Whatever\nyou want your agent\nto do, detail it\nin the specific agentic\nprompt format, the agentic\nsystem prompt format. Specifically,\nwe have the workflow,\nwe have instructions, variables,\npurpose. You can imagine\nwhat this all does.\nThe workflow is important\nhere because again, we\nhave a specific workflow.\nWe want our agent\nto hit every single\ntime. We're giving it\nsome examples, right? This\nis an important section\nthat you can swap\ninto your agentic prompts,\nboth system prompt and\nuser prompt. And we're\nshowing it how to\nproduce the right log\nformats. You can see\nexactly what this looks\nlike, capture the information\nthat you care about,\nand then pass it\nonto the tool. All\nright, there's that workflow,\nright? So we're just\nbeing super clear about\nwhat's next. So this\nis our stream agent.\nWe also have our\ninspector agent. This agent\noperates on the logs,\nright? It operates on\nthe logs produced by\nour stream agent. So\nwe're gonna read produced\nlog entries. Same kind\nof format, right? Whatever\nwe prompted to read,\nstart index and end\nindex, as you saw\nhere, and it looks\nlike we ran into\nsome issue. Let's go\nahead and restart the\nserver. We can also\nfind logs for a\nspecific user based on\nthe information that we're\nprocessing based on our,\nagain, domain specific problem.\nI really wanna showcase\nthat that is the\nkey of custom agents.\nYou can solve your\nproblems better than any\nagent can. Okay, out\nof the box is\na great place to\nstart, but don't end\nthere. There's too much\ndebate on what the\nbest tools are There's\ntoo much debate on\nthe best models. This\nis all a journey.\nNew things are coming\nout all the time.\nIt's about focusing on\nthe primitives that you\ndomain-specific problems, better than\nanyone with compute. If\nyou want to keep\nyour costs down while\nkeeping performance up, remember\nevery prompt costs and\nwhatever's in that context\nwindow on startup is\ngoing to cost you.\nThat goes all the\nway down to the\nsystem prompt and the\nuser prompt. And then\nif you need permission\nchecks, custom agents allow\nyou to prevent your\ncompute from destroying your\nwork or causing issues,\nright? They also make\nit easier if you're\ndeploying these agents for\nsomeone else, for someone\nin your team, for\nyour engineering org, PM\nsupport. Custom agents allow\nyou to make your\nagents safe, right? You\ncan set up hook\nYou can use different\nelements of your clock\ncode options to make\nsure your agent doesn't\ncause issues, okay? But\nmost importantly, you know,\na big idea we\ntalk about in TAC\nYou build custom agents\nwhen you want to\nstay out of the\nloop. These are the\nhigh level reasons why\nyou should build a\ncustom agent. Now, that\ndoesn't mean that you\nalways should. It is\nnatural that if you're\npushing compute to its\nlimits, you will end\nup at custom agents.\nBut for a lot\nof use cases, out\nof the box agents\nare good enough. So\nif you're operating in\nthe loop, like many\nof us are with\nour agents, right? You\njust boot up a\nClaude Code agent, prompting\nback and forth, getting\nwork done. There's no\nreason to build a\ncustom agent to do\nthis unless you have\nsome grandiose idea on\nhow to build a\nbetter agentic coding tool\nthan some of the\nbest engineers doing this\n24 seven. Okay, you\ncan extend this a\nlittle bit, make it\nyour own. You might\nlike to build your\nown UI wrapper around\nthis, whatever. Also, I\ndon't wanna violate any\nterms of service at\nall. In no way\ndo I think you\nshould try to compete\nwith Claude Code. I\nthink that's actually a\nmassive mistake. They own\nAgentic Coding. They are\nthe best at this.\nAnd despite efforts from\nsome of the other\nGen AI companies, I\ndon't see that changing\nanytime soon. and I\nuse all those tools\nand I've been using\nClaude Code since the\nbeginning, okay? So don't\ntry to reproduce your\nown engineering agent. Cloud\nCode is that, okay?\nAnd this space is\njust, Totally, totally oversaturated.\nSo when you're operating\nin the loop, prompting\nback and forth, use\nClaude Code. Use the\nout-of-the-box agent. When else\nshould you use out-of-the-box\nagents? When your workflow\nis generic enough that\nthe Claude Code SDK\ncan deliver on the\nwork you want done.\nYou also want to\nuse out-of-the-box agents. If\nyou're just exploring your\nprototyping, there's no innovation\nneeded here. You don't\nneed custom agents to\nexplore and prototype. If\nyou need a balanced\ngeneralist engineering agent that\nworks well in 80%\nof situations, use the\nout-of-the-box Claude Code agent.\nWhen your tasks are\nshort-lived, lightweight, They don't\nrequire repeatability and they're\nnot domain specific. It\ndoesn't matter what agent\nyou use. Okay. You\ndon't need a custom\nagent for this. You\nknow, there's an important\nidea here to echo\nand you saw it\ninside of the plan,\nbuild, review and ship\nagents, right? Our SDL\nmicro agent workflow here.\nThat is a multi-agent\nsystem. We just redeployed\na lot of the\nbaked in Claude Code\ntools and functionality. We\nonly appended the system\nprompt, right? So we\nare just extending cloud\ncode and this is\na good delineation. There\nare extension agents. or\nextended agents, and then\nthere are complete custom\nagents. This is really\ndefined when you overwrite\nthe system prompt and\nthen defined even further\nwhen you start using\nyour own custom tools,\nright? For our UltraStream\nagent, this was not\nthe Claude Code product\nat all, right? We're\nusing the Claude Code\nSDK harness, absolutely. That's\nwhere a lot of\nthe value is in\nagents. It's in the\nagent loop, it's in\nprompt caching, it's in\na lot of the\nniceties that they provide\nout of the box,\nbut we did not\nuse Claude Code at\nall, right? our SDLC\nmicro agents here, they\ndid. This is software\nwork. That's what Cloud\nCode is for. So\ndon't step on these\nboundaries too much. If\nyou're working on engineering\nwork, you probably just\nneed to fine tune\nown agent SDK. These\nare all powerful toolkits\nyou can use to\ncontrol the core for\nwithin your agents to\nscale them intelligently. If\nyou're doing one size\nfits all work, use\nthe out of the\nbox agent. Don't think\nsuper hard about this.\nJust deploy compute to\nget the job done.\nBut as your work\nbecomes more specialized, as\nyou deploy agents across\nall aspects of your\nengineering, you first want\nbetter agents, more agents,\nand then custom agents.\nSo one of the\nbenefits rolled into the\nagentic horizon extended lesson\nis that you get\nto vote on upcoming\nlessons. Upon launch, going\nto have three additional\nslots for you to\nvote on ideas for\nthe next upcoming lesson.\nAs you exit this\npage, you can click\ninto that and you'll\nhave several options to\nselect from that detail\nthe next agentic coding\ntopics you want a\ndeep dive on. Maybe\nyou want more concrete\nexamples of the agentic\nlayer, or maybe you\nwant to see more\ncustom agents, or you\nwant more context engineering\ntechniques, or maybe you\nwant to see an\nagentic deep planner, right?\nThere are tons of\nideas. Whatever you want\nto see next, place\nyour vote. After about\n500 to 1,000 votes,\nI'm going to take\nthese, I'm going to\ntally it, and I'm\ngoing to build a\nlesson, a hyper-focused lesson\non the topic you\nand other engineers decide.\nObviously here, we're focused\non the bleeding edge\nuse case of agents.\ncore four, the key\nideas embedded in TAC.\nIf this works out\nwell, I'll do more\nvote-based lessons. So place\nyour vote there and\nyou'll guide the future\nof the agentic horizon.\nThis codebase is\ngonna be available to\nyou. Every agent you\nsaw here is gonna\nbe in the apps\ndirectory waiting for you\nto dig in and\nunderstand how you can\nbuild out custom agents\nfrom zero in a\nsimple script all the\nway up to complex\nmulti-agent user interfaces that\nhelp you control your\ncompute and use custom\nagents in a better,\nmore powerful way. This\nis a codebase\nyou're going to want\nto ultra think about\nand understand how you\ncan extend and use\nthe ideas we've discussed\nhere. Deploying effective compute\nand deploying effective agents\nis all about finding\nthe constraints in your\npersonal workflow and in\nyour products. Think about\nrepeat workflows that can\nbenefit from an agent\ninside of a script,\na data stream, an\ninteractive terminal, all the\nway up to user\ninterfaces that can tackle\nhigh return on investment\nproblems in your tools\nfor your team and\nfor your business. Agented\ncoding is not so\nmuch about what we\ncan do anymore. It's\nabout what we can\nteach our agents to\ndo. This is how\nwe push our compute\nto its useful limits.\nFollow this path to\nunlock massive value for\nyour tools and products.\nBetter agents, more agents,\nand then custom agents.\nI'll see you in\nthe next Agentic Horizon\nextended lesson.",
  "summary": "This advanced lesson covers building custom agents tailored for specific domains. The progression: better agents, more agents, then custom agents. Out-of-the-box tools like Claude Code are built for everyones codebase, not yours - this mismatch costs hundreds of hours and millions of tokens. The lesson teaches how to use the Claude Code SDK to create domain-specific agents by modifying the system prompt (the most important element with zero exceptions) and providing custom tools. Examples include a Pong agent (simplest custom agent), stream agents that process real-time data, and inspector agents that analyze logs. The key is encoding your domain knowledge, business logic, and constraints into specialized agents that solve YOUR specific problems.",
  "key_concepts": "1. THE PROGRESSION: Better agents, more agents, then custom agents. Once you master prompt and context engineering, the next step is domain-specific customization.\n\n2. THE MISMATCH PROBLEM: Out-of-the-box agents (Claude Code, Codex CLI, Gemini CLI) are built for everyones codebase, not yours. This costs hundreds of hours and millions of tokens as your codebase grows.\n\n3. SYSTEM PROMPT IS EVERYTHING: The most important element of custom agents with zero exceptions. You can completely overwrite the default system prompt to change agent behavior.\n\n4. CLAUDE CODE SDK: Use the SDK to create custom agents by modifying two key aspects - the model and the system prompt. This changes everything about how the agent operates.\n\n5. DOMAIN-SPECIFIC AGENTS: Agents that understand YOUR business logic, domain constraints, and specialized workflows. This is where all the alpha is in engineering.\n\n6. CUSTOM TOOLS: Provide agents with specialized tools tailored to your domain. Stream agents, inspector agents, and other specialized workers.\n\n7. AGENT DELEGATION: Primary agents can delegate to sub-agents (code-reviewer, planner, builder, reviewer). New primary agents handle specialized domains.\n\n8. WORKFLOW ENCODING: Give agents specific workflows to hit every single time. Use examples section to show exactly how to produce the right formats.\n\n9. HARD SPECIFIC PROBLEMS: Custom agents solve problems that most engineers and most generic agents cant solve out of the box. Your edge cases become solvable.\n\n10. COMPUTE FOR YOUR DOMAIN: Flip the equation so compute works for your domain, your problems, your edge cases. Scale impact by building specialized agent fleets."
}