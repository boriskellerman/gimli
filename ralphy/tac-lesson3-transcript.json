{
  "video_id": "success-is-planned",
  "url": "https://agenticengineer.com/tactical-agentic-coding/course/success-is-planned",
  "title": "Success is Planned: The 80-20 of Agentic Coding",
  "channel": "Agentic Engineer",
  "duration": 2793,
  "language": "en",
  "language_name": "English",
  "is_auto_generated": false,
  "extracted_at": "2026-01-14T03:10:19.654Z",
  "transcript": "lesson three of Tactical\nagentic coding. What was\nonce a complete joke\nis now the most\nvaluable skill any engineer\ncan have. The prompt\nis everything. Why is\nthat? It's because it's\nthe medium in which\nyou communicate to your\nagentic tools and all\ngenerative AI technology. At\nthe heart of everything\nwe're doing in TAC\nis learning how to\nproperly communicate to our\nagents to get the\nwork autonomously. Adopting your\nagent's perspective is no\ndifferent than empathizing with\na friend or a\ncoworker. In order to\nunderstand them, connect with\nthem, and solve problems,\nyou must take their\nperspective. With AI coding\nand the big three,\ncontext, model, and prompt,\nyou are able to\npush language models hard\nand generate hundreds and\nthousands of lines of\ncode. But AI coding\nis not enough. Coding\nis just one element\nof engineering. There's a\nreason they're called Vibe\nCoders, not Vibe Engineers.\nThey're just coding. We're\ndoing it all. This\nis real engineering. Agentic\nCoding and the Core\n4 takes it all\nto the next level\nwith the addition of\ntools, our prompts, have\nbecome exponentially more powerful.\nPrompting is how we\nenable this. In order\nto maximize this ability,\nwe need to scale\nour prompts. Here's a\nsimple question for you.\nWhat does a scaled\nprompt look like? You\nguessed it. It's a\nplan. It's a specification.\nIt's a PRD. Plans\nare prompts scaled up\nfor high impact the\nplan is the prompt\nand that means great\nplanning is great prompting\nfull circle great prompting\nis all about communicating\nto gen ai and\nplanning is how we\ndo this better than\nthe rest in lesson\nthree we're going to\nscale your prompts into\nplans and scale your\nplans into something even\nmore powerful to drive\na massive impact we'll\ndo this by using\na new game breaking\ntactic. Once you see\nthis tactic and the\nimplementations of it, it\nwill be impossible to\nunsee. You'll understand how\na few engineers are\nchanging the engineering game\nbecause you'll be one\nof them. What we\ndo in this lesson\nwill unlock your ability\nto not just augment,\nbut automate the entire\nsoftware development lifecycle with\nyour agents shipping work\non your behalf. Those\nwho plan the future\ntend to create it\nsuccess is planned in\nthis lesson we enter\nthe plan and build\nphase of the agentic\nsoftware developer life cycle\nwith just three tactics\nyou'll learn the pareto\n80 20 of agentic\nengineering first you stopped\ncoding our hands and\nour minds are no\nlonger the best tool\nfor the job then\nyou adopt your agent's\nperspective so you can\nmaximize the leverage you\nget from your agents.\nThen you can template\nyour engineering. This enables\nyou to deliver consistent\nresults across hundreds of\nagent executions, no matter\nthe size or complexity\nof your codebase.\nThat's right. What we\ndo here contains one\nof many solutions to\nthe my codebase\nis too big problem.\nWhen you template your\nengineering, You encode your\nproblem solving into reusable\nunits that you, your\nteam, and your agents\ncan see, use, and\nimportantly, improve. Plans are\nthe end result of\ntemplates. It's how we\nimplement this tactic on\na functional level. But\nplanning alone is expensive.\nIt's time consuming, and\nthere's always something to\nmiss. And the time\nplanning consumes scales with\ncodebases, all the\nway up to massive\nrefactors. We do this\nby taking our successful\nplans and converting them\ninto templates, one of\nthe 12 leverage points\nof agentic coding. In\nthis lesson, we differentiate\nwhat you can do\nby building a suite\nof templates that give\nyou full control over\nhow your agent solves\na variety of problems.\nAgentic coding tools like\nCodex, Copilot, Devon, Jules,\nGemini CLI, and whatever\ncomes next, these tools\nare great, but they're\nlimited by nature. No\nmatter how great AI\ngets, they don't understand\nyour codebase like\nyou do. And out\nof the box, they\ndon't let you control\nyour agents to the\ngranularity you need to\nto ship code end\nto end throughout the\nsoftware development lifecycle. So\nhow can templates let\nus encode our engineering\nand hand off massive\namounts of work to\nour agents through plans?\nLet's break it down\nin the TAC3 code\nbase. Let's go ahead\nand open up the\nterminal. And let's clone\nin the lesson three\nrepository link available in\nyour loot box below.\nI'll CDN and I'll\nopen up VS code\nhere. Here we have\nour natural language code\nbase with our changes\nfrom lesson two. I'll\nboot up Claude Code\nand fire slash install\nto have our agent\nset up our code\nbase. Important note here,\nwe're executing a new\nscript in the install\ncommand. Let's go ahead\nand open this up.\nIf we look at\ninstall.md, you can see\nwe have a new\nline that's going to\nrun here. So we're\ngoing to run the\nscripts copy.m and this\nis going to copy\nour dot m file\nfrom our tack to\ncodebase. This is\njust a quick way\nto reuse resources. If\nyou open up scripts,\nyou can see exactly\nwhat that's doing there.\nHere we're having an\nagent with a reusable\nprompt do this work\nfor us. Agentically. These\nreusable prompts, much like\ntemplates we'll explore here\nin this lesson are\nextremely powerful time savers\ndue to how reusable\nthey are and not\njust for you, but\nfor your entire team.\nSo there we go.\nIf we close everything\nhere, go to app\nserver, you can see\nour dot environment variable\nfile was automatically copied\nin or agent set\neverything up our back\nin dependencies, front of\ndependencies and everything is\ncompleted and we had\nit report its work.\nNow let's open up\na new terminal here\nand we'll run our\nstart script once again.\nSo I'll say scripts\nstart and let's just\ngo ahead and boot\nup our natural language\nSQL application. If we\nopen up the browser,\nyou can see our\nnatural language SQL interface.\nLet's hit upload data\nand select our user\ndata here. Show users\nwith age between 20\nand 40. We'll fire\nthat off. As before,\nour natural language query\napplication is working as\nexpected. Ages 20 through\n40. If we open\nup the terminal here,\nwe can see that\nstandard out is getting\nwritten. And if we\nwanted to, we could\nboot up a cloud\ncode instance and have\nit read in all\nof the output of\nour servers so that\nit can make changes\nfor us. Great. Now\nlet's run our first\ntemplate and understand the\nimpact it has on\nyour agentic coding abilities.\nSo let's open up\na brand new cloud\ncode instance here, and\nwe're going to trigger\na template called slash\nchore and inside of\nthis template it accepts\na parameter so i'll\ntype replace all server\nprint statements proper python\nlogging log levels make\nsure all output is\nwritten to standard out\nall right let's fire\nthis off here we're\nrunning a special custom\nslash command that produces\nfour, run validation commands.\nAnd you can see\nhere, we have a\nheader that describes what\nwe're gonna run to\nvalidate that the work\ndone was successful. All\nright, and then we\nhave a final notes\nsection. So this is\nthe generated plan. Okay,\nso we just ran\na prompt that created\na plan for us.\nIt turned our one\nsentence prompt into an\nentire plan. Okay, so\nlet's understand how this\nhappened, right? Let's open\nup dot Claude commands.\nYou can see we\nhave a whole slew\nof reusable prompts. Let's\nclick into chore and\nunderstand what this prompt\ndoes. If we go\ninto preview mode here,\nyou can see we\nhave a prompt chore\nplanning. And so every\ngreat prompt contains a\npurpose right at the\ntop. Here we have\na reusable prompt that\nlooks ordinary, but the\ninstructions in this prompt\ncompletely changes your engineering\nimpact. So we're asking\nour agent to create\na new plan in\nthe specs directory to\nresolve the chore using\nthe specified plan format,\nfollow the instructions to\ncreate the plan, use\nthe relevant files to\nfocus on the right\nfiles. So you can\nsee here as headers,\nwe have our detailed\ninstructions, We have relevant\nfiles to help guide\nour agent to success.\nWe then have our\nplan format. Something super\nimportant to note here,\nwe're asking our agent\nto create a new\nplan. What is a\nplan? It's just a\nprompt, right? It's a\nlarge prompt. So this\nis this tour file\nhere. This is a\nmeta prompt, right? It's\na prompt that generates\na prompt. This is\nextremely powerful. Not only\nshould we stop coding,\nwe should also lean\ninto and leverage our\nagent to write plans\nwith us and for\nus. Now we can\ntake that idea a\nstep further. Let me\ngo back into preview\nmode here. We can\nsee the plan format.\nOkay. So we requested\nthis agent creates a\nnew plan in the\nspecified markdown format. We\nare giving our agent\na template. Okay. So\nyou can see here,\nthere's the plan format.\nWe have the chore\nat the top, chore\ndescription, relevant files, step-by-step\ntasks, validation, and then\nnotes. And of course\nthis lines up with\nexactly what was generated.\nIf we go ahead\nand collapse here, we\ncan see this exactly,\nright? This was our\nplan that was generated\nfrom our chore template\nmeta prompt. Okay. Why\nis this so interesting?\nWhy is it so\npowerful? It's because we\ncan now template our\nengineering. If we keep\nscrolling here, you can\nsee our last section\nis just chore with\nthe claw code argument\nparameter that just takes\nwhatever we passed in\nright here, takes our\nstring and places it\ndown here as the\nchore. And this is\nthe section that we\nreference in our purpose.\nSo this is super\npowerful. I hope you\ncan see where this\ncan go. This is\na massive, massive idea,\nbut we're not done\nyet, right? We only\ngenerated a plan. Okay.\nIt's just an auxiliary\ndocument. Let's go ahead\nand implement the work\ndetailed in our replace\nprint with logging plan.\nSo let's go ahead\nand open a new\nterminal and boot up\nanother claw code instance.\nThis might seem like\na weird pattern, but\nit's ultra important. We'll\ndiscuss why later. Let's\nrun another simple slash\ncommand to kick off\nthis plan. We're going\nto run slash implement.\nand then we're going\nto get the file\npath to the plan\nwe created. So I'm\njust going to copy\nthat and paste it\nhere and that's it.\nWe're going to fire\nthis off. It doesn't\ntake a lot to\ndo a lot, but\nyou need the right\ninformation. Our agent is\ngetting to work here.\nLet's go ahead and\ncrack open the implement\nprompt to understand what's\ngoing on. So we\nhave another reusable prompt\nhere, implement and check\nthis out, right? Very\nsimple, very concise, 12\nlines of natural language.\nWe have the purpose\nat the top, follow\nthe instructions to implement\nthe plan, then report\nthe completed work. All\nright. So here we\nhave instructions, just a\nsingle instruction. Read the\nplan. Think hard. We're\nactivating Claude Codes information\ndense keyword to activate\nthe reasoning model. We're\nusing one of the\n12 leverage points of\nAgentic Coding by turning\non the reasoning model.\nLet's go ahead and\ngo into Yolo mode.\nYou can see the\nchanges flowing in here.\nWe'll accept all think\nhard about the plan\nand implement the plan.\nAll right. And then\nvery interestingly here, you\ncan see as an\nargument we're passing in\nthe plan. This is\na higher order prompt,\nAKA a hop. Okay.\nThere are a lot\nof advanced concepts here.\nWe'll circle back to\nthe higher order prompt\nin a moment. But\nbasically what we need\nto know here is\nthat thanks to this\nprompt, if we hit\nup here, implement and\nthen we pass in\nthe plan that we\nwant implemented, This is\ngoing to pass our\nfile path here. And\nthen our instructions, of\ncourse, said read, think\nhard and then execute.\nOkay. And so this\nis going to run\nthe replace print with\nlogging plan. And let's\nover time, right? We\nwant to focus on\ntactics. We want to\nfocus on capabilities. We\nwant to focus on\nwhat the tools can\ndo for us. Of\ncourse, we're using cloud\ncode. We're big fans.\nBut the key here\nis the capabilities that\nare unlocked by the\ntool. Okay. And then\nvery importantly, if we\ngo back to the\nimplement, you can see\nwe have this report\nblock right under our\nplan summarized work and\nthen report files change.\nAnd you can see\nthis happening exactly. And\nthis is going to\nbe super, super important\nonce we really start\ngetting into true off\ndevice agentic coding. Okay.\nWhat we're doing right\nnow is just the\nbeginning. It's just the\nbedrock to really, really\nscale or impact templates\nare critically important for\nthis. Look at all\nthe work we just\ndid. Look at how\nreusable this is. This\nis fantastic. We can\nsee there's the report,\nthere's the files changed\nall the work that\nour agent just did.\nIf we hop back\nover to our plan,\nwe can scroll to\nthe validation commands and\nwe're embedding another lever\nof agentic coding. We\nhave several self validating\nloops with tests. All\nright. So not only\ndid it run all\nof our PI tests\nto prevent regressions, it\nalso ran server and\nmain just to make\nsure that it works.\nAll right. So there's\nall the files changed.\nIf we want to,\nwe can of course,\nopen up a terminal\nand run get diff\nourself and we can\nsee everything that's changed.\nAll right. Looks great.\nIt looks very precise.\nIt looks like exactly\nwhat we asked for,\nright? This chore has\nbeen completed agentically with\ntwo prompts, one for\nthe planning phase and\none for the coding\nbuilding phase. Okay. We\ncan, of course, test\nthis if we want\nto. I am very,\nvery confident that this\nis working, but you\nknow, it's always good\nto manually test. So\nwe can go ahead,\nkick off our server\nagain, open up the\nbrowser, do a refresh,\nAnd so we can\nsee that info log\nright there. That looks\ngreat. Let's go ahead\nand run that same\nquery. So let's get\nusers ID name sorted\nby signup date descending.\nSo there we go.\nWe got that sorted\nby signup date descending.\nAnd if we go\nback, we can see\nthat we have our\nsuccess query processed in\nthat new logging format\nwith the logs exactly\nas we asked. And\nwe can of course\nopen up the server.py\nfile, to manually validate\nthis, we are going\nto standard out. There's\nthe basic logging. We\ncan do a all\nfile reference and we\ncan see it's in\nmain and server. Fantastic.\nSo this chore was\ncompleted. We now have\nno print statements inside\nof our codebase,\nright? Here's a search\nall no prints. It's\nall logging or logger,\nright? Let me turn\non regex and there\nwe go. So fantastic.\nLet me close all\nthis. Now the question\nis how far can\nwe push this? And\nthe answer is very,\nvery far. Okay. Let's\nlook at some more\ncomprehensive templates to agentically\ncomplete bugs in the\nsame way. All right.\nWe can scale this\nup to solving bugs,\nfeatures, and really anything\nyou can encode into\nyour prompt, right? These\nare repeatable solutions for\nsuccess. Okay. We're literally\nencoding our engineering. We're\ntemplating our engineering into\nthe codebase. Okay.\nThis tactic, It's critical.\nLet's knock out a\nbug in this code\nbase. I'm going to\nclose everything here. Let's\nopen the terminal just\nlike before. And once\nwe kick this off,\nI'll fully explain why\nI keep opening new\nterminals and new cloud\ncode instances. So we'll\nboot up Claude Code\nagain and then we'll\ntype, guess what? Slash\nbug. Okay. And you\nsaw it inside of\nour commands. We have\nslash bug. And so\nlet's solve a bug,\nright? So we're going\nto write a high\nlevel prompt that directs\nour agent toward the\ngoal we want accomplished.\nGuess what's in? This\n.bug markdown file, you\nguessed it, it's a\nmeta prompt that takes\na template to generate\na plan. This pattern,\nscale this up. Just\nto kind of go\nover these key ideas\nagain, we're putting to\nwork several leverage points\nof agentic coding. We're\ngenerating plans that's getting\ncreated by templates, right?\nReusable units of our\nengineering practices, right? We're\nteaching our agents how\nwe want the work\ndone, right? We're giving\nour agent our perspective\nand in turn, we\nknow what our agent's\nperspective is. We are\nenabling thinking mode, right?\nIf you just search\nfor think, You'll be\nable to find this.\nThis is an information\ndense keyword that Anthropic\nhas encoded into this\nword here. Think. And\nso you can see\nthe model thinking. We,\nof course, have a\ncore four at work.\nNone of this works\nwithout the core four\nare in agent leverage\npoints. And we, of\ncourse, have a well-designed\ncodebase. It's a\nsimple structure, right? Client\nserver. It's very easy\nfor agent to understand\nwhere everything is located.\nWe're not doing anything\ntricky or fancy or\nunusual here. Pretty straightforward\ncodebases, right? And\nthen we have a\nlittle bit of documentation\nin the readme detailing\nour structure, how to\nset things up, so\non and so forth.\nAnd so we can\nsee here our spec\nhas been created. We\ncan go ahead and\ncheck out how our\nagent has decided to\nsolve this bug given\nour encoded best practices\nfor solving bugs like\nthis. Okay, so we\ncan look at this\nfix SQL injection vulnerability\nand we can see\na great breakdown of\nhow to smash this\nbug. Okay. So same\ndeal. You can see\nexactly what's going on\nhere. We have a\ncouple of different sections\nfor our bugs. You\nknow, you can see\nwe have the problem\nstatement and the solution\nstatement. We have steps\nto reproduce, right? So\nfull on engineering steps\nto reproduce. You start\nand then you pass\nin something malicious or\nsend in a natural\nlanguage query, and then\nit'll actually get executed.\nOkay. So classic stuff\nthere. Don't focus too\nmuch on the code\nhere. Obviously example code\nbase. We're just using\nthis as a framework\nto learn great agentic\ncoding and agentic engineering.\nWe have a root\ncalls analysis. And then\nwe have, of course,\nour relevant files inside\nof our template. We\nasked our agent to,\nif you need to\ncreate a new file,\nright? So if I\ntype new file here,\nI asked list the\nnew files in a\nnew H3, a new\nheader called new file.\nSo that's exactly what\nhappened here. We have\na new SQL security\nfile that can be\ngenerated. And then of\ncourse we have step\nby step tasks. Okay.\nAnd you can see\nhere, this is a\nnon templated portion. If\nwe just copy important,\nWe can scroll down\nhere and see, you\nknow, step by step\nexecute every step in\norder top to bottom.\nOkay. Super important. All\nright. And then there\nit is. So top\nto bottom, all of\nour tasks, we of\ncourse have our validation.\nWe're leveraging tests and\nthen we have notes.\nOkay. So same idea,\nright? We're encoding our\nengineering into templates. Okay.\nThen our agent runs\nit as a meta\nprompt, a prompt that\ngenerates a prompt. It\ngenerates a plan that\nwe can now, execute.\nOkay. And then once\nagain, I promise I'll\nexplain this right now.\nSo, um, why do\nI keep doing this?\nLet me just get\nthis fired off. So\nslash implement and then\nsame deal, right? I'll\ncopy the path to\nour brand new prompt\nfile. And then I've\nbeen working, my plans\naren't committing any changes.\nSo I'm going to\ngo ahead and actually\ncommit these solutions, right?\nCommit my specs and\nthe code changes into\nthe codebase. I\nhave a quick command\nfor that. I'm going\nto go ahead and\ncommit that and then\nkick this off. And\nwe'll talk about how\nto use Git in\nthese systems. TLDR there\nis you want each\none of these steps\nto commit their changes.\nMore details on that\nin upcoming lessons. Our\nagent is going to\nsolve this for us\nnow, right? Same deal.\nThere's all the steps.\nIt's read the plan.\nIt knows that it's\nrunning the implement. So\nit's going to run\nin, right? In thinking\nmode with the reasoning\nmode. And then it's\nWe know what our\nagent is going to\nrun. We know what\nour agent is going\nto execute. OK, this\nis super important. We\nhave a trail of\nsuccess or a trail\nof things we can\nimprove. Right. When you\nstart writing this template,\nyou're probably going to\nmiss something. You're probably\ngoing to need to\nadd more detail somewhere.\nyou're gonna need to\ntweak it, and then\nmaybe you'll run into\na bug where, super\nimportant here, maybe you'll\nrun into a bug\nwhere you need a\nmore specific template to\naddress, maybe you have\na specific weird system\non your front end\nor a class of\nbugs, then you can\nspecialize your bug, right?\nAnd this is a\nhuge, huge solution for\nbig codebases. The\nmore code, the more\ncomplexity in your code\nbase, the more you'll\nwant to dial in\nyour reusable templates to\nsolve specific problems really\nwell, okay? And there\nare a bunch of\ntricks we can layer\non here. There are\nparallel agents. You can\ndelegate a lot of\nwork. You can use\nisolated sub agent context\nwindows. There's a lot\nof fancy tricks to\nhandling large codebases.\nAnd so let's refocus\non the last point.\nNumber one, we free\nup our context window.\nWe let our agent\nfocus. Number two, we\nforce our prompts, plans,\nand templates to be\nisolated, reusable, improvable assets\nwith zero dependencies. Okay.\nAnd then lastly, most\nimportantly, when we use\nfresh agents, right? When\nwe use brand new\nagents every single time\nlike this, right? When\nwe just open up\nbrand new instances over\nand over, we prepare\nfor true off device\nagentic coding. Remember, we're\nnot here to babysit\na single agent. We\nwant to improve our\nKPIs. Okay. We want\nto increase the size\nof work we can\nhand off. We want\nto decrease our attempts.\nWe want to increase\nour streak and we\nwant to decrease our\npresence KPI to zero.\nAll right. That means\nwe need to at\nthe right node of\nthe software development lifecycle,\nkick off new instances\nwith no previous context.\nOkay. Said another way,\nwe need to decouple\nour performance from the\nconversational context window. And\nby conversational, I mean\nmore than one prompt,\nright? We want one\nshot successes. And that\ndoesn't mean that our\nagents do a ton\nof work, right? That's\nthe whole point, right?\nSize goes up, but\nit does mean that\nour plans are prompts\nscaled up contains everything\nan agent needs to\nget started. And you\ncan really pack your\nplans in. Okay, right\nhere, I have a\nrelatively small 100 line\nplan that is going\nto, you know, you\ncan see all the\nfiles is modifying. See\nall the work that's\nhappening right here relatively\nsmall you can really\nscale up the size\nof both your template\nand then the plan\nthat gets generated from\nyour template right so\nthis is why we\nuse fresh agents over\nand over and over\nby running fresh agents\non meta prompting templates\nand planning assets we\ncan understand what went\nwrong by knowing exactly\nwhat was in the\ncontext window when i\nboot up this agent\nright when i when\ni set this up\ni know 100% I\nknow what the agent's\nperspective is. We fired\noff the implement markdown\nfile, which passed in\nour plan. So it\nread this file and\nthen it read this\nfile and then it\nwent to work. Okay.\nSo we have a\nvery, very good idea\nof the exact context,\nright? The perspective of\nour agent when we\nstarted. All right. So\nultimately the reason for\nthis booting up new\nagents over and over\nand over, we want\nto move toward true,\noff-device Agentic coding. If\nyou do this right,\nit will completely differentiate\nyour engineering from the\nrest. So we can\nSQL injection step. We\nhave another test coming\nup there, manual test\nscript. That all looks\ngood. This is a\nreally big idea. We're\ngoing to be working\nwith different types of\nprompts, meta prompts, templates,\nand higher order prompts\nwhere we're passing in\nprompts into prompts to\nleverage and generate outcomes.\nOkay. We have a\nnew primitive to work\nwith here, right? We\nhave a gentic prompts\nthanks to the core\nfour where we can\nexecute arbitrary tools, our\nagent, Claude Code, with\nthe powerful models it\nhas is smart enough\nto know how to\ndo a lot of\nwork over a long\nperiod of time. As\nyou can see here\nwith this looks like\nour task just got\ncompleted. This new task\nwas implemented. We got\ntests. We got read\nme updates just like\nwe asked everything is\nhere. And of course\nwe have that final\nreport step. It's running\nthat get diff and\ncheck this out. It's\nchecking its own work\nright self validation. It\nhas two issues it\nneeds to fix here.\nIt's going to fix\nthem automatically right. This\nis the power. Of\ntemplating your engineering. I\nstill haven't lifted a\nfinger. I have stopped\ncoding. I barely did\nanything with the plan,\nright? So this is\nreally powerful. I built\nthese tactics for you\nto be in a\nvery specific configuration so\nthat you can think\nabout these tactics every\nsingle day on the\nground as you're engineering,\nright? This is Tactical\nagentic coding. Think about\nthese every single day\nyou're engineering boots on\nthe ground. Stop coding,\ntake your agent's perspective,\nand now template your\nengineering. All right. If\nyou do this right,\nit will change everything.\nThis is a massive\ndifferentiator. Having agents run\nloose on your code\nbase without structure, without\nknowing how you do\nthings is a plan\nfor failure. It will\nnot scale into the\ntrue agentic engineering future\nand to the true\nagentic engineers we are\naiming to become. As\nyou progress through each\nlesson here, You'll become\nan engineer they can't\nreplace. Okay. So this\nis one agent isolated\nright here. It's going\nto keep solving problems\nover and over. This\nidea of refreshing your\nagent every single time\nyou want to run\nis super, super important,\nright? This enables true\noff-device Agentic Coding. Let\nme just show you\none more example of\nthat. Our bug is\nstill getting smashed here.\nWe're going to let\nthis run. And then\nof course we'll validate\nthe work at the\nend. We're moving toward\nAutomating the full software\ndevelopment lifecycle. So how\nwill we build features\nend to end? Do\nwe, the engineer, sit\ndown and type code?\nWe know that that's\nnot the case, right?\nWe're going to stop\ncoding. We don't even\nwant to type the\nplan ourselves. Can leverage\nagentics to look through\nour codebase to\nhelp us plan and\nthen we can of\ncourse you know review\nthe plans review our\ntemplates that generate the\nplan so how are\nwe going to do\nthis end to end\nwe won't be able\nto open up the\nterminal we need a\nkey feature that we've\ndiscussed that really differentiates\nagentic coding so we\nwant to build features\nend to end we\nneed a feature that\nlets us run our\nagents without us being\nthere and in order\nto do that that\nmeans we need to\nbe able to run\nour agent right in\nthe terminal because we\ncan access the terminal\nanywhere right local environments\ncloud environments so on\nand so forth there's\ngoing to be a\nbig hot topic in\nour next lesson I\njust want to show\nyou the beginning of\nthis right here so\nI'm going to open\nup a new file\nand I'm going to\nstart writing out our\nprompt so here we\nhave yet another template\nwhere we have encoded\nour engineering best practices\nin to the template,\nright? We're using this\nsyntax here to have\nthe agent update specific\nparts of the template\nto create the plan,\nright? And this is\nall based on the\ninstructions. You know, you\nhave full access to\nthis codebase, take\nthese, make them your\nown, make a couple\nof tweaks and just\nget one running. You\nwanna get to that\nfirst aha moment as\nfast as possible. Let's\nturn our attention back\nto our blank files.\nWe're gonna run slash\nwas running. And we\ncan of course also\ngo into the server,\nwe can CD into\napp server, Then we\ncan, of course, ourselves\njust run UV run\npie test. All right,\nthere it is. So\nwe know that all\nthis is working. We\nhave this brand new\ntest SQL injection file.\nWe can look through\nit and validate all\nthe work that was\ndone. This is great.\nWe're not gonna do\nthat here. It's not\na good use of\nour time here, but\nwe can see, you\nknow, even through some\nmanual testing and validation,\nwe have our concat\nworking. We have all\nof our tests running.\nOur agent is properly\ncomprehensively building plans from\nour templates. It's acknowledging\nand running the self\nvalidation steps to close\nthe loop. This is\na big idea. Huge,\nhuge leverage point of\nAgentic Coding. We're going\nto talk about it\nhas its own dedicated\nlesson because this idea\nis so important that\nyou can see here.\nWe're just doing that\nhere. Update documentation, conference\nof tests, It's all\nhere. It's all in\nthe plan. It's all\neasily reproducible. If we\nwanted to tweak the\nplan, we could. If\nwe wanted to tweak\nthe higher order prompt,\nif we wanted to\ntweak the template that\ngenerates the plan, we\ntotally could. But it's\nall here for us,\nright? So let me\nshow you one more\nthing here. This encapsulates\neverything we've done here\nand showcases it to\nwhat's coming next. So\nwe have this feature,\nright, slash feature. We\nof course write our\nprompt and slash feature\nis another template. That's\nalso a meta prompt,\nwrite a prompt that\ncreates a prompt. We\nhave the structure here\nspecifically built out for\ncreating new features, right?\nNet new features. This\nis very differentiated from,\nyou know, generating bugs\nor chores, right? These\nare not the same\ntypes of engineering work.\nSo you want to\ndifferentiate each one of\nthese. We're going to\nrun that, but we're\nnot going to run\nit inside of a\nmanual instance. Right? We\nwant this to run\non its own in\na box on some\ndevice somewhere else. Okay.\nSo what we're going\nto do is open\nup a terminal and\nwe're going to replicate\nthat by firing this\noff using claw code\nin its programmatic form.\nAll right. Here's what\nwe're going to do.\nWe're going to take\nthis prompt and we're\ngoing to wrap it\nhere. I'm going to\nsay claw dash P\nand then we're going\nto wrap this in\nquotes. We're going to\nescape these quotes here\nand then new line.\nWe're going to run\nthis in the terminal.\nSo we need something\nlike this. And for\nbrevity, I'm just going\nto paste this in\nand you can see\nexactly what's happening here,\nright? We're running this\nin programmatic mode, right?\nOutput format stream running\nin dangerously skip permissions.\nThis is going to\nwork just fine for\nnow. It's very low\nrisk. We're setting our\nmodel. We want verbose\nand then check this\nout. We're going to\nwrite the output. We're\ngoing to stream the\noutput into this file.\nLet's copy this. Go\nto the terminal. Fire\nit off. Okay. This\nline is where things\nare all going. I\nknow this looks weird.\nI know it might\nfeel uncomfortable. We don't\nsee our agent. We\ndon't know what it's\ndoing, but as we\nscale up, as we\nimprove our plan writing,\nas we learn the\ntemplate, our engineering, as\nwe know our agent's\nperspective, this is what\nwe want to do\nright across the entire\nsoftware development life cycle.\nThis prompt here represents\nthe planning phase. We\ncan of course embed\nmore prompts into the\nplanning phase, more agents\ninto the planning phase,\nbut we can do\nthat of across the\nsoftware development lifecycle to\nturn it into the\nagentic software development lifecycle\nso that our agents\nare operating this for\nus. So we are\nstreaming this output. So\nif we open up\nthe sidebar here, you\ncan see we have\na new JSONL file.\nLet's click that and\ncheck this out. Our\nagent is actively working\nright now and we're\ngetting the result reported.\nAll right. So this\nis this is live,\nright? If I swap\nfiles here, you can\nsee that this is\nslowly getting appended. All\nright. So this is\nline 22. Now we're\nat line 23, 24,\nand back and forth.\nThis is just scratching\nthe surface. This is\nbarely valuable compared to\nwhat we'll be able\nto do when we\nscale up one agent,\ntwo agents, five agents,\n10 agents across the\nsoftware development lifecycle. All\nright. Plans are critically\nimportant. Plans are prompts\nscaled. Great planning is\ngreat prompting. When you\nsave your plans into\nyour codebase, you\ncreate artifacts that you,\nyour team and your\nagents can reference. You\ncan also think your\nplans as staging environments\nfor code that will\nbe generated, right? It's\nthe code, it's the\nengineering work compressed into\nnatural language that your\nagent will expand. So\nthat's why plans are\nso important. Now, why\nare templates so important?\nAs we've discussed, templates\nlet you encode your\nengineering practices into your\ncodebase for, again,\nyou, your team, and\nmost importantly, your agents.\nWriting plans take time.\nAnd they're error prone,\nright? We as humans,\nwe are error prone.\nThat's okay. There's a\nnew best tool for\nthe job. We can\nnot only stop coding,\nbut we can reduce\nour writing and our\nplanning and our direct\nplanning by templating our\nengineering to let our\nagents write the first\nand sometimes final draft\nof our plans, as\nyou saw here in\nthis codebase. And\nif we look over,\nthis agent is still\nplanning. This is a\nentire feature. It takes\na lot more work.\nSo it's running really\nhigh class compute. Check\nthis out. And it's\nrunning in reasoning mode.\nWe, of course, activated\nreasoning mode, and it\nis planning this work\nfor us. If we\nopen up our spec,\nwe can see we\nhave query history panel,\nright? Our agent just\nwrote the first draft\nof this plan for\nus and maybe the\nfinal draft, okay? This\nis why templates are\nso important. We can\nsee the agent is\ndone. Now imagine this\nhappens in the cloud\nwhere agentically all you\ndo is pass in\nthe high level work\nthat you want done.\nAnd sometimes, you know,\nthe high level prompt\nisn't enough for a\nfeature, right? For something\nlarger. You might want\nmore detail here, right?\nThat's totally cool, right?\nThis is where human\nin the loop planning\nyour work is still\nultra important. Templating lets\nyou move faster, and\nlet your agent do\nthe hard work of\nlooking through your code\nbase, figuring out what\nneeds to go where,\nand you can template\nall of that. Another\ngreat reason to use\ntemplates, another reason why\ntemplates are so important,\nyou can, of course,\nimprove them. As you\nscale up your work\nand increase your size\nKPI, your feature prompts\nwill likely get bigger\nor they'll get more\nprecise, and that's great.\nYou'll be able to\nsolve more problems in\na better, more accurate\nway over and over\nand over, right? We\nget this self-improving loop\ninside of your code\nbase for your agents,\nall right? And then\nlast but not least,\nwhy are templates so\nimportant? button, you get\nto encode custom templates,\nright? These can be\nanything chore bug feature.\nThese are just high\nlevel generic units, generic\nclasses of engineering work.\nBut you can really\ndial this in. If\nyou want to, you\ncan say this is\nthe front end feature\nfor these sets of\npages, right? Or these\nsub pages on my\nfront end. Or you\ncan say, here's a\nchore template for our\ndatabase migration system. Or\nhere's a bug resolver\nfor our research notebook,\nyou know, system, whatever,\nwhatever it is, right?\nYou can really dial\nin and create custom\ntemplates for everything. And\ntruly the more custom\nyour templates are, the\nmore unique your engineering\ngets. And that means\nyour work, your code\nbase, your products is\nlikely more differentiated, but\nthose are the reasons,\nright? So templating, is\nultra, ultra powerful. All\nright, so you can\nsee our agent finished.\nWe can scroll down\nto this new spec,\nquery history panel and\ncheck this out, super\ncomprehensive. Let's open this\nup in preview mode.\nSo we have a\nvery comprehensive brand new\nfeature plan, query history\nside panel, great description,\nAgentic Coding without all of\nthese and the upcoming\ntactics, which will take\nthis to the, to\nthe next, next level.\nOkay. We're building on\ntop of the tactics\nwe're building on top\nof principles of AI\ncoding. We're putting it\nall together and we\nare automating our work\nAnd we are learning\nto use agents. We're\nbecoming agentic engineers. We\nbuild the system that\nbuilds the system. I\nhope you can see\nhow templating, how higher\norder prompts and how\nmeta prompting and planning\nis a key, key\naspect of becoming an\nagentic engineer. So what's\nnext in our next\nlesson in lesson four.\nWe lean into programmatic\nagents. We lean in\nto true off-device Agentic\ncoding. In order to\ndo this, we need\nto learn how to\ntrigger our agents and\nlet them run in\ntheir own environments. We'll\ndo this by tapping\ninto the highest composition\nlevel and the greatest\nleverage point of agentic\ncoding, AI developer workflows.\nOnce you start to\nunderstand all the ways\nyour agent can operate\nalongside you and how\nto improve them, not\nif, but when things\ngo wrong, right? This\nis engineering. Things will\ngo wrong. But in\nthe next lessons, you'll\nbe equipped with the\ntools to get back\non track and then\ntemplate your engineering so\nthat future agents stay\non track. This lesson\nputs you three steps\ncloser toward becoming an\nengineer they can't replace.\nGreat work here. Take\na moment, review some\nof the resources available\nto you in your\nloot box below, dial\nin, to this key\ntactic of agentic coding,\ntemplate your engineering. This\nis how you scale\nyour agents into your\ncodebase and solve\nyour domain specific problems.\nOkay. There's no hand\nwaving here. I guess,\nI guess there's a\nlot of hand waving,\nbut you get the\npoint, right? These tactics\nare key ideas you\ncan think of every\nsingle day you're engineering,\nright? Stop coding. Think\nfrom your agent's perspective,\ntemplate your engineering. All\nright. There is work\nto be done here\nin creating and building\nup great templates. But\nif you do this\nright, it will change\neverything. I'll see you\nin lesson four where\nwe'll learn to let\nyour product ship itself.",
  "summary": "This lesson introduces the third tactic: Template Your Engineering. The prompt is the most valuable skill any engineer can have - it is the medium for communicating with agentic tools. The lesson teaches how to convert successful plans into reusable templates (one of the 12 leverage points). Templates are stored in .claude/commands as slash commands. The lesson covers three types of prompts: Reusable Prompts (stored templates), Meta Prompts (prompts that generate prompts/plans), and Ad-hoc Prompts (one-time prompts). It demonstrates the plan-then-implement workflow: first use a meta prompt like /chore or /feature to generate a detailed plan, then use /implement to execute the plan. This separates planning from building and allows specialized prompts for different problem types (chores, bugs, features).",
  "key_concepts": "1. TEMPLATE YOUR ENGINEERING: The third tactic. Convert successful plans into reusable templates. Templates are one of the 12 leverage points of agentic coding that give you full control over how your agent solves problems.\n\n2. THE PROMPT IS EVERYTHING: The most valuable skill any engineer can have. It is the medium for communicating with agentic tools and all generative AI technology. Great planning is great prompting.\n\n3. THREE TYPES OF PROMPTS: (1) Reusable Prompts - stored templates in .claude/commands as slash commands, (2) Meta Prompts - prompts that generate other prompts/plans, (3) Ad-hoc Prompts - one-time throwaway prompts.\n\n4. PLAN THEN IMPLEMENT WORKFLOW: Separate planning from building. First use a meta prompt (/chore, /bug, /feature) to generate a detailed plan saved to specs directory. Then use /implement to execute the plan. This two-phase approach increases success rates.\n\n5. PROBLEM CLASSIFICATION: Different problem types need different templates. Chores are simple maintenance tasks. Bugs require investigation and fixing. Features need comprehensive planning with requirements, context, and validation steps.\n\n6. META PROMPTS: Prompts that output prompts. They specify a format/template for the agent to fill out, creating detailed plans that become the input for the implementation phase. This scales your planning ability.\n\n7. SLASH COMMANDS: Templates stored in .claude/commands directory become slash commands (like /chore, /feature, /implement). Every great prompt contains a purpose at the top explaining what it does.\n\n8. VALIDATION LOOPS: Templates should include self-validating steps - running tests, checking the server starts, verifying the implementation. Embed testing as a lever of agentic coding.\n\n9. PLANS AS ARTIFACTS: When you save plans to your codebase (specs directory), you create artifacts that you, your team, and your agents can reference. Plans are like staging environments for code that will be generated.\n\n10. SCALING AGENTS: This approach enables scaling from one agent to multiple agents across the software development lifecycle. Templates and plans make it possible to hand off increasingly complex work to your agents."
}